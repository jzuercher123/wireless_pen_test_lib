# authentication_tools.py
# wireless_pen_test_lib/project_specific_utils/authentication_tools.py

import logging

class AuthenticationTools:
    """
    A class to provide authentication-related tools.
    """
    def __init__(self):
        """
        Initialize the AuthenticationTools.
        """
        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.info("AuthenticationTools initialized.")

    def decrypt_credentials(self, encrypted_data: str) -> dict:
        """
        Decrypts captured encrypted credentials.

        Args:
            encrypted_data (str): Encrypted credentials.

        Returns:
            dict: Decrypted credentials.
        """
        self.logger.debug("Decrypting credentials...")
        # Placeholder for decryption logic


        decrypted = {
            "username": "admin",
            "password": "password123"
        }
        self.logger.info("Credentials decrypted successfully.")
        return decrypted

    def authenticate(self, username: str, password: str) -> bool:
        """
        Authenticates the user with the provided credentials.

        Args:
            username (str): User's username.
            password (str): User's password.

        Returns:
            bool: True if authentication is successful, False otherwise.
        """
        self.logger.debug("Authenticating user...")
        # Placeholder for authentication logic
        authenticated = username == "admin" and password == "password123"
        if authenticated:
            self.logger.info("User authenticated successfully.")
        else:
            self.logger.warning("Authentication failed.")
        return authenticated

# custom_threading.py
import threading
from threading import Thread


class CustomThread(Thread):
    """

    """
    def __init__(self, func, args=(), kwargs={}):
        Thread.__init__(self)
        self.func = func
        self.args = args
        self.kwargs = kwargs

    def run(self):
        self.result = self.func(*self.args, **self.kwargs)


    def get_result(self):
        return self.result

    def set_result(self, result):
        self.result = result


# data_storage_manager.py
# wireless_pen_test_lib/project_specific_utils/data_storage_manager.py

import os
import json
import logging


class DataStorageManager:
    """
    A class to manage data storage and report generation.
    """
    def __init__(self, report_directory: str = "reports", filename="report.txt"):
        """
        Initialize the DataStorageManager with the specified report directory.

        Args:
            report_directory (str): Path to the directory where reports will be stored.
        """
        self.report_directory = report_directory
        os.makedirs(self.report_directory, exist_ok=True)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.info(f"DataStorageManager initialized for report directory: {self.report_directory}")
        self.filename = filename

    def generate_report(self, vulnerability_db: dict):
        """
        Generates a report based on the vulnerability database.

        Args:
            vulnerability_db (dict): Dictionary containing detected vulnerabilities.
        """
        self.logger.info("Generating reports...")
        # Ensure report directories exist
        json_dir = os.path.join(self.report_directory, "json")
        txt_dir = os.path.join(self.report_directory, "txt")
        os.makedirs(json_dir, exist_ok=True)
        os.makedirs(txt_dir, exist_ok=True)

        # JSON Report
        json_report_path = os.path.join(json_dir, "report.json")
        with open(json_report_path, 'w') as f:
            json.dump(vulnerability_db, f, indent=4)
        self.logger.info(f"JSON report generated at {json_report_path}")

        # TXT Report
        txt_report_path = os.path.join(txt_dir, "report.txt")
        with open(txt_report_path, 'w') as f:
            for scanner, vulnerabilities in vulnerability_db.get('scans', {}).items():
                f.write(f"Scanner: {scanner}\n")
                for vuln in vulnerabilities:
                    f.write(f"  - SSID: {vuln.get('ssid', 'N/A')}\n")
                    f.write(f"    BSSID: {vuln.get('bssid', 'N/A')}\n")
                    f.write(f"    Protocol: {vuln.get('protocol', 'N/A')}\n")
                    f.write(f"    Description: {vuln.get('description', 'N/A')}\n")
            for exploit, vulnerabilities in vulnerability_db.get('exploits', {}).items():
                f.write(f"Exploit: {exploit}\n")
                for vuln in vulnerabilities:
                    f.write(f"  - BSSID: {vuln.get('bssid', 'N/A')}\n")
                    f.write(f"    Description: {vuln.get('description', 'N/A')}\n")
                    f.write(f"    Action: {vuln.get('action', 'N/A')}\n")
        self.logger.info(f"TXT report generated at {txt_report_path}")


if __name__=="__main__":
    dsm = DataStorageManager()
    dsm.generate_report({
        'scans': {
            'WEPScanner': [
                {
                    'ssid': 'TestNet',
                    'bssid': '00:11:22:33:44:55',
                    'protocol': 'WEP',
                    'description': 'Weak WEP key detected.'
                }
            ]
        },
        'exploits': {
            'DeauthExploit': [
                {
                    'bssid': '00:11:22:33:44:55',
                    'description': 'Deauth attack successful.',
                    'action': 'Disconnect the client.'
                }
            ]
        }
    })
    print("Report generation completed.")

# network_interface_manager.py
# wireless_pen_test_lib/project_specific_utils/network_interface_manager.py

import subprocess
import logging

class NetworkInterfaceManager:
    """
    A class to manage network interfaces.
    """
    def __init__(self, interface: str = "wlan0mon"):
        """
        Initialize the NetworkInterfaceManager with the specified interface.

        Args:
            interface (str): Name of the wireless interface.
        """
        if not self.is_valid_interface(interface):
            raise ValueError(f"Invalid network interface: {interface}")
        self.interface = interface
        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.info(f"NetworkInterfaceManager initialized for interface: {self.interface}")

    def is_valid_interface(self, interface: str) -> bool:
        available_interfaces = self.get_available_interfaces()
        return interface in available_interfaces

    def get_available_interfaces(self) -> list:
        # This should be replaced with actual system call to list interfaces
        return ['wlan0mon', 'eth0', 'lo']

    def get_interface_mac(self) -> str:
        """
        Retrieves the MAC address of the wireless interface.

        Returns:
            str: MAC address of the interface.
        """
        try:
            result = subprocess.check_output(["ifconfig", self.interface], stderr=subprocess.STDOUT).decode()
            mac_address = result.split("ether ")[1].split(" ")[0]
            return mac_address
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Failed to get MAC address: {e.output.decode()}")
            return "00:00:00:00:00:00"

    def set_monitor_mode(self):
        """
        Sets the wireless interface to monitor mode.
        """
        self.logger.info(f"Setting interface {self.interface} to monitor mode.")
        try:
            subprocess.run(["sudo", "ifconfig", self.interface, "down"], check=True)
            subprocess.run(["sudo", "iwconfig", self.interface, "mode", "monitor"], check=True)
            subprocess.run(["sudo", "ifconfig", self.interface, "up"], check=True)
            self.logger.info(f"Interface {self.interface} set to monitor mode successfully.")
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Failed to set monitor mode: {e}")
            raise e

    def set_managed_mode(self):
        """
        Sets the wireless interface to managed mode.
        """
        self.logger.info(f"Setting interface {self.interface} to managed mode.")
        try:
            subprocess.run(["sudo", "ifconfig", self.interface, "down"], check=True)
            subprocess.run(["sudo", "iwconfig", self.interface, "mode", "managed"], check=True)
            subprocess.run(["sudo", "ifconfig", self.interface, "up"], check=True)
            self.logger.info(f"Interface {self.interface} set to managed mode successfully.")
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Failed to set managed mode: {e}")
            raise e

    def get_interface_status(self) -> str:
        """
        Retrieves the current status of the wireless interface.

        Returns:
            str: Current mode of the interface (e.g., Monitor, Managed).
        """
        try:
            result = subprocess.check_output(["iwconfig", self.interface], stderr=subprocess.STDOUT).decode()
            if "Mode:Monitor" in result:
                return "Monitor Mode"
            elif "Mode:Managed" in result:
                return "Managed Mode"
            else:
                return "Unknown Mode"
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Failed to get interface status: {e.output.decode()}")
            return "Unknown Mode"

# network_scanner.py
#!/usr/bin/env python3
import subprocess
import re
from scapy.all import srp, conf
from scapy.layers.l2 import ARP, Ether
import netifaces
import sys
import logging
import argparse

# Configure logging
logger = logging.getLogger('NetworkScanner')

def setup_logging(level):
    """
    Sets up logging with the specified level.
    """
    numeric_level = getattr(logging, level.upper(), None)
    if not isinstance(numeric_level, int):
        print(f"Invalid log level: {level}")
        sys.exit(1)
    logging.basicConfig(
        level=numeric_level,
        format='[%(asctime)s] %(levelname)s - %(name)s - %(message)s',
        handlers=[
            logging.StreamHandler(sys.stdout)
        ]
    )

def scan_wireless_networks(interface='wlan0'):
    """
    Scans for wireless networks using iwlist.

    Args:
        interface (str): The wireless interface to scan.

    Returns:
        List[dict]: A list of dictionaries containing SSID, BSSID, Signal Level, and Channel.
    """
    logger.info(f"Scanning for wireless networks on interface: {interface}")
    try:
        # Execute iwlist scan command
        scan_output = subprocess.check_output(['iwlist', interface, 'scanning'], stderr=subprocess.STDOUT, universal_newlines=True)
    except subprocess.CalledProcessError as e:
        logger.error(f"Failed to execute iwlist: {e.output}")
        return []

    # Parse the output
    cells = scan_output.split('Cell ')
    networks = []

    for cell in cells[1:]:
        ssid_search = re.search(r'ESSID:"(.*)"', cell)
        ssid = ssid_search.group(1) if ssid_search else 'Hidden'

        bssid_search = re.search(r'Address: ([\w:]+)', cell)
        bssid = bssid_search.group(1) if bssid_search else 'Unknown'

        signal_search = re.search(r'Signal level=(-?\d+) dBm', cell)
        signal = signal_search.group(1) + ' dBm' if signal_search else 'N/A'

        channel_search = re.search(r'Channel:(\d+)', cell)
        channel = channel_search.group(1) if channel_search else 'N/A'

        networks.append({
            'SSID': ssid,
            'BSSID': bssid,
            'Signal': signal,
            'Channel': channel
        })

    logger.info(f"Found {len(networks)} wireless networks.")
    return networks

def get_default_gateway_ip():
    """
    Retrieves the default gateway IP address.

    Returns:
        str: The default gateway IP.
    """
    gateways = netifaces.gateways()
    default_gateway = gateways.get('default')
    if default_gateway is None:
        logger.error("No default gateway found.")
        sys.exit(1)
    gateway_ip = default_gateway[netifaces.AF_INET][0]
    return gateway_ip

def get_network_prefix(interface):
    """
    Retrieves the network prefix (e.g., 192.168.1.0/24).

    Args:
        interface (str): The network interface.

    Returns:
        str: The network prefix.
    """
    addrs = netifaces.ifaddresses(interface)
    inet = addrs.get(netifaces.AF_INET)
    if not inet:
        logger.error(f"No IPv4 address found for interface {interface}.")
        sys.exit(1)
    ip_info = inet[0]
    ip_address = ip_info.get('addr')
    netmask = ip_info.get('netmask')
    if not ip_address or not netmask:
        logger.error(f"IP address or netmask not found for interface {interface}.")
        sys.exit(1)
    # Calculate CIDR notation
    cidr = sum([bin(int(x)).count('1') for x in netmask.split('.')])
    network_prefix = f"{ip_address}/{cidr}"
    return network_prefix

def scan_local_network(interface='eth0'):
    """
    Scans the local network for active devices using ARP requests.

    Args:
        interface (str): The network interface to use for scanning.

    Returns:
        List[dict]: A list of dictionaries containing IP and MAC addresses.
    """
    logger.info(f"Scanning local network on interface: {interface}")
    network = get_network_prefix(interface)
    logger.debug(f"Network prefix: {network}")

    # Create ARP packet
    arp = ARP(pdst=network)
    ether = Ether(dst="ff:ff:ff:ff:ff:ff")
    packet = ether/arp

    # Disable verbose in scapy
    conf.verb = 0

    try:
        result = srp(packet, timeout=3, iface=interface, inter=0.1)[0]
    except Exception as e:
        logger.error(f"Error during ARP scan: {e}")
        return []

    devices = []
    for sent, received in result:
        devices.append({
            'IP': received.psrc,
            'MAC': received.hwsrc
        })

    logger.info(f"Found {len(devices)} devices on the local network.")
    return devices

def get_active_interfaces():
    """
    Retrieves active network interfaces.

    Returns:
        List[str]: A list of active network interface names.
    """
    interfaces = netifaces.interfaces()
    active_interfaces = []
    for interface in interfaces:
        addrs = netifaces.ifaddresses(interface)
        if netifaces.AF_INET in addrs:
            active_interfaces.append(interface)
    return active_interfaces

def display_wireless_networks(networks):
    """
    Displays the list of wireless networks.

    Args:
        networks (List[dict]): List of wireless networks.
    """
    if not networks:
        logger.info("No wireless networks found.")
        return

    print("\n=== Wireless Networks ===")
    print(f"{'SSID':<30} {'BSSID':<20} {'Signal':<10} {'Channel':<8}")
    print("-" * 70)
    for net in networks:
        print(f"{net['SSID']:<30} {net['BSSID']:<20} {net['Signal']:<10} {net['Channel']:<8}")

def display_local_devices(devices):
    """
    Displays the list of devices on the local network.

    Args:
        devices (List[dict]): List of devices with IP and MAC addresses.
    """
    if not devices:
        logger.info("No devices found on the local network.")
        return

    print("\n=== Local Network Devices ===")
    print(f"{'IP Address':<20} {'MAC Address':<20}")
    print("-" * 40)
    for device in devices:
        print(f"{device['IP']:<20} {device['MAC']:<20}")

def parse_arguments():
    """
    Parses command-line arguments.

    Returns:
        argparse.Namespace: Parsed arguments.
    """
    parser = argparse.ArgumentParser(description="Network Devices Scanner Utility")
    parser.add_argument(
        '-w', '--wireless-interface',
        type=str,
        default=None,
        help="Specify the wireless interface to scan (e.g., wlan0). If not provided, the script will auto-detect."
    )
    parser.add_argument(
        '-e', '--ethernet-interface',
        type=str,
        default=None,
        help="Specify the Ethernet interface to scan (e.g., eth0). If not provided, the script will auto-detect."
    )
    parser.add_argument(
        '-l', '--log-level',
        type=str,
        default='INFO',
        help="Set the logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL). Default is INFO."
    )
    return parser.parse_args()

def main():
    args = parse_arguments()
    setup_logging(args.log_level)

    # Determine active wireless interface
    active_interfaces = get_active_interfaces()
    wireless_interfaces = [iface for iface in active_interfaces if 'wlan' in iface]

    if args.wireless_interface:
        wireless_interface = args.wireless_interface
        if wireless_interface not in wireless_interfaces:
            logger.error(f"Specified wireless interface '{wireless_interface}' is not active or not found.")
            sys.exit(1)
    else:
        if not wireless_interfaces:
            logger.error("No wireless interfaces found. Ensure your wireless adapter is connected.")
            sys.exit(1)
        wireless_interface = wireless_interfaces[0]

    networks = scan_wireless_networks(interface=wireless_interface)
    display_wireless_networks(networks)

    # Determine active Ethernet interface for local network scan
    ethernet_interfaces = [iface for iface in active_interfaces if 'eth' in iface or 'enp' in iface or 'eno' in iface]
    if args.ethernet_interface:
        ethernet_interface = args.ethernet_interface
        if ethernet_interface not in ethernet_interfaces:
            logger.error(f"Specified Ethernet interface '{ethernet_interface}' is not active or not found.")
            sys.exit(1)
    else:
        if not ethernet_interfaces:
            logger.error("No Ethernet interfaces found. Ensure you are connected to a network.")
            sys.exit(1)
        ethernet_interface = ethernet_interfaces[0]

    devices = scan_local_network(interface=ethernet_interface)
    display_local_devices(devices)

if __name__ == "__main__":
    main()


# save_project_files_to_txt_file.py
import os
import sys
import argparse
import logging


def setup_logging(verbosity):
    """
    Set up logging configuration based on verbosity level.
    """
    log_levels = {
        0: logging.ERROR,
        1: logging.WARNING,
        2: logging.INFO,
        3: logging.DEBUG
    }
    level = log_levels.get(verbosity, logging.DEBUG)

    logging.basicConfig(
        level=level,
        format='%(asctime)s - %(levelname)s - %(message)s',
        handlers=[
            logging.StreamHandler(sys.stdout)
        ]
    )


def get_default_exclusions():
    """
    Returns a set of default directory names to exclude from processing.
    """
    return {
        '.venv', 'venv', 'env', 'ENV', '__pycache__', 'site-packages',
        'build', 'dist', '.git', '.svn', '.hg', '.idea', '.mypy_cache',
        '.pytest_cache', '.tox', '.eggs', 'egg-info'
    }


def collect_py_files(project_dir, output_file, exclude_dirs):
    """
    Walk through the project directory recursively, find all .py files
    excluding specified directories, and append their contents to the
    output_file with the filename as a comment.
    """
    try:
        with open(output_file, 'w', encoding='utf-8') as outfile:
            logging.info(f"Opened output file: {output_file} for writing.")
            for root, dirs, files in os.walk(project_dir):
                logging.debug(f"Walking through directory: {root}")

                # Modify dirs in-place to exclude unwanted directories
                dirs_to_remove = [d for d in dirs if d in exclude_dirs]
                for d in dirs_to_remove:
                    dirs.remove(d)
                    logging.debug(f"Excluded directory from traversal: {d}")

                for file in files:
                    if file.endswith('.py'):
                        file_path = os.path.join(root, file)
                        relative_path = os.path.relpath(file_path, project_dir)
                        try:
                            with open(file_path, 'r', encoding='utf-8') as infile:
                                content = infile.read()
                            # Write the filename as a comment
                            outfile.write(f"# {relative_path}\n")
                            logging.debug(f"Writing header for file: {relative_path}")
                            # Write the file content
                            outfile.write(content + "\n\n")
                            logging.info(f"Appended: {relative_path}")
                        except FileNotFoundError:
                            logging.error(f"File not found: {file_path}")
                        except PermissionError:
                            logging.error(f"Permission denied: {file_path}")
                        except Exception as e:
                            logging.error(f"Failed to read {file_path}: {e}")
        logging.info(f"Successfully wrote to output file: {output_file}")
    except PermissionError:
        logging.critical(f"Permission denied when trying to write to output file: {output_file}")
        sys.exit(1)
    except Exception as e:
        logging.critical(f"An unexpected error occurred while opening the output file: {e}")
        sys.exit(1)


def main():
    parser = argparse.ArgumentParser(
        description="Recursively collect all user-created .py files in a project and append their contents to a single .txt file."
    )
    parser.add_argument(
        'project_directory',
        nargs='?',
        default='.',
        help='Path to the Python project directory (default: current directory)'
    )
    parser.add_argument(
        '-o', '--output',
        default='combined_py_files.txt',
        help='Name of the output .txt file (default: combined_py_files.txt)'
    )
    parser.add_argument(
        '-v', '--verbose',
        action='count',
        default=2,
        help='Increase output verbosity (e.g., -v, -vv, -vvv)'
    )
    parser.add_argument(
        '-e', '--exclude',
        nargs='*',
        default=[],
        help='Additional directories to exclude from processing (space-separated)'
    )

    args = parser.parse_args()

    setup_logging(args.verbose)

    project_dir = os.path.abspath(args.project_directory)
    output_file = os.path.abspath(args.output)

    logging.info(f"Project Directory: {project_dir}")
    logging.info(f"Output File: {output_file}\n")

    if not os.path.isdir(project_dir):
        logging.critical(f"The specified project directory does not exist or is not a directory: {project_dir}")
        sys.exit(1)

    # Combine default exclusions with user-specified exclusions
    exclude_dirs = get_default_exclusions().union(set(args.exclude))
    logging.debug(f"Directories to exclude: {exclude_dirs}")

    collect_py_files(project_dir, output_file, exclude_dirs)

    logging.info("\nAll .py files have been processed.")
    logging.info(f"Combined file saved as: {output_file}")


if __name__ == "__main__":
    main()


# __init__.py


